#pragma kernel kernel_upsample


int source_width;
int source_height;

int target_width;
int target_height;

Texture2D<float4> Input;
SamplerState sampler_Input;
RWTexture2D<float4> Output;


Texture2D<float4> NormalTex;
SamplerState sampler_NormalTex; 
Texture2D<float4> DepthTex;
SamplerState sampler_DepthTex; 
Texture2D<float4> Albedo;
Texture2D<float4> MotionVectors;

bool IsValid(float CenterDepth, float3 CenterNormal, float2 Uv) {
    if(Uv.x > 1.0f || Uv.y > 1.0f || Uv.x < 0 || Uv.y < 0) return false;
    bool DT = abs(CenterDepth - DepthTex.SampleLevel(sampler_DepthTex, Uv, 0).x) < 0.001f;
    bool NT = dot(CenterNormal, NormalTex.SampleLevel(sampler_NormalTex, Uv, 0).xyz * 2.0f - 1.0f) < 0.99f;

    return DT && NT;
}

[numthreads(16,16,1)]
void kernel_upsample (int3 id : SV_DispatchThreadID)
{
    if (id.x >= target_width || id.y >= target_height) return;
    

    float2 UV = float2(id.xy) / float2(target_width, target_height);
    float2 texel = 1.0f / float2(target_width, target_height);
    float2 texel2 = 1.0f / float2(source_width, source_height);
    float2 newUV = UV - MotionVectors[id.xy].xy;
    float CenterDepth = DepthTex.SampleLevel(sampler_DepthTex, newUV, 0).x;
    float3 CenterNormal = NormalTex.SampleLevel(sampler_NormalTex, newUV, 0).xyz * 2.0f - 1.0f;
    float3 TotalChange = Input.SampleLevel(sampler_Input, newUV, 0).xyz;
    int ConfirmedSamples = 0;

    for(int i = -1; i <= 1; i++) {
        [unroll]for(int j = -1; j <= 1; j++) {
            if(i == 0 && j == 0) continue;
            [branch]if(IsValid(CenterDepth, CenterNormal, newUV + float2(texel2.x * i, texel2.y * j))) {
                TotalChange += Input.SampleLevel(sampler_Input, newUV + texel2 * float2(i,j), 0).xyz;
                ConfirmedSamples++;
            }
        }
    }
    if(CenterDepth == 0) Output[id.xy] = float4(Input.SampleLevel(sampler_Input, newUV, 0).xyz, 1.0f);
    else Output[id.xy] = float4((TotalChange / (ConfirmedSamples + 1)) * Albedo[id.xy].xyz * 2.0f,1.0f);
}