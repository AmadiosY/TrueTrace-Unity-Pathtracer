// Upgrade NOTE: commented out 'float4x4 _CameraToWorld', a built-in variable
// Upgrade NOTE: replaced '_CameraToWorld' with 'unity_CameraToWorld'


#include "UnityCG.cginc"

#define GoldenAngle 2.39996323
// #define UseSkyBox//Comment out to have no skybox and use precomputed atmosphere
#define UseReflectionReproject
// #define ExtraSampleValidation

// float4x4 _CameraToWorld;
float4x4 _CameraInverseProjection;
float4x4 ViewMatrix;
int frames_accumulated;
uniform int CurBounce;
uniform int MaxBounce;

uint screen_width;
uint screen_height;

int pixel_index;

int lighttricount;

int unitylightcount;

bool UseRussianRoulette;
bool UseNEE;
bool UseDoF;
bool UseRestir;
bool UsePermutatedSamples;

bool DoVoxels;
int VoxelOffset;

float3 Up;
float3 Right;
float3 Forward;
float focal_distance;
float AperatureRadius;
int ReSTIRGIUpdateRate;

RWTexture2D<float4> RandomNums;

struct BufferSizeData {   
    int tracerays;
    int rays_retired;
    int brickmap_rays_retired;
    int shade_rays;
    int shadow_rays;
    int shadow_rays_retired;
    int brickmap_shadow_rays_retired;
    int heighmap_rays_retired;
};


struct RayData {//128 bit aligned
    float3 origin;
    float3 direction;

    uint4 hits;
    uint PixelIndex;//need to bump this back down to uint1
    int HitVoxel;//need to shave off 4 bits
    float last_pdf;
    int PrevIndex;//Need for padding, slightly increases performance
};

struct ShadowRayData {
    float3 origin;
    float3 direction;
    float3 illumination;
    float3 RadianceIncomming;
    uint PixelIndex;
    float t;
    bool PrimaryNEERay;
    float LuminanceIncomming;
};

struct LightTriangleData {
    float3 pos0;
    float3 posedge1;
    float3 posedge2;
    float3 Norm;

    float3 radiance;
    float sumEnergy;
    float pdf;
    float area;
};

StructuredBuffer<LightTriangleData> LightTriangles;

struct CudaTriangle {
    float3 pos0;
    float3 posedge1;
    float3 posedge2;

    float3 norm0;
    float3 normedge1;
    float3 normedge2;

    float3 tan0;
    float3 tanedge1;
    float3 tanedge2;

    float2 tex0;
    float2 texedge1;
    float2 texedge2;

    uint MatDat;
};

struct Ray {
    float3 origin;
    float3 direction;
    float3 direction_inv;
};

struct RayHit {
    float t;
    float u, v;
    int mesh_id;
    int triangle_id;
};

struct ColData {
    float3 throughput;
    float3 Direct;
    float3 Indirect;
    float3 PrimaryNEERay;
};

struct SHData {
    float4 shY;
    float2 CoCg;
};

struct GIReservoir {
    float3 RadianceDirect;
    float W;
    float3 RadianceIndirect;
    float M;
    float3 SecondaryHitPosition;
    float3 SecondaryHitDirectionOut;
    float3 NEERay;
    int HistoricFrame;
    int HistoricID;
    float3 BaseColor;
    int MaterialIndex;
    float RadianceIncomming;
    int2 ThisCase;
    int SecondaryNormal;
    float3 NEEPosition;
};
RWStructuredBuffer<GIReservoir> CurrentReservoirGI;
RWStructuredBuffer<GIReservoir> PreviousReservoirGI;

struct PerMatInfo {
    float Specular;
    float Roughness;
    float Clearcoat;
    float ClearCoatGloss;
    float Metallic;
    float3 Albedo;
};
RWStructuredBuffer<PerMatInfo> MatModifiers;
RWStructuredBuffer<PerMatInfo> MatModifiersPrev;

RWStructuredBuffer<SHData> SH;

int curframe;
RWTexture2D<float4> Result;

RWStructuredBuffer<ShadowRayData> ShadowRaysBuffer;
RWStructuredBuffer<RayData> GlobalRays1;
RWStructuredBuffer<RayData> GlobalRays2;
RWStructuredBuffer<ColData> GlobalColors;
RWStructuredBuffer<BufferSizeData> BufferSizes;

StructuredBuffer<CudaTriangle> AggTris;

float3 project_SH_irradiance(SHData sh, float3 N)
{
    float d = dot(sh.shY.xyz, N);
    float Y = 2.0 * (1.023326 * d + 0.886226 * sh.shY.w);
    Y = max(Y, 0.0);

    sh.CoCg *= Y * 0.282095 / (sh.shY.w + 1e-6);

    float   T       = Y - sh.CoCg.y * 0.5;
    float   G       = sh.CoCg.y + T;
    float   B       = T - sh.CoCg.x * 0.5;
    float   R       = B + sh.CoCg.x;

    return max(float3(R, G, B), 0.0);
}

SHData irradiance_to_SH(float3 color, float3 dir)
{
    SHData result;

    float   Co      = color.r - color.b;
    float   t       = color.b + Co * 0.5;
    float   Cg      = color.g - t;
    float   Y       = max(t + Cg * 0.5, 0.0);

    result.CoCg = float2(Co, Cg);

    float   L00     = 0.282095;
    float   L1_1    = 0.488603 * dir.y;
    float   L10     = 0.488603 * dir.z;
    float   L11     = 0.488603 * dir.x;

    result.shY = float4 (L11, L1_1, L10, L00) * Y;

    return result;
}

float3 SH_to_irradiance(SHData sh)
{
    float   Y       = sh.shY.w / 0.282095;

    float   T       = Y - sh.CoCg.y * 0.5;
    float   G       = sh.CoCg.y + T;
    float   B       = T - sh.CoCg.x * 0.5;
    float   R       = B + sh.CoCg.x;

    return max(float3(R, G, B), 0.0);
}

SHData init_SH()
{
    SHData result;
    result.shY = 0;
    result.CoCg = 0;
    return result;
}

void accumulate_SH(inout SHData accum, SHData b, float scale)
{
    accum.shY += b.shY * scale;
    accum.CoCg += b.CoCg * scale;
}

SHData mix_SH(SHData a, SHData b, float s)
{
    SHData result;
    result.shY = lerp(a.shY, b.shY, s);
    result.CoCg = lerp(a.CoCg, b.CoCg, s);
    return result;
}



Ray CreateRay(float3 origin, float3 direction) {
    Ray ray;
    ray.origin = origin;
    ray.direction = direction;
    ray.direction_inv = rcp(direction);
    return ray;
}

RayHit CreateRayHit() {
    RayHit hit;
    hit.t = 1000000000;
    hit.u = 0;
    hit.v = 0;
    hit.mesh_id = 0;
    hit.triangle_id = 0;
    return hit;
}

void set(int index, const RayHit ray_hit) {
    uint uv = (int)(ray_hit.u * 65535.0f) | ((int)(ray_hit.v * 65535.0f) << 16);

    GlobalRays1[index].hits = uint4(ray_hit.mesh_id, ray_hit.triangle_id, asuint(ray_hit.t), uv);
}

RayHit get(int index) {
    const uint4 hit = GlobalRays1[index].hits;

    RayHit ray_hit;

    ray_hit.mesh_id = hit.x;
    ray_hit.triangle_id = hit.y;

    ray_hit.t = asfloat(hit.z);

    ray_hit.u = (float)(hit.w & 0xffff) / 65535.0f;
    ray_hit.v = (float)(hit.w >> 16) / 65535.0f;

    return ray_hit;
}

inline void set2(int index, const RayHit ray_hit) {
    uint uv = (uint)(ray_hit.u * 65535.0f) | ((int)(ray_hit.v * 65535.0f) << 16);

    GlobalRays2[index].hits = uint4(ray_hit.mesh_id, ray_hit.triangle_id, asuint(ray_hit.t), uv);
}

inline RayHit get2(int index) {
    const uint4 hit = GlobalRays2[index].hits;

    RayHit ray_hit;

    ray_hit.mesh_id = hit.x;
    ray_hit.triangle_id = hit.y;

    ray_hit.t = asfloat(hit.z);

    ray_hit.u = (float)(hit.w & 0xffff) / 65535.0f;
    ray_hit.v = (float)(hit.w >> 16) / 65535.0f;

    return ray_hit;
}


uint hash_with(uint seed, uint hash) {
    // Wang hash
    seed = (seed ^ 61) ^ hash;
    seed += seed << 3;
    seed ^= seed >> 4;
    seed *= 0x27d4eb2d;
    return seed;
}
uint pcg_hash(uint seed) {
    uint state = seed * 747796405u + 2891336453u;
    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;
    return (word >> 22u) ^ word;
}


uint packUnormArb(const float3 data2) {
    const uint4 bits = uint4(10,10,10,0);
    const float4 data = float4(data2, 0);
    float4 mull = exp2(float4(bits)) - 1.0;

    uint4 shift = uint4(0, bits.x, bits.x + bits.y, bits.x + bits.y + bits.z);
    uint4 shifted = uint4(data * mull + 0.5) << shift;

    return shifted.x | shifted.y | shifted.z | shifted.w;
}

float3 unpackUnormArb(const uint pack) {
    const uint4 bits = uint4(10,10,10,0);
    uint4 maxValue  = uint4(exp2(bits) - 1);
    uint4 shift     = uint4(0, bits.x, bits.x + bits.y, bits.x + bits.y + bits.z);
    uint4 unshifted = pack >> shift;
    unshifted = unshifted & maxValue;

    return normalize((float4(unshifted).xyz * 1.0 / float4(maxValue).xyz).xyz * 2.0f - 1.0f);
}

uniform bool UseASVGF;
bool UseReSTIRGI;

float2 random(uint samdim) {
    [branch]if(UseASVGF || (UseReSTIRGI && ReSTIRGIUpdateRate != 0)) {
        uint2 pixid = uint2(pixel_index % screen_width, pixel_index / screen_width);
        uint hash = pcg_hash(((uint)RandomNums[pixid].y * (uint)112 + samdim) * (MaxBounce + 1) + CurBounce);

        const static float one_over_max_unsigned = asfloat(0x2f7fffff);


        float x = hash_with((uint)RandomNums[pixid].x, hash) * one_over_max_unsigned;
        float y = hash_with((uint)RandomNums[pixid].x + 0xdeadbeef, hash) * one_over_max_unsigned;

        return float2(x,y);
        } else {
            uint hash = pcg_hash((pixel_index * (uint)204 + samdim) * (MaxBounce + 1) + CurBounce);

            const static float one_over_max_unsigned = asfloat(0x2f7fffff);


            float x = hash_with(frames_accumulated, hash) * one_over_max_unsigned;
            float y = hash_with(frames_accumulated + 0xdeadbeef, hash) * one_over_max_unsigned;

            return float2(x,y);
        }
    }

    uint rng_state;

    uint rand_lcg()
    {
    // LCG values from Numerical Recipes
    rng_state = 1664525 * rng_state + 1013904223;
    return rng_state;
}

uint rand_xorshift()
{
    // Xorshift algorithm from George Marsaglia's paper
    rng_state ^= (rng_state << 13);
    rng_state ^= (rng_state >> 17);
    rng_state ^= (rng_state << 5);
    return rng_state;
}


Texture2D<float2> MotionVectors;
SamplerState sampler_MotionVectors;


#pragma kernel GenerateASVGF 
static const float PI = 3.14159265f;

Ray CreateCameraRay(float2 uv) {
    // Transform the camera origin to world space
    float3 origin = mul(unity_CameraToWorld, float4(0.0f, 0.0f, 0.0f, 1.0f)).xyz;
    
    // Invert the perspective projection of the view-space position
    float3 direction = mul(_CameraInverseProjection, float4(uv, 0.0f, 1.0f)).xyz;
    // Transform the direction from camera to world space and normalize
    direction = mul(unity_CameraToWorld, float4(direction, 0.0f)).xyz;
    direction = normalize(direction);   
    [branch]if(UseDoF) {
        float3 cameraForward = mul(_CameraInverseProjection, float4(0,0, 0.0f, 1.0f)).xyz;
        // Transform the direction from camera to world space and normalize
        float4 sensorPlane;
        sensorPlane.xyz = cameraForward;
        sensorPlane.w = -dot(cameraForward, (origin - cameraForward));

        float t = -(dot(origin, sensorPlane.xyz) + sensorPlane.w) / dot(direction, sensorPlane.xyz);
        float3 sensorPos = origin + direction  * t;

        float3 cameraSpaceSensorPos = mul(ViewMatrix, float4(sensorPos, 1.0f)).xyz;

        // elongate z by the focal length
        cameraSpaceSensorPos.z *= focal_distance;

        // convert back into world space
        sensorPos = mul(unity_CameraToWorld, float4(cameraSpaceSensorPos, 1.0f)).xyz;

        float angle = random(6).x * 2.0f * PI;
        float radius = sqrt(random(6).y);
        float2 offset = float2(cos(angle), sin(angle)) * radius * AperatureRadius;

        float3 p = origin + direction * (focal_distance);

        float3 aperturePos = origin + Right * offset.x + Up * offset.y;

        origin = aperturePos;
        direction = normalize(p - origin);
    }


    return CreateRay(origin, direction);
}


RWStructuredBuffer<Ray> Rays;

[numthreads(256,1,1)]
void GenerateASVGF (uint3 id : SV_DispatchThreadID) {

    if(id.x >= screen_width || id.y >= screen_height) return;
    pixel_index = id.y * screen_width + id.x;
    float2 jitter = (random(1) - 0.5f);
    // float2 uv = float2((id.xy) / float2(screen_width, screen_height) * 2.0f - 1.0f);
    // Ray ray = CreateCameraRay(uv);
    float2 pos_prev = ((float2(id.xy) + 0.5) * float2(rcp(screen_width), rcp(screen_height)) - MotionVectors.SampleLevel(sampler_MotionVectors, id.xy / float2(screen_width, screen_height), 0).xy) * float2(screen_width, screen_height);
    int2 pp = int2(floor(pos_prev));

    const static RayHit tempray = CreateRayHit();

    set(pixel_index, tempray);
    GlobalRays1[pixel_index].origin = Rays[pixel_index].origin;
    GlobalRays1[pixel_index].direction = Rays[pixel_index].direction;
    GlobalRays1[pixel_index].PixelIndex = id.x + id.y * screen_width;
    GlobalRays1[pixel_index].HitVoxel = 0;
    GlobalRays1[pixel_index].last_pdf = 0;
    GlobalRays1[pixel_index].PrevIndex = pp.x + pp.y * screen_width;
    GlobalColors[pixel_index].throughput = float3(1.0f, 1.0f, 1.0f);
    GlobalColors[pixel_index].Direct = float3(0.0f, 0.0f, 0.0f);
    GlobalColors[pixel_index].Indirect = float3(0.0f, 0.0f, 0.0f);
    GlobalColors[pixel_index].PrimaryNEERay = float3(0.0f, 0.0f, 0.0f);
    // GlobalColors[pixel_index].RadianceIncomming = 0;
    SH[pixel_index] = init_SH();
}

#pragma kernel Generate

[numthreads(256,1,1)]
void Generate (uint3 id : SV_DispatchThreadID) {

    if(id.x >= screen_width || id.y >= screen_height) return;
    static const ColData InitCol = {1,1,1,0,0,0,0,0,0,0,0,0};
    pixel_index = id.y * screen_width + id.x;
    float2 jitter = (random(1) - 0.5f);
    float2 uv = float2((id.xy + jitter) / float2(screen_width, screen_height) * 2.0f - 1.0f);
    Ray ray = CreateCameraRay(uv);

    const static RayHit tempray = CreateRayHit();
    if(UseReSTIRGI) {
        float2 pos_prev = ((float2(id.xy) + 0.5) * float2(rcp(screen_width), rcp(screen_height)) - MotionVectors.SampleLevel(sampler_MotionVectors, id.xy / float2(screen_width, screen_height), 0).xy) * float2(screen_width, screen_height);
        int2 pp = int2(floor(pos_prev));
        GlobalRays1[pixel_index].PrevIndex = pp.x + pp.y * screen_width;
    }

    set(pixel_index, tempray);
    GlobalRays1[pixel_index].origin = ray.origin;
    GlobalRays1[pixel_index].direction = ray.direction;
    GlobalRays1[pixel_index].PixelIndex = id.x + id.y * screen_width;
    GlobalRays1[pixel_index].HitVoxel = 0;
    GlobalRays1[pixel_index].last_pdf = 0;
    GlobalColors[pixel_index] = InitCol;
    
}

RWTexture2D<float4> TempPosTex;
Texture2D<float3> NormalTex;
SamplerState sampler_NormalTex;
Texture2D<float4> AlbedoTex;
SamplerState sampler_AlbedoTex;
RWTexture2D<int> TempNormTex;
RWTexture2D<float4>TempAlbedoTex;

RWTexture2D<int> RenderMaskTex;

#pragma kernel kernel_trace 

static const float ONE_OVER_PI = 0.318309886548;
static const float EPSILON = 1e-8;

struct MyMeshDataCompacted {
    float4x4 Transform;
    float4x4 Inverse;
    int TriOffset;
    int NodeOffset;
    int MaterialOffset;
        int mesh_data_bvh_offsets;//could I convert this an int4?
        uint IsVoxel;
        int3 Size;
        int LightTriCount;
        float LightPDF;
    };

    struct BVHNode8Data {
        float3 node_0xyz;
        uint node_0w;
        uint4 node_1;
        uint4 node_2;
        uint4 node_3;
        uint4 node_4;
    };

    StructuredBuffer<BVHNode8Data> cwbvh_nodes;
    StructuredBuffer<BVHNode8Data> VoxelTLAS;
    StructuredBuffer<MyMeshDataCompacted> _MeshData;


    struct TrianglePos {
        float3 pos0;
        float3 posedge1;
        float3 posedge2;
    };

    inline TrianglePos triangle_get_positions(const int ID) {
        TrianglePos tri;
        tri.pos0 = AggTris[ID].pos0;
        tri.posedge1 = AggTris[ID].posedge1;
        tri.posedge2 = AggTris[ID].posedge2;
        return tri;
    }

    inline void IntersectTriangle(int mesh_id, int tri_id, const Ray ray, inout RayHit ray_hit) {

        TrianglePos tri = triangle_get_positions(tri_id);

        float3 h = cross(ray.direction, tri.posedge2);
        float  a = dot(tri.posedge1, h);

        float  f = rcp(a);
        float3 s = ray.origin - tri.pos0;
        float  u = f * dot(s, h);

        if (u >= 0.0f && u <= 1.0f) {//This may be fucking things up later, its supposed to be u >= 0.0f && u <= 1.0f, changed it to u == saturate(u)
            float3 q = cross(s, tri.posedge1);
            float  v = f * dot(ray.direction, q);

            if (v >= 0.0f && u + v <= 1.0f) {
                float t = f * dot(tri.posedge2, q);

                if (t > 0.0f && t < ray_hit.t) {
                    ray_hit.t = t;
                    ray_hit.u = u;
                    ray_hit.v = v;
                    ray_hit.mesh_id     = mesh_id;
                    ray_hit.triangle_id = tri_id;
                }
            }
        }
    }

    int Reps;
    inline uint cwbvh_node_intersect(const Ray ray, int oct_inv4, float max_distance, const float3 node_0, uint node_0w, const uint4 node_1, const uint4 node_2, const uint4 node_3, const uint4 node_4) {
        uint e_x = (node_0w) & 0xff;
        uint e_y = (node_0w >> (8)) & 0xff;
        uint e_z = (node_0w >> (16)) & 0xff;

        const float3 adjusted_ray_direction_inv = float3(
            asfloat(e_x << 23) * ray.direction_inv.x,
            asfloat(e_y << 23) * ray.direction_inv.y,
            asfloat(e_z << 23) * ray.direction_inv.z
            );
        const float3 adjusted_ray_origin = ray.direction_inv * (node_0 - ray.origin);

        uint hit_mask = 0;
        float3 tmin3;
        float3 tmax3;
        uint child_bits;
        uint bit_index;
        [unroll]
        for(int i = 0; i < 2; i++) {
            uint meta4 = asuint(i == 0 ? node_1.z : node_1.w);

            uint is_inner4   = (meta4 & (meta4 << 1)) & 0x10101010;
            uint inner_mask4 = (((is_inner4 << 3) >> 7) & 0x01010101) * 0xff;
            uint bit_index4  = (meta4 ^ (oct_inv4 & inner_mask4)) & 0x1f1f1f1f;
            uint child_bits4 = (meta4 >> 5) & 0x07070707;

            uint q_lo_x = (i == 0 ? node_2.x : node_2.y);
            uint q_hi_x = (i == 0 ? node_2.z : node_2.w);

            uint q_lo_y = (i == 0 ? node_3.x : node_3.y);
            uint q_hi_y = (i == 0 ? node_3.z : node_3.w);

            uint q_lo_z = (i == 0 ? node_4.x : node_4.y);
            uint q_hi_z = (i == 0 ? node_4.z : node_4.w);

            uint x_min = ray.direction.x < 0.0f ? q_hi_x : q_lo_x;
            uint x_max = ray.direction.x < 0.0f ? q_lo_x : q_hi_x;

            uint y_min = ray.direction.y < 0.0f ? q_hi_y : q_lo_y;
            uint y_max = ray.direction.y < 0.0f ? q_lo_y : q_hi_y;

            uint z_min = ray.direction.z < 0.0f ? q_hi_z : q_lo_z;
            uint z_max = ray.direction.z < 0.0f ? q_lo_z : q_hi_z;
            [unroll]
            for(int j = 0; j < 4; j++) {

                tmin3 = float3((float)((x_min >> (j * 8)) & 0xff), (float)((y_min >> (j * 8)) & 0xff), (float)((z_min >> (j * 8)) & 0xff));
                tmax3 = float3((float)((x_max >> (j * 8)) & 0xff), (float)((y_max >> (j * 8)) & 0xff), (float)((z_max >> (j * 8)) & 0xff));

                tmin3 = tmin3 * adjusted_ray_direction_inv + adjusted_ray_origin;
                tmax3 = tmax3 * adjusted_ray_direction_inv + adjusted_ray_origin;

                float tmin = max(max(tmin3.x, tmin3.y), max(tmin3.z, EPSILON));
                float tmax = min(min(tmax3.x, tmax3.y), min(tmax3.z, max_distance));
                
                bool intersected = tmin < tmax;
                [branch]
                if (intersected) {
                    child_bits = (child_bits4 >> (j * 8)) & 0xff;
                    bit_index  = (bit_index4 >> (j * 8)) & 0xff;

                    hit_mask |= child_bits << bit_index;
                }
            }
        }
        return hit_mask;
    }

    inline uint ray_get_octant_inv4(const float3 ray_direction) {
        return
        (ray_direction.x < 0.0f ? 0 : 0x04040404) |
        (ray_direction.y < 0.0f ? 0 : 0x02020202) |
        (ray_direction.z < 0.0f ? 0 : 0x01010101);
    }

    RWTexture2D<float4> _DebugTex;
    void IntersectBVH(const int localid) {
        RayHit bestHit;
        Ray ray;

        uint2 stack[24];

        int stack_size = 0;
        uint ray_index;
        uint2 current_group;

        uint oct_inv4;
        int tlas_stack_size;
        int mesh_id = -1;
        int NodeOffset = 0;
        int TriOffset = 0;
        Ray ray2;

        while(true) {
            //Revive dead threads(persistent threads, need Shader Model 6 to take true advantage of)
            InterlockedAdd(BufferSizes[CurBounce].rays_retired, 1, ray_index);
            if(ray_index >= (uint)BufferSizes[CurBounce].tracerays) {
                // InterlockedAdd(BufferSizes[CurBounce].rays_retired, -1, ray_index);
                return;
            }
            ray.origin = GlobalRays1[ray_index].origin;
            ray.direction = GlobalRays1[ray_index].direction;
            ray.direction_inv = rcp(ray.direction);
            ray2 = ray;

            oct_inv4 = ray_get_octant_inv4(ray.direction);

            current_group.x = (uint)0;
            current_group.y = (uint)0x80000000;
            bestHit = CreateRayHit();

            tlas_stack_size = -1;
            Reps = 0;

        while(true) {//Traverse Accelleration Structure(Compressed Wide Bounding Volume Hierarchy)            
            uint2 triangle_group;
            if(current_group.y & 0xff000000) {
                uint hits_imask = current_group.y;
                uint child_index_offset = firstbithigh(hits_imask);
                uint child_index_base = current_group.x;

                current_group.y &= ~(1 << child_index_offset);

                if(current_group.y & 0xff000000) {
                    stack[stack_size++] = current_group;
                }
                uint slot_index = (child_index_offset - 24) ^ (oct_inv4 & 0xff);
                uint relative_index = countbits(hits_imask & ~(0xffffffff << slot_index));
                uint child_node_index = child_index_base + relative_index;
                const BVHNode8Data TempNode = cwbvh_nodes[child_node_index];
                float3 node_0 = TempNode.node_0xyz;
                uint node_0w = TempNode.node_0w;
                
                uint4 node_1 = TempNode.node_1;
                uint4 node_2 = TempNode.node_2;
                uint4 node_3 = TempNode.node_3;
                uint4 node_4 = TempNode.node_4;

                uint hitmask = cwbvh_node_intersect(ray, oct_inv4, bestHit.t, node_0, node_0w, node_1, node_2, node_3, node_4);
                uint imask = (node_0w >> (24)) & 0xff;

                current_group.x = asuint(node_1.x) + ((tlas_stack_size == -1) ? 0 : NodeOffset);
                triangle_group.x = asuint(node_1.y) + ((tlas_stack_size == -1) ? 0 : TriOffset);
                Reps++;
                current_group .y = (hitmask & 0xff000000) | (imask);
                triangle_group.y = (hitmask & 0x00ffffff);

            }
            else {
                triangle_group.x = current_group.x;
                triangle_group.y = current_group.y;
                current_group.x = (uint)0;
                current_group.y = (uint)0;
            }

            while(triangle_group.y != 0) { 

                if(tlas_stack_size == -1) {//Transfer from Top Level Accelleration Structure to Bottom Level Accelleration Structure
                    uint mesh_offset = firstbithigh(triangle_group.y);
                    triangle_group.y &= ~(1 << mesh_offset);
                    mesh_id = triangle_group.x + mesh_offset;
                    NodeOffset = _MeshData[mesh_id].NodeOffset;
                    TriOffset = _MeshData[mesh_id].TriOffset;
                    if(triangle_group.y != 0) {
                        stack[stack_size++] = triangle_group;
                    }

                    if(current_group.y & 0xff000000) {
                        stack[stack_size++] = current_group;
                    }
                    tlas_stack_size = stack_size;

                    int root_index = (_MeshData[mesh_id].mesh_data_bvh_offsets & 0x7fffffff);

                    ray.direction = (mul(_MeshData[mesh_id].Transform, float4(ray.direction, 0))).xyz;
                    ray.origin = (mul(_MeshData[mesh_id].Transform, float4(ray.origin, 1))).xyz;
                    ray.direction_inv = rcp(ray.direction);

                    oct_inv4 = ray_get_octant_inv4(ray.direction);

                    current_group.x = (uint)root_index;
                    current_group.y = (uint)0x80000000;
//                    Reps++;

break;
}
else {
    uint triangle_index =  firstbithigh(triangle_group.y);
    triangle_group.y &= ~(1 << triangle_index);
                    IntersectTriangle(mesh_id, triangle_group.x + triangle_index, ray, bestHit);//Intersect Mesh Triangles
                }
            }
            if((current_group.y & 0xff000000) == 0) {
                if(stack_size == 0) {//thread has finished traversing
                    GlobalRays2[ray_index] = GlobalRays1[ray_index];
                    set2(ray_index, bestHit);
                    // int PixIndex = GlobalRays2[ray_index].PixelIndex;
                    // uint2 TempUv = uint2(PixIndex % screen_width, PixIndex / screen_width);
                    // _DebugTex[TempUv] = float4((Reps) / 120.0f,0,0,1);
                    current_group.y = 0;
                    break;
                }

                if(stack_size == tlas_stack_size) {
                    tlas_stack_size = -1;
                    ray = ray2;
                    oct_inv4 = ray_get_octant_inv4(ray.direction);
                }
                current_group = stack[--stack_size];
            }
        }
    }
}


[numthreads(64,1,1)]
void kernel_trace (uint id : SV_GroupIndex) {//If I move the function contents into here, unity yells at me, so for now its just gonna continue to live in its function
    IntersectBVH(id * 6);
}

#pragma kernel kernel_brickmap_trace
StructuredBuffer<int> BrickMap;


inline bool rayBoxIntersection(const float3 ray_orig, const float3 inv_dir, const float3 Min, const float3 Max, float tMax, inout float t0, inout float t1) {
    const float3 tmp_min = (Min - ray_orig) * inv_dir;
    const float3 tmp_max = (Max - ray_orig) * inv_dir;
    const float3 tmin = min(tmp_min, tmp_max);
    const float3 tmax = max(tmp_min, tmp_max);
    t0 = max(tmin.x, max(tmin.y, max(tmin.z, 0))); // Usually ray_tmin = 0
    t1 = min(tmax.x, min(tmax.y, min(tmax.z, tMax)));
    return (t0 <= t1);
}



inline bool TraceBrickmap(float3 ray_orig, const float3 ray_direction, const float3 inv, inout RayHit bestHit, const int MeshIndex, const int GridSize, const int VoxelSize, const int BrickSize, const uint Offset, const float3 Scale) {
    float Dist = 1.0f;
    float Dist2 = 1.0f;
    if(rayBoxIntersection(ray_orig, inv, 0, GridSize + 0.0001f,bestHit.t, Dist, Dist2)) {
        ray_orig += ray_direction * Dist;

        const int InitialSize = GridSize / (float)BrickSize;
        int A = InitialSize;
        const int3 raystep = sign(ray_direction);
        int3 MapPos = floor((ray_orig + raystep * 0.001f) / A);
        const float3 deltaDist = abs(inv);


        float3 SideDist = (raystep * (MapPos - (ray_orig) / A) + (raystep * 0.5f) + 0.5f) * deltaDist;

        bool3 mask;

        const int MaxSteps = 10000;
        int CurrentPositionIndex = 0;
        float3 LastSideDist = 0;
        float3 BBMax = GridSize;
        float3 BBMin = 0;
        int Layer = 0;
        uint CurrentOffsetArray[10];
        uint CurrentOffset = Offset;
        CurrentOffsetArray[0] = Offset;
        int CurrentSize = BrickSize;
        const float3 OrigionalPosition = ray_orig * Scale;
        for(int i = 0; i < MaxSteps; i++) {
            const float3 LocalPos = fmod(MapPos, CurrentSize);
            [branch]if((any(MapPos * A >= BBMax) || any(MapPos * A < BBMin)) && A < InitialSize) {
                float3 updatedPos = ray_orig + ray_direction * ((min(min(LastSideDist.x, LastSideDist.y), LastSideDist.z)) * A);
                CurrentOffset = CurrentOffsetArray[--Layer];
                A *= CurrentSize;
                if(A == VoxelSize) CurrentSize = BrickSize;
                BBMax = MapPos * A + A;
                BBMin = MapPos * A;
                ray_orig = updatedPos;
                LastSideDist = 0;
                MapPos = floor((updatedPos + raystep * 0.001f) / A);
                SideDist = (raystep * (MapPos - updatedPos / A) + (raystep * 0.5f) + 0.5f) * deltaDist;
                } else {
                    [branch]if(A == 1 && BrickMap[(uint)CurrentOffset + (uint)LocalPos.x + (uint)LocalPos.y * (uint)CurrentSize + (uint)LocalPos.z * (uint)CurrentSize * (uint)CurrentSize] != -1) {
                        if(length(OrigionalPosition - (ray_orig + ray_direction * ((min(min(LastSideDist.x, LastSideDist.y), LastSideDist.z)) * A))*Scale) + Dist < bestHit.t) {
                            bestHit.t = length(OrigionalPosition - (ray_orig + ray_direction * ((min(min(LastSideDist.x, LastSideDist.y), LastSideDist.z)) * A))*Scale) + Dist;
                            bestHit.triangle_id = BrickMap[(uint)CurrentOffset + (uint)LocalPos.x + (uint)LocalPos.y * (uint)CurrentSize + (uint)LocalPos.z * (uint)CurrentSize * (uint)CurrentSize];
                            bestHit.mesh_id = MeshIndex;
                            return true;
                        }
                        break;
                    }
                    [branch]if(BrickMap[CurrentOffset + LocalPos.x + LocalPos.y * CurrentSize + LocalPos.z * CurrentSize * CurrentSize] != -1 && A > 1) {
                        float3 updatedPos = ray_orig + ray_direction * ((min(min(LastSideDist.x, LastSideDist.y), LastSideDist.z)) * A);
                        CurrentOffsetArray[Layer++] = CurrentOffset;
                        CurrentOffset = BrickMap[CurrentOffset + LocalPos.x + LocalPos.y * CurrentSize + LocalPos.z * CurrentSize * CurrentSize] + Offset;
                        BBMax = MapPos * A + A;
                        BBMin = MapPos * A;
                        if(A == VoxelSize) CurrentSize = VoxelSize;
                        A /= (uint)CurrentSize;     
                        ray_orig = updatedPos;
                        LastSideDist = 0;
                        MapPos = floor((updatedPos + raystep * 0.001f) / A);
                        SideDist = (raystep * (MapPos - updatedPos / A) + (raystep * 0.5f) + 0.5f) * deltaDist;
                        } else {
                            mask = (SideDist.xyz <= min(SideDist.yzx, SideDist.zxy));
                            LastSideDist = SideDist;
                            SideDist += mask * deltaDist;
                            MapPos += mask * raystep;                  
                        }
                    }


                    if(any(MapPos * A >= GridSize) || any(MapPos * A < 0)) break;
                } 
            }
            return false;
        }



        float3 GetScale(float4x4 m)
        {
            return float3(
                length(float3(m._m00, m._m10, m._m20)),
                length(float3(m._m01, m._m11, m._m21)),
                length(float3(m._m02, m._m12, m._m22))
                );
        }


        void IntersectVoxelTLAS() {
            RayHit bestHit;
            Ray ray;

            uint2 stack[8];
            int stack_size = 0;
            uint ray_index;
            uint2 current_group;

            uint oct_inv4;
            int tlas_stack_size;
            int mesh_id =  VoxelOffset;
            int NodeOffset = 0;
            int TriOffset = 0;
            Ray ray2;
            uint2 TempUv;
            while(true) {
                bool inactive = stack_size == 0 && current_group.y == 0;

        if (inactive) {//Revive dead threads(persistent threads, need Shader Model 6 to take true advantage of)
            InterlockedAdd(BufferSizes[CurBounce].brickmap_rays_retired, 1, ray_index);
            if(ray_index >= (uint)BufferSizes[CurBounce].tracerays) return;
            ray.origin = GlobalRays2[ray_index].origin;
            ray.direction = GlobalRays2[ray_index].direction;
            ray.direction_inv = rcp(ray.direction);
            bestHit = get2(ray_index);
            ray2 = ray;

            oct_inv4 = ray_get_octant_inv4(ray.direction);

            current_group.x = (uint)0;
            current_group.y = (uint)0x80000000;
            bestHit = get2(ray_index);

            tlas_stack_size = -1;
        }

        while(true) {//Traverse Accelleration Structure(Compressed Wide Bounding Volume Hierarchy)           
            uint2 triangle_group;
            if(current_group.y & 0xff000000) {
                uint hits_imask = current_group.y;
                uint child_index_offset = firstbithigh(hits_imask);
                uint child_index_base = current_group.x;

                current_group.y &= ~(1 << child_index_offset);

                if(current_group.y & 0xff000000) {
                    stack[stack_size++] = current_group;
                }
                uint slot_index = (child_index_offset - 24) ^ (oct_inv4 & 0xff);
                uint relative_index = countbits(hits_imask & ~(0xffffffff << slot_index));
                uint child_node_index = child_index_base + relative_index;

                float3 node_0 = VoxelTLAS[child_node_index].node_0xyz;
                uint node_0w = VoxelTLAS[child_node_index].node_0w;
                
                uint4 node_1 = VoxelTLAS[child_node_index].node_1;
                uint4 node_2 = VoxelTLAS[child_node_index].node_2;
                uint4 node_3 = VoxelTLAS[child_node_index].node_3;
                uint4 node_4 = VoxelTLAS[child_node_index].node_4;

                uint hitmask = cwbvh_node_intersect(ray, oct_inv4, bestHit.t, node_0, node_0w, node_1, node_2, node_3, node_4);
                uint imask = (node_0w >> (3 * 8)) & 0xff;

                current_group.x = asuint(node_1.x) + ((tlas_stack_size == -1) ? 0 : NodeOffset);
                triangle_group.x = asuint(node_1.y) + ((tlas_stack_size == -1) ? 0 : TriOffset);

                current_group .y = (hitmask & 0xff000000) | (imask);
                triangle_group.y = (hitmask & 0x00ffffff);
            }
            else {
                triangle_group.x = current_group.x;
                triangle_group.y = current_group.y;
                current_group.x = (uint)0;
                current_group.y = (uint)0;
            }

            while(triangle_group.y != 0) { 
                if(tlas_stack_size == -1) {//Transfer from Top Level Accelleration Structure to Bottom Level Accelleration Structure
                    Reps += 1;
                    uint mesh_offset = firstbithigh(triangle_group.y);
                    triangle_group.y &= ~(1 << mesh_offset);

                    mesh_id = triangle_group.x + mesh_offset + VoxelOffset;
                    NodeOffset = _MeshData[mesh_id].NodeOffset;
                    TriOffset = _MeshData[mesh_id].TriOffset;
                    if(triangle_group.y != 0) {
                        stack[stack_size++] = triangle_group;
                    }

                    if(current_group.y & 0xff000000) {
                        stack[stack_size++] = current_group;
                    }
                    tlas_stack_size = stack_size;

                    int root_index = (_MeshData[mesh_id].mesh_data_bvh_offsets & 0x7fffffff);

                    ray.direction = (mul(_MeshData[mesh_id].Transform, float4(ray.direction, 0))).xyz;
                    ray.origin = (mul(_MeshData[mesh_id].Transform, float4(ray.origin, 1))).xyz;
                    ray.direction_inv = rcp(ray.direction);

                    oct_inv4 = ray_get_octant_inv4(ray.direction);

                    current_group.y = (uint)0x80000000;
                    if(TraceBrickmap(ray.origin, ray.direction, ray.direction_inv, bestHit, mesh_id, _MeshData[mesh_id].Size.x, _MeshData[mesh_id].Size.y, _MeshData[mesh_id].Size.z, _MeshData[mesh_id].NodeOffset, GetScale(_MeshData[mesh_id].Inverse))) {GlobalRays2[ray_index].HitVoxel = 1; set2(ray_index, bestHit);}
                    break;
                }
                else {
                    uint triangle_index =  firstbithigh(triangle_group.y);
                    triangle_group.y &= ~(1 << triangle_index);
                }
            }
            if((current_group.y & 0xff000000) == 0) {
                if(stack_size == 0) {//thread has finished traversing
                    set2(ray_index, bestHit);
                    break;
                }

                if(stack_size == tlas_stack_size) {

                    tlas_stack_size = -1;
                    ray = ray2;
                    oct_inv4 = ray_get_octant_inv4(ray.direction);
                }
                current_group = stack[--stack_size];
            }
        }
    }
}


[numthreads(64,1,1)]
void kernel_brickmap_trace () {//If I move the function contents into here, unity yells at me, so for now its just gonna continue to live in its function

    IntersectVoxelTLAS();
}



struct Reservoir {
    float y;
    float wsum;
    float M;
    float W;
    float3 Radiance;
    float3 Position;
    float3 Norm;
    float MeshIndex;
    float3 PrevWorld;
    float3 PrevNorm;
    float3 FirstBounceHitPosition;
};

RWStructuredBuffer<Reservoir> CurrentReservoir;
RWStructuredBuffer<Reservoir> PreviousReservoir;

#pragma kernel kernel_shadow

TrianglePos triangle_get_positions2(int ID) {
    TrianglePos tri;
    tri.pos0 = LightTriangles[ID].pos0;
    tri.posedge1 = LightTriangles[ID].posedge1;
    tri.posedge2 = LightTriangles[ID].posedge2;
    return tri;
}

inline bool triangle_intersect_shadow(int tri_id, const Ray ray, float max_distance) {
    TrianglePos tri = triangle_get_positions(tri_id);

    float3 h = cross(ray.direction, tri.posedge2);
    float  a = dot(tri.posedge1, h);

    float  f = rcp(a);
    float3 s = ray.origin - tri.pos0;
    float  u = f * dot(s, h);

    if (u >= 0.0f && u <= 1.0f) {
        float3 q = cross(s, tri.posedge1);
        float  v = f * dot(ray.direction, q);

        if (v >= 0.0f && u + v <= 1.0f) {
            float t = f * dot(tri.posedge2, q);

            if (t > 0.0f && t < max_distance) return true;
        }
    }

    return false;
}



void IntersectBVHShadow(const int localid) {
    Ray ray;

    uint2 stack[24];
    int stack_size = 0;
    uint ray_index;
    uint2 current_group;

    uint oct_inv4;
    int tlas_stack_size;
    int mesh_id;
    float max_distance;
    Ray ray2;

    while(true) {
            //Revive dead threads(persistent threads, need Shader Model 6 to take true advantage of)
            InterlockedAdd(BufferSizes[CurBounce].shadow_rays_retired, 1, ray_index);
            if(ray_index >= (uint)BufferSizes[CurBounce].shadow_rays) return;
            ray.origin = ShadowRaysBuffer[ray_index].origin;
            ray.direction = ShadowRaysBuffer[ray_index].direction;
            ray.direction_inv = rcp(ray.direction);
            ray2 = ray;

            oct_inv4 = ray_get_octant_inv4(ray.direction);

            current_group.x = (uint)0;
            current_group.y = (uint)0x80000000;

            max_distance = ShadowRaysBuffer[ray_index].t;

            tlas_stack_size = -1;
            bool hit = false;

        while(true) {//Traverse Accelleration Structure(Compressed Wide Bounding Volume Hierarchy)            
            uint2 triangle_group;
            if(current_group.y & 0xff000000) {
                uint hits_imask = current_group.y;
                uint child_index_offset = firstbithigh(hits_imask);
                uint child_index_base = current_group.x;

                current_group.y &= ~(1 << child_index_offset);

                if(current_group.y & 0xff000000) {
                    stack[stack_size++] = current_group;
                }
                uint slot_index = (child_index_offset - 24) ^ (oct_inv4 & 0xff);
                uint relative_index = countbits(hits_imask & ~(0xffffffff << slot_index));
                uint child_node_index = child_index_base + relative_index;

                float3 node_0 = cwbvh_nodes[child_node_index].node_0xyz;
                uint node_0w = cwbvh_nodes[child_node_index].node_0w;
                
                uint4 node_1 = cwbvh_nodes[child_node_index].node_1;
                uint4 node_2 = cwbvh_nodes[child_node_index].node_2;
                uint4 node_3 = cwbvh_nodes[child_node_index].node_3;
                uint4 node_4 = cwbvh_nodes[child_node_index].node_4;

                uint hitmask = cwbvh_node_intersect(ray, oct_inv4, max_distance, node_0, node_0w, node_1, node_2, node_3, node_4);

                uint imask = (node_0w >> (3 * 8)) & 0xff;

                current_group.x = asuint(node_1.x) + ((tlas_stack_size == -1) ? 0 : _MeshData[mesh_id].NodeOffset);
                triangle_group.x = asuint(node_1.y) + ((tlas_stack_size == -1) ? 0 : _MeshData[mesh_id].TriOffset);

                current_group .y = (hitmask & 0xff000000) | (uint)(imask);
                triangle_group.y = (hitmask & 0x00ffffff);
            }
            else {
                triangle_group.x = current_group.x;
                triangle_group.y = current_group.y;
                current_group.x = (uint)0;
                current_group.y = (uint)0;
            }


            while(triangle_group.y != 0) { 
                if(tlas_stack_size == -1) {//Transfer from Top Level Accelleration Structure to Bottom Level Accelleration Structure
                    uint mesh_offset = firstbithigh(triangle_group.y);
                    triangle_group.y &= ~(1 << mesh_offset);

                    mesh_id = triangle_group.x + mesh_offset;

                    if(triangle_group.y != 0) {
                        stack[stack_size++] = triangle_group;
                    }

                    if(current_group.y & 0xff000000) {
                        stack[stack_size++] = current_group;
                    }
                    tlas_stack_size = stack_size;

                    int root_index = (_MeshData[mesh_id].mesh_data_bvh_offsets & 0x7fffffff);

                    ray.direction = (mul(_MeshData[mesh_id].Transform, float4(ray.direction, 0))).xyz;
                    ray.origin = (mul(_MeshData[mesh_id].Transform, float4(ray.origin, 1))).xyz;
                    ray.direction_inv = rcp(ray.direction);

                    oct_inv4 = ray_get_octant_inv4(ray.direction);

                    current_group.x = (uint)root_index;
                    current_group.y = (uint)0x80000000;

                    break;
                }
                else {
                    uint triangle_index =  firstbithigh(triangle_group.y);
                    triangle_group.y &= ~(1 << triangle_index);

                    if(triangle_intersect_shadow(triangle_group.x + triangle_index, ray, max_distance)) {
                        hit = true;
                        ShadowRaysBuffer[ray_index].t = -1;
                        break;
                    }
                }
            }

            if(hit) {
                stack_size = 0;
                current_group.y = 0;
                break;
            }

            if((current_group.y & 0xff000000) == 0) {
                if(stack_size == 0) {//thread has finished traversing
                    current_group.y = 0;
                    break;
                }

                if(stack_size == tlas_stack_size) {
                    tlas_stack_size = -1;
                    ray = ray2;
                    oct_inv4 = ray_get_octant_inv4(ray.direction);
                }
                current_group = stack[--stack_size];
            }
        }
    }
}


[numthreads(64,1,1)]
void kernel_shadow (uint id : SV_GroupIndex) {//If I move the function contents into here, unity yells at me, so for now its just gonna continue to live in its function
    IntersectBVHShadow(id * 6);
}



#pragma kernel kernel_shadow_brickmap

inline bool TraceShadowBrickmap(float3 ray_orig, const float3 ray_direction, const float3 inv, const int MeshIndex, const float Distance, const int GridSize, const int VoxelSize, const int BrickSize, const uint Offset, const float3 Scale) {
    float Dist = 1.0f;
    float Dist2 = 1.0f;
    if(rayBoxIntersection(ray_orig, inv, 0, GridSize + 0.0001f, Distance, Dist, Dist2)) {
        ray_orig += ray_direction * Dist;

        const int InitialSize = (uint)GridSize / (uint)BrickSize;
        int A = InitialSize;
        const int3 raystep = sign(ray_direction);
        int3 MapPos = floor((ray_orig + raystep * 0.001f) / A);
        const float3 deltaDist = abs(inv);


        float3 SideDist = (raystep * (MapPos - (ray_orig) / A) + (raystep * 0.5f) + 0.5f) * deltaDist;

        bool3 mask;

        const int MaxSteps = 10000;
        int CurrentPositionIndex = 0;
        float3 LastSideDist = 0;
        float3 BBMax = GridSize;
        float3 BBMin = 0;
        int Layer = 0;
        int CurrentOffsetArray[10];
        int CurrentOffset = Offset;
        int CurrentSize = BrickSize;
        const float3 OrigionalPosition = ray_orig * Scale;
        for(int i = 0; i < MaxSteps; i++) {
            const float3 LocalPos = fmod(MapPos, CurrentSize);
            [branch]if((any(MapPos * A >= BBMax) || any(MapPos * A < BBMin)) && A < InitialSize) {
                float3 updatedPos = ray_orig + ray_direction * ((min(min(LastSideDist.x, LastSideDist.y), LastSideDist.z)) * A);
                CurrentOffset = CurrentOffsetArray[--Layer];
                A *= CurrentSize;
                if(A == VoxelSize) CurrentSize = BrickSize;
                BBMax = MapPos * A + A;
                BBMin = MapPos * A;
                ray_orig = updatedPos;
                LastSideDist = 0;
                MapPos = floor((updatedPos + raystep * 0.001f) / A);
                SideDist = (raystep * (MapPos - updatedPos / A) + (raystep * 0.5f) + 0.5f) * deltaDist;
            } else {
                [branch]if(A == 1 && BrickMap[(uint)CurrentOffset + (uint)LocalPos.x + (uint)LocalPos.y * (uint)CurrentSize + (uint)LocalPos.z * (uint)CurrentSize * (uint)CurrentSize] != -1) {
                    if(length(OrigionalPosition - (ray_orig + ray_direction * ((min(min(LastSideDist.x, LastSideDist.y), LastSideDist.z)) * A)) * Scale) + Dist < Distance) {
                        return true;
                    }
                    break;
                }
                [branch]if(BrickMap[CurrentOffset + LocalPos.x + LocalPos.y * CurrentSize + LocalPos.z * CurrentSize * CurrentSize] != -1 && A > 1) {
                    float3 updatedPos = ray_orig + ray_direction * ((min(min(LastSideDist.x, LastSideDist.y), LastSideDist.z)) * A);
                    CurrentOffsetArray[Layer++] = CurrentOffset;
                    CurrentOffset = BrickMap[CurrentOffset + LocalPos.x + LocalPos.y * CurrentSize + LocalPos.z * CurrentSize * CurrentSize] + Offset;
                    BBMax = MapPos * A + A;
                    BBMin = MapPos * A;
                    if(A == VoxelSize) CurrentSize = VoxelSize;
                    A /= (uint)CurrentSize;     
                    ray_orig = updatedPos;
                    LastSideDist = 0;
                    MapPos = floor((updatedPos + raystep * 0.001f) / A);
                    SideDist = (raystep * (MapPos - updatedPos / A) + (raystep * 0.5f) + 0.5f) * deltaDist;
                } else {
                    mask = (SideDist.xyz <= min(SideDist.yzx, SideDist.zxy));
                    LastSideDist = SideDist;
                    SideDist += mask * deltaDist;
                    MapPos += mask * raystep;                  
                }
            }


            if(any(MapPos * A >= GridSize) || any(MapPos * A < 0)) break;
        } 
    }
    return false;



}       


void IntersectVoxelTLASShadow() {
    Ray ray;

    uint2 stack[8];
    int stack_size = 0;
    uint ray_index;
    uint2 current_group;

    uint oct_inv4;
    int tlas_stack_size;
    int mesh_id =  VoxelOffset;
    int NodeOffset = 0;
    int TriOffset = 0;
    float max_distance;
    Ray ray2;
    bool DidHit = false;
    while(true) {
        bool inactive = stack_size == 0 && current_group.y == 0;

if (inactive) {//Revive dead threads(persistent threads, need Shader Model 6 to take true advantage of)
    InterlockedAdd(BufferSizes[CurBounce].brickmap_shadow_rays_retired, 1, ray_index);
    if(ray_index >= (uint)BufferSizes[CurBounce].shadow_rays) return;
    if(ShadowRaysBuffer[ray_index].t == -1) continue;
    max_distance = ShadowRaysBuffer[ray_index].t;
    ray.origin = ShadowRaysBuffer[ray_index].origin;
    ray.direction = ShadowRaysBuffer[ray_index].direction;
    ray.direction_inv = rcp(ray.direction);
    ray2 = ray;
    DidHit = false;

    oct_inv4 = ray_get_octant_inv4(ray.direction);

    current_group.x = (uint)0;
    current_group.y = (uint)0x80000000;

    tlas_stack_size = -1;
}

while(true) {//Traverse Accelleration Structure(Compressed Wide Bounding Volume Hierarchy)          
    uint2 triangle_group;
    if(current_group.y & 0xff000000) {
        uint hits_imask = current_group.y;
        uint child_index_offset = firstbithigh(hits_imask);
        uint child_index_base = current_group.x;

        current_group.y &= ~(1 << child_index_offset);

        if(current_group.y & 0xff000000) {
            stack[stack_size++] = current_group;
        }
        uint slot_index = (child_index_offset - 24) ^ (oct_inv4 & 0xff);
        uint relative_index = countbits(hits_imask & ~(0xffffffff << slot_index));
        uint child_node_index = child_index_base + relative_index;

        float3 node_0 = VoxelTLAS[child_node_index].node_0xyz;
        uint node_0w = VoxelTLAS[child_node_index].node_0w;
        
        uint4 node_1 = VoxelTLAS[child_node_index].node_1;
        uint4 node_2 = VoxelTLAS[child_node_index].node_2;
        uint4 node_3 = VoxelTLAS[child_node_index].node_3;
        uint4 node_4 = VoxelTLAS[child_node_index].node_4;

        uint hitmask = cwbvh_node_intersect(ray, oct_inv4, max_distance, node_0, node_0w, node_1, node_2, node_3, node_4);
        uint imask = (node_0w >> (3 * 8)) & 0xff;

        current_group.x = asuint(node_1.x) + ((tlas_stack_size == -1) ? 0 : NodeOffset);
        triangle_group.x = asuint(node_1.y) + ((tlas_stack_size == -1) ? 0 : TriOffset);

        current_group .y = (hitmask & 0xff000000) | (imask);
        triangle_group.y = (hitmask & 0x00ffffff);
    }
    else {
        triangle_group.x = current_group.x;
        triangle_group.y = current_group.y;
        current_group.x = (uint)0;
        current_group.y = (uint)0;
    }

    while(triangle_group.y != 0) { 
        if(tlas_stack_size == -1) {//Transfer from Top Level Accelleration Structure to Bottom Level Accelleration Structure
            uint mesh_offset = firstbithigh(triangle_group.y);
            triangle_group.y &= ~(1 << mesh_offset);

            mesh_id = triangle_group.x + mesh_offset + VoxelOffset;
            NodeOffset = _MeshData[mesh_id].NodeOffset;
            TriOffset = _MeshData[mesh_id].TriOffset;
            if(triangle_group.y != 0) {
                stack[stack_size++] = triangle_group;
            }

            if(current_group.y & 0xff000000) {
                stack[stack_size++] = current_group;
            }
            tlas_stack_size = stack_size;

            int root_index = (_MeshData[mesh_id].mesh_data_bvh_offsets & 0x7fffffff);

            ray.direction = (mul(_MeshData[mesh_id].Transform, float4(ray.direction, 0))).xyz;
            ray.origin = (mul(_MeshData[mesh_id].Transform, float4(ray.origin, 1))).xyz;
            ray.direction_inv = rcp(ray.direction);

            oct_inv4 = ray_get_octant_inv4(ray.direction);

            current_group.y = (uint)0x80000000;
            DidHit = TraceShadowBrickmap(ray.origin, ray.direction, ray.direction_inv, mesh_id, max_distance, _MeshData[mesh_id].Size.x, _MeshData[mesh_id].Size.y, _MeshData[mesh_id].Size.z, _MeshData[mesh_id].NodeOffset, GetScale(_MeshData[mesh_id].Inverse));
            break;
        }
        else {
            uint triangle_index =  firstbithigh(triangle_group.y);
            triangle_group.y &= ~(1 << triangle_index);
        }
    }
    if((current_group.y & 0xff000000) == 0 || DidHit) {
        if(DidHit) {
            stack_size = 0;
            if(CurBounce == 0 && ShadowRaysBuffer[ray_index].PrimaryNEERay) CurrentReservoir[ShadowRaysBuffer[ray_index].PixelIndex].W = 0;
            break;
        }
        if(stack_size == 0) {//thread has finished traversing
            int pixel_index = ShadowRaysBuffer[ray_index].PixelIndex;
            if(ShadowRaysBuffer[ray_index].PrimaryNEERay) {
                if(CurBounce == 0) {
                    GlobalColors[pixel_index].Direct += ShadowRaysBuffer[ray_index].illumination;
                    } else {
                        SHData ThisSH = SH[pixel_index];
                        accumulate_SH(ThisSH, irradiance_to_SH(ShadowRaysBuffer[ray_index].illumination * 1024, Rays[pixel_index].direction), 1.0f);
                        SH[pixel_index] = ThisSH;
                        GlobalColors[pixel_index].Indirect +=ShadowRaysBuffer[ray_index].illumination;
                    }
                    } else {
                        GlobalColors[pixel_index].PrimaryNEERay += ShadowRaysBuffer[ray_index].illumination;
                        CurrentReservoirGI[pixel_index].NEERay = ShadowRaysBuffer[ray_index].RadianceIncomming;
                    }
                    break;
                }

                if(stack_size == tlas_stack_size) {

                    tlas_stack_size = -1;
                    ray = ray2;
                    oct_inv4 = ray_get_octant_inv4(ray.direction);
                }
                current_group = stack[--stack_size];
            }
        }
    }
}

Texture2D<half> Heightmap;
SamplerState sampler_trilinear_clamp;

struct TerrainData {
    float3 PositionOffset;
    float HeightScale;
    float TerrainDim;
    float4 AlphaMap;
    float4 HeightMap;
    int MatOffset;
};

StructuredBuffer<TerrainData> Terrains;

int TerrainCount;

static float g = sin(atan(1.0f / 2.0f));

inline bool rayBoxIntersection(const float3 ray_orig, const float3 inv_dir, const float3 Min, const float3 Max, float tMax, inout float t0) {
    const float3 tmp_min = (Min - ray_orig) * inv_dir;
    const float3 tmp_max = (Max - ray_orig) * inv_dir;
    const float3 tmin = min(tmp_min, tmp_max);
    const float3 tmax = max(tmp_min, tmp_max);
    t0 = max(tmin.x, max(tmin.y, max(tmin.z, 0))); // Usually ray_tmin = 0
    float t1 = min(tmax.x, min(tmax.y, min(tmax.z, tMax)));
    return (t0 <= t1);
}


float GetHeight(float3 CurrentPos, const TerrainData Terrain) {
    CurrentPos -= Terrain.PositionOffset;
    float3 b = float3(Terrain.TerrainDim,0.1f,Terrain.TerrainDim);
    float3 q = (abs(CurrentPos) - b);
    q.x /= Terrain.TerrainDim;
    q.z/= Terrain.TerrainDim;
    float2 uv = float2(min(CurrentPos.x / Terrain.TerrainDim, b.x / Terrain.TerrainDim), min(CurrentPos.z / Terrain.TerrainDim, b.z / Terrain.TerrainDim));
    float h = Heightmap.SampleLevel(sampler_trilinear_clamp, uv * (Terrain.HeightMap.xy - Terrain.HeightMap.zw) + Terrain.HeightMap.zw, 0).x;
    h *= Terrain.HeightScale * 2;
    q.y -= h;
    // q = max(0,q);
    return q.y;//length(q);
}

bool IntersectHeightMapShadow(Ray ray, float MaxDist) {
    float3 Origin = ray.origin;
    for(int i = 0; i < TerrainCount; i++) {
        const TerrainData Terrain = Terrains[i];
        float t0;
        if(rayBoxIntersection(Origin, ray.direction_inv, Terrain.PositionOffset, Terrain.PositionOffset + Terrain.TerrainDim, 9999999, t0)) {
            ray.origin = Origin + ray.direction * (t0 + 0.001f) - Terrain.PositionOffset;
            float3 CurrentPos = ray.origin;
            int step_count = 0;
            float Dist = 0;
            while(step_count < 2000 && Dist < MaxDist && all(ray.origin + ray.direction * Dist < float3(Terrain.TerrainDim,1000,Terrain.TerrainDim)) && all(CurrentPos > 0)) {
                CurrentPos = ray.origin + ray.direction * Dist;
                float3 b = float3(Terrain.TerrainDim,0.1f,Terrain.TerrainDim);
                float3 q = (abs(CurrentPos) - b);
                q.x /= Terrain.TerrainDim;
                q.z/= Terrain.TerrainDim;
                float2 uv = float2(min(CurrentPos.x / Terrain.TerrainDim, 1), min(CurrentPos.z / Terrain.TerrainDim, 1)) * (Terrain.HeightMap.xy - Terrain.HeightMap.zw) + Terrain.HeightMap.zw;
                step_count++;
                float h = Heightmap.SampleLevel(sampler_trilinear_clamp, uv, 0).x;
                h *= Terrain.HeightScale * 2;
                q.y -= h;
                q.y *= g;

                q = max(0,q);
                float dist = length(q);
                if(dist < 0.0001f) {
                    return true;
                }
                Dist += dist;

            }
        }
    }
    return false;

}

uniform bool TerrainExists;
inline float luminance(const float3 a) {
    return dot(float3(0.299f, 0.587f, 0.114f), a);
}

void IntersectShadowBrickmap() {
    uint ray_index;
    if(DoVoxels) {
        IntersectVoxelTLASShadow();
        } else {
            while(true) {
                InterlockedAdd(BufferSizes[CurBounce].brickmap_shadow_rays_retired, 1, ray_index);
                if(ray_index >= (uint)BufferSizes[CurBounce].shadow_rays) return;
                int pixel_index = ShadowRaysBuffer[ray_index].PixelIndex;
                Ray ray = CreateRay(ShadowRaysBuffer[ray_index].origin, ShadowRaysBuffer[ray_index].direction);
                if(ShadowRaysBuffer[ray_index].t == -1) { 
                    if(CurBounce == 0 && ShadowRaysBuffer[ray_index].PrimaryNEERay) 
                    CurrentReservoir[ShadowRaysBuffer[ray_index].PixelIndex].W = 0; 
                    CurrentReservoir[ShadowRaysBuffer[ray_index].PixelIndex].wsum = 0; 
                    continue;
                }
                bool HitHeightmap = TerrainExists;
                if(TerrainExists) HitHeightmap = IntersectHeightMapShadow(ray, ShadowRaysBuffer[ray_index].t);
                if(!HitHeightmap) {
                    CurrentReservoirGI[pixel_index].RadianceIncomming += ShadowRaysBuffer[ray_index].LuminanceIncomming;
                    if(ShadowRaysBuffer[ray_index].PrimaryNEERay) {
                        if(CurBounce == 0) {   
                            GlobalColors[pixel_index].Direct += ShadowRaysBuffer[ray_index].illumination;
                            } else {
                                SHData ThisSH = SH[pixel_index];
                                accumulate_SH(ThisSH, irradiance_to_SH(ShadowRaysBuffer[ray_index].illumination * 1024, Rays[pixel_index].direction), 1.0f);
                                SH[pixel_index] = ThisSH;
                                GlobalColors[pixel_index].Indirect +=ShadowRaysBuffer[ray_index].illumination;
                            }
                            } else {
                                GlobalColors[pixel_index].PrimaryNEERay += ShadowRaysBuffer[ray_index].illumination;
                                CurrentReservoirGI[pixel_index].NEERay = ShadowRaysBuffer[ray_index].RadianceIncomming;
                            }
                        }
                    }
                }
            }


            [numthreads(64,1,1)]
void kernel_shadow_brickmap () {//If I move the function contents into here, unity yells at me, so for now its just gonna continue to live in its function

    IntersectShadowBrickmap();
}
#pragma kernel kernel_heightmap

bool GetDist(float3 CurrentPos, out float2 uv, out float dist, const TerrainData Terrain) {
    float3 b = float3(Terrain.TerrainDim,0.1f,Terrain.TerrainDim);
    float3 q = (abs(CurrentPos) - b);
    q.x /= Terrain.TerrainDim;
    q.z/= Terrain.TerrainDim;
    uv = float2(min(CurrentPos.x / Terrain.TerrainDim, 1), min(CurrentPos.z / Terrain.TerrainDim, 1));
    float h = Heightmap.SampleLevel(sampler_trilinear_clamp, uv * (Terrain.HeightMap.xy - Terrain.HeightMap.zw) + Terrain.HeightMap.zw, 0).x;
    h *= Terrain.HeightScale * 2;
    q.y -= h;
    q.y *= g;
    float b2 = q.y;
    q = max(0,q);
    dist = length(q);
    return b2 != abs(b2);
}

void IntersectHeightMap() {
    Ray ray;
    Ray ray2;

    uint ray_index;
    RayHit bestHit;

    while(true) {
        bool DidHit = false;
        float3 CurrentPos;
        int step_count = 0;
        InterlockedAdd(BufferSizes[CurBounce].heighmap_rays_retired, 1, ray_index);
        if(ray_index >= (uint)BufferSizes[CurBounce].tracerays) return;
        ray.origin = GlobalRays2[ray_index].origin;
        CurrentPos = ray.origin;
        ray.direction = GlobalRays2[ray_index].direction;
        ray.direction_inv = rcp(ray.direction);
        ray2 = ray;
        bestHit = get2(ray_index);
        float dist = 999999;
        float2 uv;
        for(int i = 0; i < TerrainCount; i++) {
            float t0;
            float CurDist = 0;
            const TerrainData Terrain = Terrains[i];
            if(rayBoxIntersection(ray2.origin, ray.direction_inv, Terrain.PositionOffset + 0.001f, Terrain.PositionOffset + Terrain.TerrainDim - 0.001f, bestHit.t, t0)) {
                CurDist = 0;
                dist = 999999;
                ray.origin = ray2.origin + ray.direction * max(t0 + 0.0001f,0) - Terrain.PositionOffset;
                CurrentPos = ray.origin;
                float PrevDist = 0;
                step_count = 0;
                while(step_count < 2000 && CurDist < bestHit.t && all(ray.origin + ray.direction * CurDist < float3(Terrain.TerrainDim,1000,Terrain.TerrainDim)) && all(ray.origin + ray.direction * CurDist > float3(0,0,0))) {
                    CurrentPos = ray.origin + ray.direction * CurDist;
                    step_count++;
                    bool throwa = GetDist(CurrentPos, uv, dist, Terrain);
                    if(dist < 0.0001f) {
                        if(throwa) {
                            CurDist -= PrevDist /= 2;
                            for(int i = 0; i < 10; i++) {
                                if(GetDist(ray.origin + ray.direction * CurDist, uv, dist, Terrain)) {
                                    CurDist -= PrevDist /= 2;
                                } else {
                                    for(int i2 = 0; i2 < 10; i2++) {
                                        if(!GetDist(ray.origin + ray.direction * CurDist, uv, dist, Terrain)) {
                                            CurDist += PrevDist /= 2;
                                            } else {
                                                CurDist -= PrevDist;
                                                break;
                                            }
                                        }
                                        break;
                                }
                            }
                        }
                        bestHit.u = uv.x; 
                        bestHit.v = uv.y;
                        bestHit.t = CurDist + t0; 
                        bestHit.triangle_id = i;
                        set2(ray_index, bestHit);
                        GlobalRays2[ray_index].HitVoxel = 2;
                        break;
                    }
                    PrevDist = dist;
                    CurDist += dist;

                }
            }
        }
    }

}


        [numthreads(64,1,1)]
void kernel_heightmap () {//If I move the function contents into here, unity yells at me, so for now its just gonna continue to live in its function

    IntersectHeightMap();
}



#pragma kernel kernel_shade

int LightMeshCount;

struct LightMeshData {
    float4x4 Inverse;
    float3 Center;
    float pdf;
    float CDF;
    int StartIndex;
    int IndexEnd;
};
StructuredBuffer<LightMeshData> _LightMeshes;

struct LightData {
    float3 Radiance;
    float3 Position;
    float3 Direction;
    float pdf;
    float CDF;
    int Type;
    float2 SpotAngle;
};
StructuredBuffer<LightData> _UnityLights;


struct MaterialData {//56
    float4 AlbedoTex;//16
    float4 NormalTex;//32
    float4 EmissiveTex;//48
    float4 MetallicTex;//64
    float4 RoughnessTex;//80
    int HasAlbedoTex;//81
    int HasNormalTex;//82
    int HasEmissiveTex;//83
    int HasMetallicTex;//84
    int HasRoughnessTex;//85
    float3 BaseColor;
    float emmissive;
    float3 EmissionColor;
    float roughness;
    int MatType;
    float3 transmittanceColor;
    float ior;
    float metallic;
    float sheen;
    float sheenTint;
    float specularTint;
    float clearcoat;
    float clearcoatGloss;
    float anisotropic;
    float flatness;
    float diffTrans;
    float specTrans;
    int Thin;
    float Specular;
};


StructuredBuffer<MaterialData> _Materials;

Texture2D<float4> _SkyboxTexture;
SamplerState sampler_SkyboxTexture;

Texture2D<float4> _TextureAtlas;
SamplerState my_point_repeat_sampler;

Texture2D<float4> _NormalAtlas;
SamplerState sampler_NormalAtlas;

Texture2D<float4> _EmissiveAtlas;
SamplerState sampler_EmissiveAtlas;

Texture2D<float4> _MetalAlphaRoughnessAtlas;
SamplerState sampler_MetalAlphaRoughnessAtlas;

Texture2D<float4> _RoughnessAtlas;
SamplerState sampler_RoughnessAtlas;

//These are here purely for the Atrous


struct HitMat {
    float3 surfaceColor;
    float emmis;
    float roughness;
    uint MatType;
    float relativeIOR;
    float specularTint;
    float metallic;
    float ior;
    float anisotropic;
    float flatness;
    float specTrans;
    float clearcoat;
    float clearcoatGloss;
    float3 transmittanceColor;
    float3 scatterDistance;
    float phaseFunction;
    float3 extinction;
    float diffTrans;
    float sheen;
    float sheenTint;
    int Thin;
    float Specular;

    bool DoesPassThrough;
};

HitMat CreateHitMat() {
    HitMat hit;
    hit.surfaceColor  = float3(0.0f, 0.0f, 0.0f);
    hit.emmis = 0.0f;
    hit.roughness = 0.0f;
    hit.MatType = 0;
    hit.DoesPassThrough = false;
    hit.relativeIOR = 0;
    hit.ior = 0;
    hit.anisotropic = 0;
    hit.clearcoatGloss = 0;
    hit.flatness = 0;
    hit.clearcoat = 0;
    hit.transmittanceColor = 0;
    hit.scatterDistance = 0;
    hit.phaseFunction = 0;
    hit.extinction = 0;
    hit.diffTrans = 0;
    hit.sheen = 0;

    hit.sheenTint = 0;


    return hit;
}

int SelectUnityLight() {
    if(unitylightcount == 1) return 0;
    const float2 rand_light = random(5);
    return clamp((rand_light.y * unitylightcount), 0, unitylightcount - 1);
    float e = _UnityLights[unitylightcount - 1].CDF * rand_light.x + _UnityLights[0].CDF;
    int low = 0;
    int high = unitylightcount - 1;
    if(e > _UnityLights[high - 1].pdf + _UnityLights[high - 1].CDF) return high;
    int mid = -1;
    while(low < high) {
        int mid = (low + high) >> 1;
        LightData thislight = _UnityLights[mid];
        if(e < thislight.CDF)
        high = mid;
        else if(e > thislight.CDF + thislight.pdf)
        low = mid + 1;
        else
        return mid;
    }
    return mid;
    // Failed to find a light using importance sampling, pick a random one from the array
    // NOTE: this is a failsafe, we should never get here!
    return clamp((rand_light.y * unitylightcount), 0, unitylightcount - 1);
}
int SelectUnityLight(float2 rand_light) {
    if(unitylightcount == 1) return 0;
    return clamp((rand_light.y * unitylightcount), 0, unitylightcount - 1);
    float e = _UnityLights[unitylightcount - 1].CDF * rand_light.x + _UnityLights[0].CDF;
    int low = 0;
    int high = unitylightcount - 1;
    if(e > _UnityLights[high - 1].pdf + _UnityLights[high - 1].CDF) return high;
    int mid = -1;
    while(low < high) {
        int mid = (low + high) >> 1;
        LightData thislight = _UnityLights[mid];
        if(e < thislight.CDF)
        high = mid;
        else if(e > thislight.CDF + thislight.pdf)
        low = mid + 1;
        else
        return mid;
    }
    return mid;
    // Failed to find a light using importance sampling, pick a random one from the array
    // NOTE: this is a failsafe, we should never get here!
    return clamp((rand_light.y * unitylightcount), 0, unitylightcount - 1);
}

int SelectLight(int MeshIndex, bool DoSimple) {//Need to check these to make sure they arnt simply doing uniform sampling

    const float2 rand_light = random(3);
    const int StartIndex = _LightMeshes[MeshIndex].StartIndex;
    const int IndexEnd = _LightMeshes[MeshIndex].IndexEnd;
   // if(DoSimple) return clamp((rand_light.y * (IndexEnd - StartIndex) + StartIndex), StartIndex, IndexEnd - 1);
   float e = LightTriangles[IndexEnd - 1].sumEnergy * rand_light.x + LightTriangles[StartIndex].pdf;
   int low = StartIndex;
   int high = IndexEnd - 1;
   if(e > LightTriangles[high - 1].pdf + LightTriangles[high - 1].sumEnergy) return high;
   int mid = -1;
   while(low < high) {
    int mid = (low + high) >> 1;
    LightTriangleData tri = LightTriangles[mid];
    if(e < tri.sumEnergy)
    high = mid;
    else if(e > tri.sumEnergy + tri.pdf)
    low = mid + 1;
    else
    return mid;
}
  //  return mid;
    // Failed to find a light using importance sampling, pick a random one from the array
    // NOTE: this is a failsafe, we should never get here!
    return clamp((rand_light.y * (IndexEnd - StartIndex) + StartIndex), StartIndex, IndexEnd - 1);
}
int SelectLight(int MeshIndex, float2 rand_light) {//Need to check these to make sure they arnt simply doing uniform sampling

    const int StartIndex = _LightMeshes[MeshIndex].StartIndex;
    const int IndexEnd = _LightMeshes[MeshIndex].IndexEnd;
   // if(DoSimple) return clamp((rand_light.y * (IndexEnd - StartIndex) + StartIndex), StartIndex, IndexEnd - 1);
   float e = LightTriangles[IndexEnd - 1].sumEnergy * rand_light.x + LightTriangles[StartIndex].pdf;
   int low = StartIndex;
   int high = IndexEnd - 1;
   if(e > LightTriangles[high - 1].pdf + LightTriangles[high - 1].sumEnergy) return high;
   int mid = -1;
   while(low < high) {
    int mid = (low + high) >> 1;
    LightTriangleData tri = LightTriangles[mid];
    if(e < tri.sumEnergy)
    high = mid;
    else if(e > tri.sumEnergy + tri.pdf)
    low = mid + 1;
    else
    return mid;
}
  //  return mid;
    // Failed to find a light using importance sampling, pick a random one from the array
    // NOTE: this is a failsafe, we should never get here!
    return clamp((rand_light.y * (IndexEnd - StartIndex) + StartIndex), StartIndex, IndexEnd - 1);
}

int SelectLightMesh() {//Select mesh to sample light from
    if(LightMeshCount == 1) return 0;
    const float2 rand_mesh = random(4);
    return clamp((rand_mesh.y * LightMeshCount), 0, LightMeshCount - 1);
}

float2 sample_disc(float u1, float u2) {
    float a = 2.0f * u1 - 1.0f;
    float b = 2.0f * u2 - 1.0f;
    if(a == 0.0f) a = 0.00001;
    if(b == 0.0f) b = 0.00001;

    float phi, r;
    if(a*a > b*b) {
        r = a;
        phi = (0.25f * PI) * (b/a);
        } else {
            r = b;
            phi = (0.25f * PI) * (a/b) + (0.5f * PI);
        }

        float sin_phi, cos_phi;
        sincos(phi, sin_phi, cos_phi);

        return float2(r * cos_phi, r * sin_phi);
    }

    float3 sample_cosine_weighted_direction(float u1, float u2) {
        float2 d = sample_disc(u1, u2);
        return float3(d.x, d.y, sqrt(abs(1.0f - dot(d, d))));
    }

float3 sample(inout float pdf) {//Diffuse
    float2 rando = random(5);
    float3 omega_o = sample_cosine_weighted_direction(rando.x, rando.y);
    pdf = omega_o.z * ONE_OVER_PI;
    return omega_o;
}

float3 sample(inout float pdf, int rand) {//Diffuse
    float2 rando = random(rand);
    float3 omega_o = sample_cosine_weighted_direction(rando.x, rando.y);
    pdf = omega_o.z * ONE_OVER_PI;
    return omega_o;
}

float3x3 GetTangentSpace(float3 normal) {
    // Choose a helper floattor for the cross product
    float3 helper = float3(1, 0, 0);
    if (abs(normal.x) > 0.99f)
    helper = float3(0, 0, 1);

    // Generate floattors
    float3 tangent = normalize(cross(normal, helper));
    float3 binormal = cross(normal, tangent);
    
    return float3x3(tangent, binormal, normal);
}
float3x3 GetTangentSpace2(float3 normal) {
    // Choose a helper floattor for the cross product
    float3 helper = float3(1, 0, 0);
    if (abs(normal.x) > 0.99f)
    helper = float3(0, 0, 1);

    // Generate floattors
    float3 tangent = normalize(cross(normal, helper));
    float3 binormal = cross(normal, tangent);
    
    return float3x3(tangent, normal, binormal);
}

float3 sample_visible_normals_ggx(float3 omega, float alpha_x, float alpha_y, float u1, float u2) {
    float3 v = normalize(float3(alpha_x * omega.x, alpha_y * omega.y, omega.z));

    float length_squared = v.x*v.x + v.y*v.y;
    float3 axis_1 = (length_squared > 0.0f) ? float3(-v.y, v.x, 0.0f) / sqrt(length_squared) : float3(1.0f, 0.0f, 0.0f);
    float3 axis_2 = cross(v, axis_1);

    float2 d = sample_disc(u1, u2);
    float t1 = d.x;
    float t2 = d.y;

    float s = 0.5f * (1.0f + v.z);
    t2 = (1.0f - s) * sqrt(max(1.0f - t1 * t1, 0.0f)) + s*t2;

    float3 n_h = t1*axis_1 + t2*axis_2 + sqrt(max(0.0f, 1.0f - t1*t1 - t2*t2)) * v;

    return normalize(float3(alpha_x * n_h.x, alpha_y * n_h.y, n_h.z));
}

float fresnel_dielectric(float cos_theta_i, float eta) {
    float sin_theta_o2 = eta * eta * (1.0f - cos_theta_i*cos_theta_i);
    if(sin_theta_o2 >= 1.0f) {
        return 1.0f;
    }

    float cos_theta_o = sqrt(max(1.0f - sin_theta_o2, 0.0f));

    float s = (cos_theta_i - eta * cos_theta_o) / (eta * cos_theta_o + cos_theta_i);
    float p = (eta * cos_theta_i - cos_theta_o) / (eta * cos_theta_i + cos_theta_o);

    return 0.5f * (p*p + s*s);
}


float ggx_D(const float3 micro_normal, float alpha_x, float alpha_y) {
    float sx = -micro_normal.x / (micro_normal.z * alpha_x);
    float sy = -micro_normal.y / (micro_normal.z * alpha_y);

    float s1 = 1.0f + sx * sx + sy * sy;

    float cos_theta_2 = micro_normal.z * micro_normal.z;
    float cos_theta_4 = cos_theta_2 * cos_theta_2;

    return 1.0f / (s1 * s1 * PI * alpha_x * alpha_y * cos_theta_4);
}

float ggx_lambda(const float3 omega, float alpha_x, float alpha_y) {
    return 0.5f * (sqrt(1.0f + ((alpha_x * omega.x) * (alpha_x * omega.x) + (alpha_y * omega.y) * (alpha_y * omega.y)) / (omega.z * omega.z)) - 1.0f);
}
float ggx_G1(const float3 omega, float alpha_x, float alpha_y) {
    return 1.0f / (1.0f + ggx_lambda(omega, alpha_x, alpha_y));
}

float ggx_G2(const float3 omega_o, const float3 omega_i, const float3 omega_m, float alpha_x, float alpha_y) {
    bool omega_i_backfacing = dot(omega_i, omega_m) * omega_i.z <= 0.0f;
    bool omega_o_backfacing = dot(omega_o, omega_m) * omega_o.z <= 0.0f;

    if(omega_i_backfacing || omega_o_backfacing) {
        return 0.0f;
        } else {
            return 1.0f / (1.0f + ggx_lambda(omega_o, alpha_x, alpha_y) + ggx_lambda(omega_i, alpha_x, alpha_y));
        }
    }


    inline void orthonormal_basis(const float3 normal, inout float3 tangent, inout float3 binormal) {
        float sign2 = (normal.z >= 0.0f) ? 1.0f : -1.0f;
        float a = -1.0f / (sign2 + normal.z);
        float b = normal.x * normal.y * a;

        tangent  = float3(1.0f + sign2 * normal.x * normal.x * a, sign2 * b, -sign2 * normal.x);
        binormal = float3(b, sign2 + normal.y * normal.y * a, -normal.y);
    }

    inline float3 local_to_world(const float3 float, const float3 tangent, const float3 binormal, const float3 normal) {
        return float3(
            tangent.x * float.x + binormal.x * float.y + normal.x * float.z,
            tangent.y * float.x + binormal.y * float.y + normal.y * float.z,
            tangent.z * float.x + binormal.z * float.y + normal.z * float.z
            );
    }

    float3 sample_henyey_greenstein(const float3 omega, float g, float u1, float u2) {
        float cos_theta;
        if (abs(g) < 1e-3f) {
        // Isotropic case
        cos_theta = 1.0f - 2.0f * u1;
        } else {
            float sqr_term = (1.0f - g * g) / (1.0f + g - 2.0f * g * u1);
            cos_theta = -(1.0f + g * g - sqr_term * sqr_term) / (2.0f * g);
        }
        float sin_theta = sqrt(max(1.0f - cos_theta * cos_theta, 0.0f));

        float phi = (PI * 2.0f) * u2;
        float sin_phi, cos_phi;
        sincos(phi, sin_phi, cos_phi);

        float3 direction = float3(
            sin_theta * cos_phi,
            sin_theta * sin_phi,
            cos_theta
            );

        float3 v1, v2;
        orthonormal_basis(omega, v1, v2);

        return local_to_world(direction, v1, v2, omega);
    }

    bool VolumetricScatter(inout float3 throughput, RayHit hit, inout Ray ray, inout float3 Pos, HitMat hitDat) {
        float3 SigmaS = hitDat.surfaceColor;
        float3 SigmaA = hitDat.transmittanceColor;

        bool medium_can_scatter = (SigmaS.x + SigmaS.y + SigmaS.z) > 0.0f;

        if(medium_can_scatter) {
            float2 rand_scatter = random(3);
            float2 rand_phase = random(5);

            float3 sigma_t = SigmaA + SigmaS;

            float throughput_sum = throughput.x + throughput.y + throughput.z;
            float3 wavelength_pdf = throughput / throughput_sum;

            float sigma_t_used_for_sampling;
            if(rand_scatter.x * throughput_sum < throughput.x) {
                sigma_t_used_for_sampling = sigma_t.x;
                } else if(rand_scatter.x * throughput_sum < throughput.x + throughput.y) {
                    sigma_t_used_for_sampling = sigma_t.y;
                    } else {
                        sigma_t_used_for_sampling = sigma_t.z;
                    }

                    float scatter_distance = -log(rand_scatter.y) / sigma_t_used_for_sampling;
                    float dist = min(scatter_distance, hit.t);
                    float3 transmittance = float3(
                        exp(-sigma_t.x * dist),
                        exp(-sigma_t.y * dist),
                        exp(-sigma_t.z * dist)
                        );

                    if(scatter_distance < hit.t) {
                        float3 pdf = wavelength_pdf * sigma_t * transmittance;
                        throughput *= SigmaS * transmittance / (pdf.x + pdf.y + pdf.z);

                        float3 direction_out = sample_henyey_greenstein(-ray.direction, hitDat.roughness, rand_phase.x, rand_phase.y);

                        float3 ray_origin = ray.origin;
                        ray.origin = ray_origin + scatter_distance * ray.direction;
                        Pos = ray.origin;
                        ray.direction = direction_out;
                        return true;
                        } else {
                            float3 pdf = wavelength_pdf * transmittance;
                            throughput *= transmittance / (pdf.x + pdf.y + pdf.z);
                            return false;
                        }
                    }
                    return false;
                }

                float3 SunDir;

                static uint ScatteringTexRSize = 32;
                static uint ScatteringTexMUSize = 128;
                static uint ScatteringTexMUSSize = 32;
                static uint ScatteringTexNUSize = 8;

                static float bottom_radius = 6360000.0f;
                static float top_radius = 6420000.0f;
                static uint TransmittanceTexWidth = 256;
                static uint TransmittanceTexHeight = 64;

                float RayleighPhaseFunction(float nu) {
                  float k = 3.0 / (16.0 * PI);
                  return k * (1.0 + nu * nu);
              }
              float GetTextureCoordFromUnitRange(float x, int texture_size) {
                return 0.5f / (float)texture_size + x * (1.0f - 1.0f / (float)texture_size);
            }

            float MiePhaseFunction(float g, float nu) {
              float k = 3.0 / (8.0 * PI) * (1.0 - g * g) / (2.0 + g * g);
              return k * (1.0 + nu * nu) / pow(1.0 + g * g - 2.0 * g * nu, 1.5);
          }

          float GetUnitRangeFromTextureCoord(float u, int texture_size) {
            return (u - 0.5f / (float)texture_size) / (1.0f - 1.0f / (float)texture_size);
        }

        float DistanceToTopAtmosphereBoundary(float r, float mu) {
            float discriminant = r * r * (mu * mu - 1.0f) + top_radius * top_radius;
            return max(-r * mu + sqrt(max(discriminant, 0.0f)), 0.0f);
        }

        float4 GetScatteringTextureUvwzFromRMuMuSNu(float r, float mu, float mu_s, float nu, bool ray_r_mu_intersects_ground) {
            float H = sqrt(top_radius * top_radius - bottom_radius * bottom_radius);
            float rho = sqrt(max(r * r - bottom_radius * bottom_radius, 0.0f));
            float u_r = GetTextureCoordFromUnitRange(rho / H, ScatteringTexRSize);

            float r_mu = r * mu;
            float discriminant = r_mu * r_mu - r * r + bottom_radius * bottom_radius;
            float u_mu;
            if(ray_r_mu_intersects_ground) {
                float d = -r_mu - sqrt(max(discriminant, 0.0f));
                float d_min = r - bottom_radius;
                float d_max = rho;
                u_mu = 0.5f - 0.5f * GetTextureCoordFromUnitRange((d_max == d_min) ? 0.0f : (d - d_min) / (d_max - d_min), ScatteringTexMUSize / 2);
                } else {
                    float d = -r_mu + sqrt(max(discriminant + H * H, 0.0f));
                    float d_min = top_radius - r;
                    float d_max = rho + H;
                    u_mu = 0.5f + 0.5f * GetTextureCoordFromUnitRange((d - d_min) / (d_max - d_min), ScatteringTexMUSize / 2);
                }

                float d = DistanceToTopAtmosphereBoundary(bottom_radius, mu_s);
                float d_min = top_radius - bottom_radius;
                float d_max = H;
                float a = (d - d_min) / (d_max - d_min);
                float D = DistanceToTopAtmosphereBoundary(bottom_radius, -0.8f);
                float A = (D - d_min) / (d_max - d_min);

                float u_mu_s = GetTextureCoordFromUnitRange(max(1.0f - a / A, 0.0f) / (1.0f + a), ScatteringTexMUSSize);

                float u_nu = (nu + 1.0f) / 2.0f;
                return float4(u_nu, u_mu_s, u_mu, u_r);
            }


            Texture3D<float4> scattering_texture;
            Texture2D<float4> TransmittanceTex;
            SamplerState linearClampSampler;
            SamplerState sampler_scattering_texture_trilinear_clamp;

            static float3 rayleigh_scattering = float3(5.85f, 13.558f, 33.10f) * 0.001f;
            static float3 mie_scattering = 3.996f * 0.001f;

            float ClampCosine(float mu) {
              return clamp(mu, -1.0f, 1.0f);
          }

          float ClampRadius(float r) {
              return clamp(r, bottom_radius, top_radius);
          }


          float3 GetExtrapolatedSingleMieScattering(
            float4 scattering) {
              if (scattering.r == 0.0) {
                return 0;
            }
            return scattering.rgb * scattering.a / scattering.r *
            (rayleigh_scattering.r / mie_scattering.r) *
            (mie_scattering / rayleigh_scattering);
        }

        float3 GetCombinedScattering(
            float r, float mu, float mu_s, float nu,
            bool ray_r_mu_intersects_ground,
            inout float3 single_mie_scattering) {
          float4 uvwz = GetScatteringTextureUvwzFromRMuMuSNu(r, mu, mu_s, nu, ray_r_mu_intersects_ground);
          float tex_coord_x = uvwz.x * float(ScatteringTexNUSize - 1);
          float tex_x = floor(tex_coord_x);
          float lerp2 = tex_coord_x - tex_x;
          float3 uvw0 = float3((tex_x + uvwz.y) / float(ScatteringTexNUSize),
              uvwz.z, uvwz.w);
          float3 uvw1 = float3((tex_x + 1.0 + uvwz.y) / float(ScatteringTexNUSize),
              uvwz.z, uvwz.w);
          float4 combined_scattering =
          scattering_texture.SampleLevel(sampler_scattering_texture_trilinear_clamp, uvw0, 0) * (1.0 - lerp2) +
          scattering_texture.SampleLevel(sampler_scattering_texture_trilinear_clamp, uvw1, 0) * lerp2;
          float3 scattering = float3(combined_scattering.rgb);
          single_mie_scattering =
          GetExtrapolatedSingleMieScattering(combined_scattering);
          return scattering;
      }

      bool RayIntersectsGround(float r, float mu) {
        return (mu < 0.0f && r * r * (mu * mu - 1.0f) + bottom_radius * bottom_radius >= 0.0f);
    }

    float2 GetTransmittanceTextureUvFromRMu(float r, float mu) {
        float H = sqrt(top_radius * top_radius - bottom_radius * bottom_radius);

        float rho = sqrt(max(r * r - bottom_radius * bottom_radius, 0.0f));

        float d = DistanceToTopAtmosphereBoundary(r, mu);
        float d_min = top_radius - r;
        float d_max = rho + H;
        float x_mu = (d - d_min) / (d_max - d_min);
        float x_r = rho / H;
        return float2(GetTextureCoordFromUnitRange(x_mu, TransmittanceTexWidth), GetTextureCoordFromUnitRange(x_r, TransmittanceTexHeight));
    }

    SamplerState _LinearClamp;

    float4 TEX2D(Texture2D<float4> tex, float2 uv)
    {
        return tex.SampleLevel(_LinearClamp, uv, 0);
    }

    float3 GetTransmittanceToTopAtmosphereBoundary(float r, float mu) {
        float2 uv = GetTransmittanceTextureUvFromRMu(r, mu);
        return TEX2D(TransmittanceTex, uv).rgb;
    }

    float3 GetTransmittance(float r, float mu, float d, bool ray_r_mu_intersects_ground) {

        float r_d = clamp(sqrt(d * d + 2.0f * r * mu * d + r * r), bottom_radius, top_radius);
        float mu_d = clamp((r * mu + d) / r_d, -1.0f, 1.0f);
        if(ray_r_mu_intersects_ground) {
            return min(GetTransmittanceToTopAtmosphereBoundary(r_d, -mu_d) / 
                GetTransmittanceToTopAtmosphereBoundary(r, -mu), 
                float3(1.0f, 1.0f, 1.0f));

            } else {
                return min(GetTransmittanceToTopAtmosphereBoundary(r, mu) / 
                    GetTransmittanceToTopAtmosphereBoundary(r_d, mu_d), 
                    float3(1.0f, 1.0f, 1.0f));
            }
        }   

        float3 GetSkyRadiance(
            float3 camera, float3 view_ray, float shadow_length,
            float3 sun_direction, inout float3 transmittance) {
            camera.y += bottom_radius;
            camera.y = max(camera.y, bottom_radius + 1);

  // Compute the distance to the top atmosphere boundary along the view ray,
  // assuming the viewer is in space (or NaN if the view ray does not intersect
  // the atmosphere).
  float r = length(camera);
  float rmu = dot(camera, view_ray);
  float distance_to_top_atmosphere_boundary = -rmu -
  sqrt(rmu * rmu - r * r + top_radius * top_radius);
  // If the viewer is in space and the view ray intersects the atmosphere, move
  // the viewer to the top atmosphere boundary (along the view ray):
  if (distance_to_top_atmosphere_boundary > 0.0) {
    camera = camera + view_ray * distance_to_top_atmosphere_boundary;
    r = top_radius;
    rmu += distance_to_top_atmosphere_boundary;
    } else if (r >= top_radius) {
    // If the view ray does not intersect the atmosphere, simply return 0.
    transmittance = 1;
    return 0;
}
  // Compute the r, mu, mu_s and nu parameters needed for the texture lookups.
  float mu = rmu / r;
  float mu_s = dot(camera, sun_direction) / r;
  float nu = dot(view_ray, sun_direction);
  bool ray_r_mu_intersects_ground = RayIntersectsGround(r, mu);

  transmittance = ray_r_mu_intersects_ground ? 0.0 :
  GetTransmittanceToTopAtmosphereBoundary(r, mu);
  float3 single_mie_scattering;
  float3 scattering;
  if (shadow_length == 0.0) {
    scattering = GetCombinedScattering(
        r, mu, mu_s, nu, ray_r_mu_intersects_ground,
        single_mie_scattering);
    } else {
    // Case of light shafts (shadow_length is the total length noted l in our
    // paper): we omit the scattering between the camera and the point at
    // distance l, by implementing Eq. (18) of the paper (shadow_transmittance
    // is the T(x,x_s) term, scattering is the S|x_s=x+lv term).
    float d = shadow_length;
    float r_p =
    ClampRadius(sqrt(d * d + 2.0 * r * mu * d + r * r));
    float mu_p = (r * mu + d) / r_p;
    float mu_s_p = (r * mu_s + d * nu) / r_p;

    scattering = GetCombinedScattering(
        r_p, mu_p, mu_s_p, nu, ray_r_mu_intersects_ground,
        single_mie_scattering);
    float3 shadow_transmittance =
    GetTransmittance(r, mu, shadow_length, ray_r_mu_intersects_ground);
    scattering = scattering * shadow_transmittance;
    single_mie_scattering = single_mie_scattering * shadow_transmittance;
}
return scattering * RayleighPhaseFunction(nu) + single_mie_scattering *
MiePhaseFunction(0.8f, nu);
}



float2 sample_triangle(float u1, float u2) {
    if (u2 > u1) {
        u1 *= 0.5f;
        u2 -= u1;
        } else {
            u2 *= 0.5f;
            u1 -= u2;
        }
        return float2(u1, u2);
    }

    bool evaldiffuse(const float3 to_light, float cos_theta_o, inout float3 bsdf, inout float pdf) {
        if (cos_theta_o <= 0.0f) return false;

        bsdf = float3(cos_theta_o * ONE_OVER_PI, cos_theta_o * ONE_OVER_PI, cos_theta_o * ONE_OVER_PI);
        pdf  = cos_theta_o * ONE_OVER_PI;

        return (pdf > 0 || pdf < 0 || pdf == 0);
    }

    inline float power_heuristic(float pdf_f, float pdf_g) {
    return (pdf_f * pdf_f) / (pdf_f * pdf_f + pdf_g * pdf_g); // Power of 2 hardcoded, best empirical results according to Veach
}

inline float luminance(const float r, const float g, const float b) {
    return 0.299f * r + 0.587f * g + 0.114f * b;
}


void sampleEquiAngular( float u, float maxDistance, float3 rOrigin, float3 rDirection, float3 lightPos, inout float dist, inout float pdf )
{
    // get coord of closest point to light along (infinite) ray
    float delta = clamp(dot(lightPos - rOrigin, rDirection), 0.0, 1.0);
    
    // get distance this point is from light
    float D = distance(rOrigin + delta * rDirection, lightPos);

    // get angle of endpoints
    float thetaA = atan((0.0 - delta) / D);
    float thetaB = atan((maxDistance - delta) / D);

    // take sample
    float t = D * tan( lerp(thetaA, thetaB, u) );
    dist = delta + t;
    pdf = D / ( (thetaB - thetaA) * (D * D + t * t) );
}
inline float average_fresnel(float ior) {
    // Approximation by Kully-Conta 2017
    return (ior - 1.0f) / (4.08567f + 1.00071f*ior);
}
bool evalplastic(HitMat material, float3 to_light, float cos_theta_o, inout float3 bsdf, inout float pdf, float3 omega_i) {
    bsdf = 0;
    pdf = 0;
    if (cos_theta_o <= 0.0f) return false;
    float3 omega_o = to_light;

    float3 omega_m = normalize(omega_i + omega_o);

    float ETA = 1.0f / material.ior;
        // Specular component
        float alpha_x = max(0.000001f, material.roughness * material.roughness);
        float alpha_y = alpha_x;

        float F  = fresnel_dielectric(dot(omega_i, omega_m), ETA);
        float D  = ggx_D (omega_m, alpha_x, alpha_y);
        float G1 = ggx_G1(omega_i, alpha_x, alpha_y);
        float G2 = ggx_G2(omega_o, omega_i, omega_m, alpha_x, alpha_y);

        float3 brdf_specular = F * G2 * D / (4.0f * omega_i.z);

        // Diffuse component
        float F_i = fresnel_dielectric(omega_i.z, ETA);
        float F_o = fresnel_dielectric(omega_o.z, ETA);

        float F_avg = average_fresnel(material.ior);
        float internal_scattering_factor = 1.0f - (1.0f - F_avg) * ETA * ETA;

        float3 brdf_diffuse = ETA*ETA * (1.0f - F_i) * (1.0f - F_o) * material.surfaceColor * ONE_OVER_PI / (1.0f - material.surfaceColor * internal_scattering_factor) * omega_o.z;

        float pdf_specular = G1 * D / (4.0f * omega_i.z);
        float pdf_diffuse  = omega_o.z * ONE_OVER_PI;

        pdf  = lerp(pdf_diffuse, pdf_specular, F_i);
        bsdf = brdf_specular + brdf_diffuse; // BRDF * cos(theta_o)

        return (pdf > 0 || pdf < 0 || pdf == 0);
    }

    bool sampleplastic(HitMat material, inout float3 throughput, inout float3 direction_out, inout float pdf, float3 omega_i) {
        float  rand_fresnel = random(5).x;
        float2 rand_brdf    = random(6);
        float ETA = 1.0f / material.ior;
        float F_i = fresnel_dielectric(omega_i.z, ETA);

        float alpha_x = max(0.000001f, material.roughness * material.roughness);
        float alpha_y = alpha_x;

        float3 omega_m;
        float3 omega_o;
        if (rand_fresnel < F_i) {
            // Sample specular component
            omega_m = sample_visible_normals_ggx(omega_i, alpha_x, alpha_y, rand_brdf.x, rand_brdf.y);
            omega_o = reflect(-omega_i, omega_m);
            } else {
            // Sample diffuse component
            omega_o = sample_cosine_weighted_direction(rand_brdf.x, rand_brdf.y);
            omega_m = normalize(omega_i + omega_o);
        }

        if (omega_m.z < 0.0f) return false; // Wrong hemisphere

        // Specular component
        float F  = fresnel_dielectric(dot(omega_i, omega_m), ETA);
        float D  = ggx_D (omega_m, alpha_x, alpha_y);
        float G1 = ggx_G1(omega_i, alpha_x, alpha_y);
        float G2 = ggx_G2(omega_o, omega_i, omega_m, alpha_x, alpha_y);

        float3 brdf_specular = F * G2 * D / (4.0f * omega_i.z);

        // Diffuse component
        float F_o = fresnel_dielectric(omega_o.z, ETA);

        float F_avg = average_fresnel(material.ior);
        float internal_scattering_factor = 1.0f - (1.0f - F_avg) * ETA * ETA;

        float3 brdf_diffuse = ETA*ETA * (1.0f - F_i) * (1.0f - F_o) * material.surfaceColor * ONE_OVER_PI / (1.0f - material.surfaceColor * internal_scattering_factor) * omega_o.z;

        float pdf_specular = G1 * D / (4.0f * omega_i.z);
        float pdf_diffuse  = omega_o.z * ONE_OVER_PI;
        pdf = lerp(pdf_diffuse, pdf_specular, F_i);

        throughput *= (brdf_specular + brdf_diffuse) / pdf; // BRDF * cos(theta) / pdf

        direction_out = omega_o;

        return (pdf > 0 || pdf < 0 || pdf == 0);
    }


    bool VisabilityCheck(Ray ray, float dist) {

        uint2 stack[24];
        int stack_size = 0;
        uint ray_index;
        uint2 current_group;

        uint oct_inv4;
        int tlas_stack_size;
        int mesh_id;
        float max_distance;
        Ray ray2;

        bool inactive = stack_size == 0 && current_group.y == 0;

        ray.direction_inv = rcp(ray.direction);
        ray2 = ray;

        oct_inv4 = ray_get_octant_inv4(ray.direction);

        current_group.x = (uint)0;
        current_group.y = (uint)0x80000000;

        max_distance = dist;

        tlas_stack_size = -1;

        while(true) {//Traverse Accelleration Structure(Compressed Wide Bounding Volume Hierarchy)            
            uint2 triangle_group;
            if(current_group.y & 0xff000000) {
                uint hits_imask = current_group.y;
                uint child_index_offset = firstbithigh(hits_imask);
                uint child_index_base = current_group.x;

                current_group.y &= ~(1 << child_index_offset);

                if(current_group.y & 0xff000000) {
                    stack[stack_size++] = current_group;
                }
                uint slot_index = (child_index_offset - 24) ^ (oct_inv4 & 0xff);
                uint relative_index = countbits(hits_imask & ~(0xffffffff << slot_index));
                uint child_node_index = child_index_base + relative_index;

                float3 node_0 = cwbvh_nodes[child_node_index].node_0xyz;
                uint node_0w = cwbvh_nodes[child_node_index].node_0w;
                
                uint4 node_1 = cwbvh_nodes[child_node_index].node_1;
                uint4 node_2 = cwbvh_nodes[child_node_index].node_2;
                uint4 node_3 = cwbvh_nodes[child_node_index].node_3;
                uint4 node_4 = cwbvh_nodes[child_node_index].node_4;

                uint hitmask = cwbvh_node_intersect(ray, oct_inv4, max_distance, node_0, node_0w, node_1, node_2, node_3, node_4);

                uint imask = (node_0w >> (3 * 8)) & 0xff;

                current_group.x = asuint(node_1.x) + ((tlas_stack_size == -1) ? 0 : _MeshData[mesh_id].NodeOffset);
                triangle_group.x = asuint(node_1.y) + ((tlas_stack_size == -1) ? 0 : _MeshData[mesh_id].TriOffset);

                current_group .y = (hitmask & 0xff000000) | (uint)(imask);
                triangle_group.y = (hitmask & 0x00ffffff);
            }
            else {
                triangle_group.x = current_group.x;
                triangle_group.y = current_group.y;
                current_group.x = (uint)0;
                current_group.y = (uint)0;
            }

            bool hit = false;

            while(triangle_group.y != 0) { 
                if(tlas_stack_size == -1) {//Transfer from Top Level Accelleration Structure to Bottom Level Accelleration Structure
                    uint mesh_offset = firstbithigh(triangle_group.y);
                    triangle_group.y &= ~(1 << mesh_offset);

                    mesh_id = triangle_group.x + mesh_offset;

                    if(triangle_group.y != 0) {
                        stack[stack_size++] = triangle_group;
                    }

                    if(current_group.y & 0xff000000) {
                        stack[stack_size++] = current_group;
                    }
                    tlas_stack_size = stack_size;

                    int root_index = (_MeshData[mesh_id].mesh_data_bvh_offsets & 0x7fffffff);

                    ray.direction = (mul(_MeshData[mesh_id].Transform, float4(ray.direction, 0))).xyz;
                    ray.origin = (mul(_MeshData[mesh_id].Transform, float4(ray.origin, 1))).xyz;
                    ray.direction_inv = rcp(ray.direction);

                    oct_inv4 = ray_get_octant_inv4(ray.direction);

                    current_group.x = (uint)root_index;
                    current_group.y = (uint)0x80000000;

                    break;
                }
                else {
                    uint triangle_index =  firstbithigh(triangle_group.y);
                    triangle_group.y &= ~(1 << triangle_index);

                    if(triangle_intersect_shadow(triangle_group.x + triangle_index, ray, max_distance)) {
                        hit = true;
                        break;
                    }
                }
            }

            if(hit) {
                return false;
            }

            if((current_group.y & 0xff000000) == 0) {
                if(stack_size == 0) {//thread has finished traversing
                    return true;
                }

                if(stack_size == tlas_stack_size) {
                    tlas_stack_size = -1;
                    ray = ray2;
                    oct_inv4 = ray_get_octant_inv4(ray.direction);
                }
                current_group = stack[--stack_size];
            }
        }
}

void RayCast(inout RayHit bestHit, Ray ray) {
    uint2 stack[24];

    int stack_size = 0;
    uint ray_index;
    uint2 current_group;

    uint oct_inv4;
    int tlas_stack_size;
    int mesh_id = -1;
    int NodeOffset = 0;
    int TriOffset = 0;
    Ray ray2;

    while(true) {
        ray2 = ray;

        oct_inv4 = ray_get_octant_inv4(ray.direction);

        current_group.x = (uint)0;
        current_group.y = (uint)0x80000000;
        bestHit = CreateRayHit();

        tlas_stack_size = -1;

        while(true) {//Traverse Accelleration Structure(Compressed Wide Bounding Volume Hierarchy)            
            uint2 triangle_group;
            if(current_group.y & 0xff000000) {
                uint hits_imask = current_group.y;
                uint child_index_offset = firstbithigh(hits_imask);
                uint child_index_base = current_group.x;

                current_group.y &= ~(1 << child_index_offset);

                if(current_group.y & 0xff000000) {
                    stack[stack_size++] = current_group;
                }
                uint slot_index = (child_index_offset - 24) ^ (oct_inv4 & 0xff);
                uint relative_index = countbits(hits_imask & ~(0xffffffff << slot_index));
                uint child_node_index = child_index_base + relative_index;
                const BVHNode8Data TempNode = cwbvh_nodes[child_node_index];
                float3 node_0 = TempNode.node_0xyz;
                uint node_0w = TempNode.node_0w;
                
                uint4 node_1 = TempNode.node_1;
                uint4 node_2 = TempNode.node_2;
                uint4 node_3 = TempNode.node_3;
                uint4 node_4 = TempNode.node_4;

                uint hitmask = cwbvh_node_intersect(ray, oct_inv4, bestHit.t, node_0, node_0w, node_1, node_2, node_3, node_4);
                uint imask = (node_0w >> (24)) & 0xff;

                current_group.x = asuint(node_1.x) + ((tlas_stack_size == -1) ? 0 : NodeOffset);
                triangle_group.x = asuint(node_1.y) + ((tlas_stack_size == -1) ? 0 : TriOffset);
                current_group .y = (hitmask & 0xff000000) | (imask);
                triangle_group.y = (hitmask & 0x00ffffff);

            }
            else {
                triangle_group.x = current_group.x;
                triangle_group.y = current_group.y;
                current_group.x = (uint)0;
                current_group.y = (uint)0;
            }

            while(triangle_group.y != 0) { 

                if(tlas_stack_size == -1) {//Transfer from Top Level Accelleration Structure to Bottom Level Accelleration Structure
                    uint mesh_offset = firstbithigh(triangle_group.y);
                    triangle_group.y &= ~(1 << mesh_offset);
                    mesh_id = triangle_group.x + mesh_offset;
                    NodeOffset = _MeshData[mesh_id].NodeOffset;
                    TriOffset = _MeshData[mesh_id].TriOffset;
                    if(triangle_group.y != 0) {
                        stack[stack_size++] = triangle_group;
                    }

                    if(current_group.y & 0xff000000) {
                        stack[stack_size++] = current_group;
                    }
                    tlas_stack_size = stack_size;

                    int root_index = (_MeshData[mesh_id].mesh_data_bvh_offsets & 0x7fffffff);

                    ray.direction = (mul(_MeshData[mesh_id].Transform, float4(ray.direction, 0))).xyz;
                    ray.origin = (mul(_MeshData[mesh_id].Transform, float4(ray.origin, 1))).xyz;
                    ray.direction_inv = rcp(ray.direction);

                    oct_inv4 = ray_get_octant_inv4(ray.direction);

                    current_group.x = (uint)root_index;
                    current_group.y = (uint)0x80000000;
                    break;
                }
                else {
                    uint triangle_index =  firstbithigh(triangle_group.y);
                    triangle_group.y &= ~(1 << triangle_index);
                    IntersectTriangle(mesh_id, triangle_group.x + triangle_index, ray, bestHit);//Intersect Mesh Triangles
                }
            }
            if((current_group.y & 0xff000000) == 0) {
                if(stack_size == 0) {//thread has finished traversing
                    current_group.y = 0;
                    break;
                }

                if(stack_size == tlas_stack_size) {
                    tlas_stack_size = -1;
                    ray = ray2;
                    oct_inv4 = ray_get_octant_inv4(ray.direction);
                }
                current_group = stack[--stack_size];
            }
        }
    }
}



float AreaOfTriangle(float3 pt1, float3 pt2, float3 pt3) {
    float a = distance(pt1, pt2);
    float b = distance(pt2, pt3);
    float c = distance(pt3, pt1);
    float s = (a + b + c) / 2.0f;
    return sqrt(s * (s-a) * (s-b) * (s-c));
}

float Luminance(float3 c)
{
    return 0.212671 * c.x + 0.715160 * c.y + 0.072169 * c.z;
}

float3 ToWorld(float3x3 X, float3 V)
{
    return normalize(mul(V, X));//V.x * X + V.y * Y + V.z * Z;
}

float3 ToLocal(float3x3 X, float3 V)
{
    return normalize(mul(X, V));
}

float GTR1(float NDotH, float a)
{
    if (a >= 1.0)
    return rcp(PI);
    float a2 = a * a;
    float t = 1.0 + (a2 - 1.0) * NDotH * NDotH;
    return (a2 - 1.0) / (PI * log(a2) * t);
}


float3 Schlick(float3 r0, float rad)
{
    float exponential = pow(1.0f - rad, 5.0f);
    return r0 + (1.0f - r0) * exponential;
}

float SchlickWeight(float u)
{
    float m = saturate(1.0f - u);
    float m2 = m * m;
    return m * m2 * m2;
}
float Schlick(float r0, float rads)
{
    return lerp(1.0f, SchlickWeight(rads), r0);
}


static float3 CalculateTint(float3 baseColor)
{
    // -- The color tint is never mentioned in the SIGGRAPH presentations as far as I recall but it was done in
    // --  the BRDF Explorer so I'll replicate that here.
    float luminance = dot(float3(0.3f, 0.6f, 1.0f), baseColor);
    return (luminance > 0.0f) ? (baseColor * (1.0f / luminance)) : 1;
}

static float3 EvaluateSheen(HitMat hitDat, const float3 wo, const float3 wm, const float3 wi)
{
    if(hitDat.sheen <= 0.0f) {
        return 0;
    }

    float dotHL = dot(wm, wi);
    float3 tint = CalculateTint(hitDat.surfaceColor);
    return hitDat.sheen * lerp(1.0f, tint, hitDat.sheenTint) * SchlickWeight(dotHL);
}



float CosTheta(const float3 w)
{
    return w.y;
}

float AbsCosTheta(const float3 w)
{
    return abs(CosTheta(w));
}
float Cos2Theta(const float3 w)
{
    return w.y * w.y;
}

float Sin2Theta(const float3 w)
{
    return max(0.0f, 1.0f - Cos2Theta(w));
}
float SinTheta(const float3 w)
{
    return sqrt(Sin2Theta(w));
}

float TanTheta(const float3 w)
{
    return SinTheta(w) / CosTheta(w);
}

float Tan2Theta(const float3 w)
{
    return Sin2Theta(w) / Cos2Theta(w);
}


float CosPhi(const float3 w)
{
    float sinTheta = SinTheta(w);
    return (sinTheta == 0) ? 1.0f : clamp(w.x / sinTheta, -1.0f, 1.0f);
}
float SinPhi(const float3 w)
{
    float sinTheta = SinTheta(w);
    return (sinTheta == 0) ? 1.0f : clamp(w.z / sinTheta, -1.0f, 1.0f);
}
float Cos2Phi(const float3 w)
{
    float cosPhi = CosPhi(w);
    return cosPhi * cosPhi;
}
float Sin2Phi(const float3 w)
{
    float sinPhi = SinPhi(w);
    return sinPhi * sinPhi;
}

//===================================================================================================================
float SeparableSmithGGXG1(const float3 w, float a)
{
    float a2 = a * a;
    float absDotNV = AbsCosTheta(w);

    return 2.0f / (1.0f + sqrt(a2 + (1 - a2) * absDotNV * absDotNV));
}

//===================================================================================================================
static float EvaluateDisneyClearcoat(float clearcoat, float alpha, const float3 wo, const float3 wm,
   const float3 wi, inout float fPdfW, inout float rPdfW)
{
    fPdfW = 0;
    rPdfW = 0;
    if(clearcoat <= 0.0f) {
        return 0.0f;
    }
    float absDotNH = AbsCosTheta(wm);
    float dotHL = dot(wm, wi);

    float gloss = lerp(.1,.001,alpha);
    float Dr = GTR1(absDotNH, gloss);
    float FH = SchlickWeight(dotHL);
    float Fr = lerp(0.04f, 1.0f, FH);
    float Gr = SeparableSmithGGXG1(wi, 0.25f) * SeparableSmithGGXG1(wo, 0.25f);
    fPdfW = Dr / (4.0f * abs(dot(wo, wm)));
    rPdfW = fPdfW;
    return 0.25f * clearcoat * Fr * Gr * Dr * PI;
}



float GgxAnisotropicD(const float3 wm, float ax, float ay)
{
    float dotHX2 = (wm.x*wm.x);
    float dotHY2 = (wm.z*wm.z);
    float cos2Theta = Cos2Theta(wm);
    float ax2 = (ax*ax);
    float ay2 = (ay*ay);

    return 1.0f / (PI * ax * ay * pow(dotHX2 / ax2 + dotHY2 / ay2 + cos2Theta,2));
}

//===================================================================================================================
float SeparableSmithGGXG1(const float3 w, const float3 wm, float ax, float ay)
{


    float absTanTheta = abs(TanTheta(w));
    if(!(absTanTheta < 0 || absTanTheta > 0 || absTanTheta == 0)) {
        return 0.0f;
    }

    float a = sqrt(Cos2Phi(w) * ax * ax + Sin2Phi(w) * ay * ay);
    float a2Tan2Theta = pow(a * absTanTheta,2);

    float lambda = 0.5f * (-1.0f + sqrt(1.0f + a2Tan2Theta));
    return 1.0f / (1.0f + lambda);
}

static void CalculateAnisotropicParams(float roughness, float anisotropic, inout float ax, inout float ay)
{
    float aspect = sqrt(1.0f - 0.9f * anisotropic);
    ax = max(0.0001f, (roughness*roughness) / aspect);
    ay = max(0.0001f, (roughness*roughness) * aspect);
}

void GgxVndfAnisotropicPdf(const float3 wi, const float3 wm, const float3 wo, float ax, float ay,
 inout float forwardPdfW, inout float reversePdfW)
{
    float D = GgxAnisotropicD(wm, ax, ay);

    float absDotNL = AbsCosTheta(wi);
    float absDotHL = abs(dot(wm, wi));
    float G1v = SeparableSmithGGXG1(wo, wm, ax, ay);
    forwardPdfW = G1v * absDotHL * D / absDotNL;

    float absDotNV = AbsCosTheta(wo);
    float absDotHV = abs(dot(wm, wo));
    float G1l = SeparableSmithGGXG1(wi, wm, ax, ay);
    reversePdfW = G1l * absDotHV * D / absDotNV;
}

float SchlickR0FromRelativeIOR(float eta)
{
    // https://seblagarde.wordpress.com/2013/04/29/memo-on-fresnel-equations/
    return pow(eta - 1.0f,2) / pow(eta + 1.0f,2);
}

float Dielectric(float cosThetaI, float ni, float nt)
{
    // Copied from PBRT. This function calculates the full Fresnel term for a dielectric material.
    // See Sebastion Legarde's link above for details.

    cosThetaI = clamp(cosThetaI, -1.0f, 1.0f);

    // Swap index of refraction if this is coming from inside the surface
    if(cosThetaI < 0.0f) {
        float temp = ni;
        ni = nt;
        nt = temp;

        cosThetaI = -cosThetaI;
    }

    float sinThetaI = sqrt(max(0.0f, 1.0f - cosThetaI * cosThetaI));
    float sinThetaT = ni / nt * sinThetaI;

    // Check for total internal reflection
    if(sinThetaT >= 1) {
        return 1;
    }

    float cosThetaT = sqrt(max(0.0f, 1.0f - sinThetaT * sinThetaT));

    float rParallel     = ((nt * cosThetaI) - (ni * cosThetaT)) / ((nt * cosThetaI) + (ni * cosThetaT));
    float rPerpendicuar = ((ni * cosThetaI) - (nt * cosThetaT)) / ((ni * cosThetaI) + (nt * cosThetaT));
    return (rParallel * rParallel + rPerpendicuar * rPerpendicuar) / 2;
}

static float3 DisneyFresnel(HitMat hitDat, const float3 wo, const float3 wm, const float3 wi)
{
    float dotHV = dot(wm, wo);

    float3 tint = CalculateTint(hitDat.surfaceColor);

    // -- See section 3.1 and 3.2 of the 2015 PBR presentation + the Disney BRDF explorer (which does their 2012 remapping
    // -- rather than the SchlickR0FromRelativeIOR seen here but they mentioned the switch in 3.2).
    float3 R0 = SchlickR0FromRelativeIOR(hitDat.relativeIOR) * lerp(1.0f, tint, hitDat.specularTint);
    R0 = lerp(R0, hitDat.surfaceColor, hitDat.metallic);

    float dielectricFresnel = Dielectric(dotHV, 1.0f, hitDat.ior);
    float3 metallicFresnel = Schlick(R0, dot(wi, wm));

    return lerp(dielectricFresnel, metallicFresnel, hitDat.metallic);
}

//===================================================================================================================
static float3 EvaluateDisneyBRDF(const HitMat hitDat, const float3 wo, const float3 wm,
   const float3 wi, inout float fPdf, inout float rPdf)
{
    fPdf = 0.0f;
    rPdf = 0.0f;

    float dotNL = CosTheta(wi);
    float dotNV = CosTheta(wo);
    if(dotNL <= 0.0f || dotNV <= 0.0f) {
        return 0;
    }

    float ax, ay;
    CalculateAnisotropicParams(hitDat.roughness, hitDat.anisotropic, ax, ay);

    float d = GgxAnisotropicD(wm, ax, ay);
    float gl = SeparableSmithGGXG1(wi, wm, ax, ay);
    float gv = SeparableSmithGGXG1(wo, wm, ax, ay);
    float3 f = DisneyFresnel(hitDat, wo, wm, wi);

    // fPdf = gv * max(dot(wi, wm), 0.0) * d * (rcp(4.0f * (dot(wi, wm)))) / dotNL;



    GgxVndfAnisotropicPdf(wi, wm, wo, ax, ay, fPdf, rPdf);
    fPdf *= (1.0f / (4 * abs(dot(wo, wm))));
    // rPdf *= (1.0f / (4 * abs(dot(wi, wm))));
    // _DebugTex[int2(pixel_index % screen_width, pixel_index / screen_width)] = float4(d * gl * gv * f/ (4.0f * dotNL * dotNV),1);
    return d * gl * gv * f / (4.0f * dotNL * dotNV); 
}


static float ThinTransmissionRoughness(float ior, float roughness)
{
    // -- Disney scales by (.65 * eta - .35) based on figure 15 of the 2015 PBR course notes. Based on their figure
    // -- the results match a geometrically thin solid fairly well.
    return saturate((0.65f * ior - 0.35f) * roughness);
}

//===================================================================================================================
static float3 EvaluateDisneySpecTransmission(const HitMat hitDat, const float3 wo, const float3 wm,
   const float3 wi, float ax, float ay, bool thin)
{
    float relativeIor = hitDat.ior;
    float n2 = relativeIor * relativeIor;

    float absDotNL = AbsCosTheta(wi);
    float absDotNV = AbsCosTheta(wo);
    float dotHL = dot(wm, wi);
    float dotHV = dot(wm, wo);
    float absDotHL = abs(dotHL);
    float absDotHV = abs(dotHV);

    float d = GgxAnisotropicD(wm, ax, ay);
    float gl = SeparableSmithGGXG1(wi, wm, ax, ay);
    float gv = SeparableSmithGGXG1(wo, wm, ax, ay);

    float f = Dielectric(dotHV, 1.0f, 1.0f / hitDat.ior);

    float3 color;
    if(thin)
    color = sqrt(hitDat.surfaceColor);
    else
    color = hitDat.surfaceColor;
    
    // Note that we are intentionally leaving out the 1/n2 spreading factor since for VCM we will be evaluating
    // particles with this. That means we'll need to model the air-[other medium] transmission if we ever place
    // the camera inside a non-air medium.
    float c = (absDotHL * absDotHV) / (absDotNL * absDotNV);
    float t = (n2 / pow(dotHL + relativeIor * dotHV,2));
    return color * c * t * (1.0f - f) * gl * gv * d;
}

static float EvaluateDisneyRetroDiffuse(const HitMat hitDat, const float3 wo, const float3 wm, const float3 wi)
{
    float dotNL = AbsCosTheta(wi);
    float dotNV = AbsCosTheta(wo);

    float roughness = hitDat.roughness * hitDat.roughness;

    float rr = 0.5f + 2.0f * dotNL * dotNL * roughness;
    float fl = SchlickWeight(dotNL);
    float fv = SchlickWeight(dotNV);
    
    return rr * (fl + fv + fl * fv * (rr - 1.0f));
}

static float EvaluateDisneyDiffuse(const HitMat hitDat, const float3 wo, const float3 wm,
 const float3 wi, bool thin)
{
    float dotNL = AbsCosTheta(wi);
    float dotNV = AbsCosTheta(wo);

    float fl = SchlickWeight(dotNL);
    float fv = SchlickWeight(dotNV);

    float hanrahanKrueger = 0.0f;

    if(thin && hitDat.flatness > 0.0f) {
        float roughness = hitDat.roughness * hitDat.roughness;

        float dotHL = dot(wm, wi);
        float fss90 = dotHL * dotHL * roughness;
        float fss = lerp(1.0f, fss90, fl) * lerp(1.0f, fss90, fv);

        float ss = 1.25f * (fss * (1.0f / (dotNL + dotNV) - 0.5f) + 0.5f);
        hanrahanKrueger = ss;
    }

    float lambert = 1.0f;
    float retro = EvaluateDisneyRetroDiffuse(hitDat, wo, wm, wi);
    float subsurfaceApprox = lerp(lambert, hanrahanKrueger, thin ? hitDat.flatness : 0.0f);

    return rcp(PI) * (retro + subsurfaceApprox * (1.0f - 0.5f * fl) * (1.0f - 0.5f * fv));
}


static void CalculateLobePdfs(const HitMat hitDat,
  inout float pSpecular, inout float pDiffuse, inout float pClearcoat, inout float pSpecTrans)
{
    float metallicBRDF   = hitDat.metallic;
    float specularBSDF   = (1.0f - hitDat.metallic) * hitDat.specTrans;
    float dielectricBRDF = (1.0f - hitDat.specTrans) * (1.0f - hitDat.metallic);

    float specularWeight     = metallicBRDF + hitDat.Specular;
    float transmissionWeight = specularBSDF;
    float diffuseWeight      = dielectricBRDF;
    float clearcoatWeight    = 1.0f * saturate(hitDat.clearcoat); 

    float norm = 1.0f / (specularWeight + transmissionWeight + diffuseWeight + clearcoatWeight);

    pSpecular  = specularWeight     * norm;
    pSpecTrans = transmissionWeight * norm;
    pDiffuse   = diffuseWeight      * norm;
    pClearcoat = clearcoatWeight    * norm;
}

float3 EvaluateDisney(HitMat hitDat, float3 V, float3 L, bool thin,
  inout float forwardPdf, inout float reversePdf, float3x3 TruTan)
{


    float3 wo = ToLocal(TruTan, V); // NDotL = L.z; NDotV = V.z; NDotH = H.z
    float3 wi = ToLocal(TruTan, L); // NDotL = L.z; NDotV = V.z; NDotH = H.z
// hitDat.surfaceColor *= PI;
float3 wm = normalize(wo + wi);

float dotNV = CosTheta(wo);
float dotNL = CosTheta(wi);

float3 reflectance = 0;
forwardPdf = 0.0f;
reversePdf = 0.0f;

float pBRDF, pDiffuse, pClearcoat, pSpecTrans;
CalculateLobePdfs(hitDat, pBRDF, pDiffuse, pClearcoat, pSpecTrans);

float3 baseColor = hitDat.surfaceColor;
float metallic = hitDat.metallic;
float specTrans = hitDat.specTrans;
float roughness = hitDat.roughness;

    // calculate all of the anisotropic params
    float ax, ay;
    CalculateAnisotropicParams(hitDat.roughness, hitDat.anisotropic, ax, ay);

    float diffuseWeight = (1.0f - metallic) * (1.0f - specTrans);
    float transWeight   = (1.0f - metallic) * specTrans;

    // -- Clearcoat
    bool upperHemisphere = dotNL > 0.0f && dotNV > 0.0f;
    if(upperHemisphere && hitDat.clearcoat > 0.0f) {

        float forwardClearcoatPdfW;
        float reverseClearcoatPdfW;

        float clearcoat = EvaluateDisneyClearcoat(hitDat.clearcoat, hitDat.clearcoatGloss, wo, wm, wi,
          forwardClearcoatPdfW, reverseClearcoatPdfW);
        reflectance += clearcoat;
        forwardPdf += pClearcoat * forwardClearcoatPdfW;
        reversePdf += pClearcoat * reverseClearcoatPdfW;
    }

    // -- Diffuse
    if(diffuseWeight > 0.0f) {
        float forwardDiffusePdfW = AbsCosTheta(wi);
        float reverseDiffusePdfW = AbsCosTheta(wo);
        float diffuse = EvaluateDisneyDiffuse(hitDat, wo, wm, wi, thin);

        float3 sheen = EvaluateSheen(hitDat, wo, wm, wi);

        reflectance += (diffuse * hitDat.surfaceColor + sheen);

        forwardPdf += pDiffuse * forwardDiffusePdfW;
        reversePdf += pDiffuse * reverseDiffusePdfW;
    }

    // -- transmission
    if(transWeight > 0.0f) {

        // Scale roughness based on IOR (Burley 2015, Figure 15).
        float rscaled = thin ? ThinTransmissionRoughness(hitDat.ior, hitDat.roughness) : hitDat.roughness;
        float tax, tay;
        CalculateAnisotropicParams(rscaled, hitDat.anisotropic, tax, tay);

        float3 transmission = EvaluateDisneySpecTransmission(hitDat, wo, wm, wi, tax, tay, thin);
        reflectance += transWeight * transmission;

        float forwardTransmissivePdfW;
        float reverseTransmissivePdfW;
        GgxVndfAnisotropicPdf(wi, wm, wo, tax, tay, forwardTransmissivePdfW, reverseTransmissivePdfW);

        float dotLH = dot(wm, wi);
        float dotVH = dot(wm, wo);
        forwardPdf += pSpecTrans * forwardTransmissivePdfW / (pow(dotLH + hitDat.relativeIOR * dotVH,2));
        reversePdf += pSpecTrans * reverseTransmissivePdfW / (pow(dotVH + hitDat.relativeIOR * dotLH,2));
    }

    // -- specular
    if(upperHemisphere) {
        float forwardMetallicPdfW;
        float reverseMetallicPdfW;
        // hitDat.surfaceColor *= PI;
        float3 specular = EvaluateDisneyBRDF(hitDat, wo, wm, wi, forwardMetallicPdfW, reverseMetallicPdfW);
        
        reflectance +=  specular;// * (abs(dot(wi, wm)));
        forwardPdf += pBRDF * forwardMetallicPdfW / (4 * abs(dot(wo, wm)));
        reversePdf += pBRDF * reverseMetallicPdfW / (4 * abs(dot(wi, wm)));
    }

    reflectance = reflectance * abs(dotNL);
        // _DebugTex[int2(pixel_index % screen_width, pixel_index / screen_width)] = float4(reflectance,1);

        return reflectance;
    }

    float3 SampleGgxVndfAnisotropic(const float3 wo, float ax, float ay, float u1, float u2)
    {
    // -- Stretch the view vector so we are sampling as though roughness==1
    float3 v = normalize(float3(wo.x * ax, wo.y, wo.z * ay));

    // -- Build an orthonormal basis with v, t1, and t2
    float3 t1 = (v.y < 0.9999f) ? normalize(cross(v, float3(0,1,0))) : float3(1,0,0);
    float3 t2 = cross(t1, v);

    // -- Choose a point on a disk with each half of the disk weighted proportionally to its projection onto direction v
    float a = 1.0f / (1.0f + v.y);
    float r = sqrt(u1);
    float phi = (u2 < a) ? (u2 / a) * PI : PI + (u2 - a) / (1.0f - a) * PI;
    float p1 = r * cos(phi);
    float p2 = r * sin(phi) * ((u2 < a) ? 1.0f : v.y);

    // -- Calculate the normal in this stretched tangent space
    float3 n = p1 * t1 + p2 * t2 + sqrt(max(0.0f, 1.0f - p1 * p1 - p2 * p2)) * v;

    // -- unstretch and normalize the normal
    return normalize(float3(ax * n.x, n.y, ay * n.z));
}

struct BsdfSample {
    float forwardPdfW;
    float reversePdfW;
    float3 reflectance;
    float3 wi;
    int InsideMedium;
    float phaseFunction;
    float3 extinction;
};

BsdfSample initbsdf() {
    BsdfSample result;
    result.forwardPdfW = 0;
    result.reversePdfW = 0;
    result.reflectance = 0;
    result.wi = 0;
    result.InsideMedium = 0;
    result.phaseFunction = 0;
    result.extinction = 0;
    return result;
}

bool Transmit(float3 wm, float3 wi, float n, inout float3 wo)
{
    float c = dot(wi, wm);
    if(c < 0.0f) {
        c = -c;
        wm = -wm;
    }

    float root = 1.0f - n * n * (1.0f - c * c);
    if(root <= 0)
    return false;

    wo = (n * c - sqrt(root)) * wm - n * wi;
    return true;
}

static float3 CalculateExtinction(float3 apparantColor, float scatterDistance)
{
    float3 a = apparantColor;
    float3 s = 1.9f - a + 3.5f * (a - 0.8f) * (a - 0.8f);

    return 1.0f / (s * scatterDistance);
}

#define eIsotropic 0.5f
#define eVacuum 0.1f

static bool SampleDisneySpecTransmission(const HitMat hitDat, float3 v, bool thin, inout BsdfSample sample, float3x3 TruTan, out float refracted)
{
    float3 wo = ToLocal(TruTan, v); // NDotL = L.z; NDotV = V.z; NDotH = H.z
    refracted = false;
    if(CosTheta(wo) == 0.0) {
        sample.forwardPdfW = 0.0f;
        sample.reversePdfW = 0.0f;
        sample.reflectance = 0;
        sample.wi = 0;
        return false;
    }

    // -- Scale roughness based on IOR
    float rscaled = thin ? ThinTransmissionRoughness(hitDat.ior, hitDat.roughness) : hitDat.roughness;

    float tax, tay;
    CalculateAnisotropicParams(rscaled, hitDat.anisotropic, tax, tay);
    
    // -- Sample visible distribution of normals
    float r0 = random(23).x;
    float r1 = random(23).y;
    float3 wm = SampleGgxVndfAnisotropic(wo, tax, tay, r0, r1);

    float dotVH = dot(wo, wm);
    if(wm.y < 0.0f) {
        dotVH = -dotVH;
    }

    float ni = wo.y > 0.0f ? 1.0f : hitDat.ior;
    float nt = wo.y > 0.0f ? hitDat.ior : 1.0f;
    float relativeIOR = hitDat.relativeIOR;// ni / nt;

    // -- Disney uses the full dielectric Fresnel equation for transmission. We also importance sample F
    // -- to switch between refraction and reflection at glancing angles.
    float F = Dielectric(dotVH, 1.0f, hitDat.ior);
    
    // -- Since we're sampling the distribution of visible normals the pdf cancels out with a number of other terms.
    // -- We are left with the weight G2(wi, wo, wm) / G1(wi, wm) and since Disney uses a separable masking function
    // -- we get G1(wi, wm) * G1(wo, wm) / G1(wi, wm) = G1(wo, wm) as our weight.
    float G1v = SeparableSmithGGXG1(wo, wm, tax, tay);

    float pdf;
    refracted = false;

    float3 wi;
    if(random(24).x <= F) {
        wi = normalize(reflect(-wo, wm));

        sample.reflectance = G1v * hitDat.surfaceColor;

        float jacobian = (4 * abs(dot(wo, wm)));
        pdf = F / jacobian;
    }
    else {
        if(thin) {
            // -- When the surface is thin so it refracts into and then out of the surface during this shading event.
            // -- So the ray is just reflected then flipped and we use the sqrt of the surface color.
            wi = reflect(-wo, wm);
            wi.y = -wi.y;
            sample.reflectance = G1v * sqrt(hitDat.surfaceColor);

            // -- Since this is a thin surface we are not ending up inside of a volume so we treat this as a scatter event.
            sample.InsideMedium = 0;
        }
        else {
            if(Transmit(wm, wo, relativeIOR, wi)) {
                sample.InsideMedium = 1;
                refracted = true;
                sample.phaseFunction = dotVH > 0.0f ? eIsotropic : eVacuum;
                sample.extinction = CalculateExtinction(hitDat.transmittanceColor, hitDat.scatterDistance);
            }
            else {
                sample.InsideMedium = 0;
                wi = reflect(-wo, wm);
            }

            sample.reflectance = G1v * hitDat.surfaceColor;
        }

        wi = normalize(wi);
        
        float dotLH = abs(dot(wi, wm));
        float jacobian = dotLH / (pow(dotLH + hitDat.relativeIOR * dotVH,2));
        pdf = (1.0f - F) / jacobian;
    }

    if(CosTheta(wi) == 0.0f) {
        sample.forwardPdfW = 0.0f;
        sample.reversePdfW = 0.0f;
        sample.reflectance = 0;
        sample.wi = 0;
        return false;
    }

    // -- calculate VNDF pdf terms and apply Jacobian and Fresnel sampling adjustments
    GgxVndfAnisotropicPdf(wi, wm, wo, tax, tay, sample.forwardPdfW, sample.reversePdfW);
    sample.forwardPdfW *= pdf;
    sample.reversePdfW *= pdf;
    // -- convert wi back to world space
    sample.wi = normalize(ToWorld(TruTan, wi));

    return true;
}

float3 CosineSampleHemisphere2(float r1, float r2)
{
    float3 dir;
    float r = sqrt(r1);
    float phi = (2 * PI) * r2;
    dir.x = r * cos(phi);
    dir.z = r * sin(phi);
    dir.y = sqrt(max(0.0, 1.0 - dir.x * dir.x - dir.z * dir.z));
    return dir;
}

static bool SampleDisneyDiffuse(const HitMat hitDat, float3 v, bool thin,
    inout BsdfSample sample, float3x3 TruTan, inout bool refracted)
{
    float3 wo = ToLocal(TruTan, v); // NDotL = L.z; NDotV = V.z; NDotH = H.z

    float sig = sign(CosTheta(wo));

    // -- Sample cosine lobe
    float r0 = random(43).x;
    float r1 = random(43).y;
    float3 wi = CosineSampleHemisphere2(r0, r1);
    float3 wm = normalize(wi + wo);

    float dotNL = CosTheta(wi);
    if(dotNL == 0.0f) {
        sample.forwardPdfW = 0.0f;
        sample.reversePdfW = 0.0f;
        sample.reflectance = 0;
        sample.wi = 0;
        return false;
    }

    float dotNV = CosTheta(wo);

    float pdf;

    sample.InsideMedium = 0;

    float3 color = hitDat.surfaceColor;

    float p = random(64).x;
    if(p <= hitDat.diffTrans) {
        wi = -wi;
        pdf = hitDat.diffTrans;
        refracted = true;

        if(thin)
        color = sqrt(color);
        else {
            sample.InsideMedium = 1;

            sample.phaseFunction = eIsotropic;
            sample.extinction = CalculateExtinction(hitDat.transmittanceColor, hitDat.scatterDistance);
        }
    }
    else {
        pdf = (1.0f - hitDat.diffTrans);
    }

    float3 sheen = EvaluateSheen(hitDat, wo, wm, wi);

    float diffuse = EvaluateDisneyDiffuse(hitDat, wo, wm, wi, thin);
    sample.reflectance = (sheen + color * (diffuse / pdf));
    sample.wi = normalize(ToWorld(TruTan, wi));
    sample.forwardPdfW = abs(dotNL) * pdf;
    sample.reversePdfW = abs(dotNV) * pdf;
    return true;
}

static bool SampleDisneyBRDF(const HitMat hitDat, float3 v, inout BsdfSample sample, float3x3 TruTan)
{
    float3 wo = ToLocal(TruTan, v); // NDotL = L.z; NDotV = V.z; NDotH = H.z

        // -- Calculate Anisotropic params
        float ax, ay;
        CalculateAnisotropicParams(hitDat.roughness, hitDat.anisotropic, ax, ay);

        // -- Sample visible distribution of normals
        float r0 = random(203).x;
        float r1 = random(203).y;
        float3 wm = SampleGgxVndfAnisotropic(wo, ay, ax, r1, r0);

        // -- Reflect over wm
        float3 wi = normalize(reflect(-wo, wm));
        if(CosTheta(wi) <= 0.0f) {
            sample.forwardPdfW = 0.0f;
            sample.reversePdfW = 0.0f;
            sample.reflectance = 0;
            sample.wi = 0;
            return false;
        }

        // -- Fresnel term for this lobe is complicated since we're blending with both the metallic and the specularTint
        // -- parameters plus we must take the IOR into account for dielectrics
        float3 F = DisneyFresnel(hitDat, wo, wm, wi);

        // -- Since we're sampling the distribution of visible normals the pdf cancels out with a number of other terms.
        // -- We are left with the weight G2(wi, wo, wm) / G1(wi, wm) and since Disney uses a separable masking function
        // -- we get G1(wi, wm) * G1(wo, wm) / G1(wi, wm) = G1(wo, wm) as our weight.
        float G1v = SeparableSmithGGXG1(wo, wm, ay, ax);
        float3 specular = G1v * F;

        sample.InsideMedium = 0;
        sample.reflectance = specular;
        sample.wi = normalize(ToWorld(TruTan, wi));
        GgxVndfAnisotropicPdf(wi, wm, wo, ay, ax, sample.forwardPdfW, sample.reversePdfW);

        sample.forwardPdfW *= (1.0f / (4 * abs(dot(wo, wm))));
        sample.reversePdfW *= (1.0f / (4 * abs(dot(wi, wm))));

        return true;
    }

    static bool SampleDisneyClearcoat(const HitMat hitDat, const float3 v,
      inout BsdfSample sample, float3x3 TruTan)
    {
        float gloss = lerp(0.1f, 0.001f, hitDat.clearcoatGloss);
    float3 wo = ToLocal(TruTan, v); // NDotL = L.z; NDotV = V.z; NDotH = H.z

    float a = gloss;
    float a2 = a * a;

    float r0 = random(102).x;
    float r1 = random(102).y;
    float cosTheta = sqrt(max(1e-6, (1.0f - pow(a2, 1.0f - r0)) / (1.0f - a2)));
    float sinTheta = sqrt(max(1e-6, 1.0f - cosTheta * cosTheta));
    float phi = 2 * PI * r1;

    float3 wm = float3(sinTheta * cos(phi), cosTheta, sinTheta * sin(phi));
    if(dot(wm, wo) < 0.0f) {
        wm = -wm;
    }

    float3 wi = reflect(-wo, wm);
    // if(dot(wi, wo) < 0.0f) {
    //     return false;
    // }

    float clearcoatWeight = hitDat.clearcoat;
    float clearcoatGloss = hitDat.clearcoatGloss;

    float dotNH = CosTheta(wm);
    float dotLH = dot(wm, wi);

    float d = GTR1(abs(dotNH), lerp(0.1f, 0.001f, clearcoatGloss));
    float FH = SchlickWeight(dotLH);
    float f = lerp(0.04f, 1.0f, FH);//Schlick(0.04f, (dotLH));
    float g = SeparableSmithGGXG1(wi, 0.25f) * SeparableSmithGGXG1(wo, 0.25f);

    float fPdf = d / (4.0f * dot(wo, wm));

    sample.reflectance = (0.25f * clearcoatWeight * g * f * d) / fPdf;
    sample.wi = normalize(ToWorld(TruTan, wi));
    sample.forwardPdfW = fPdf;
    sample.reversePdfW = d / (4.0f * dot(wi, wm));

    return true;
}

void GetLobeProbabilities(out float diffuseWt, out float specReflectWt, out float specRefractWt, out float clearcoatWt, HitMat hitDat)
{
    diffuseWt = Luminance(hitDat.surfaceColor) * (1.0 - hitDat.metallic) * (1.0 - hitDat.specTrans);
    specReflectWt = hitDat.metallic;
    specRefractWt = (1.0f - hitDat.metallic) * hitDat.specTrans;
    clearcoatWt = hitDat.clearcoat * (1.0 - hitDat.metallic);
    float totalWt = diffuseWt + specReflectWt + specRefractWt + clearcoatWt;

    diffuseWt /= totalWt;
    specReflectWt /= totalWt;
    specRefractWt /= totalWt;
    clearcoatWt /= totalWt;
}


bool2 SampleDisney(HitMat hitDat, float3 v, bool thin, inout BsdfSample sample, float3x3 TruTanMat, out int Case)
{
    float pSpecular;
    float pDiffuse;
    float pClearcoat;
    float pTransmission;
    hitDat.surfaceColor *= PI;
    CalculateLobePdfs(hitDat, pSpecular, pDiffuse, pClearcoat, pTransmission);
        // GetLobeProbabilities(pDiffuse, pSpecular, pTransmission, pClearcoat, hitDat);

        bool success = false;

        float pLobe = 0.0f;
        bool refracted = false;
        float p = random(194).x;
        if(p <= pSpecular) {
            hitDat.surfaceColor /= PI;
            success = SampleDisneyBRDF(hitDat, v, sample, TruTanMat);
            pLobe = pSpecular;
            Case = 0;
        }
        else if(p > pSpecular && p <= (pSpecular + pClearcoat)) {
            success = SampleDisneyClearcoat(hitDat, v, sample, TruTanMat);
            pLobe = pClearcoat;
            Case = 1;
        }
        else if(p > pSpecular + pClearcoat && p <= (pSpecular + pClearcoat + pDiffuse)) {
            success = SampleDisneyDiffuse(hitDat, v, thin, sample, TruTanMat, refracted);
            pLobe = pDiffuse;
            Case = 2;
        }
        else if(pTransmission >= 0.0f) {
            hitDat.surfaceColor /= PI;
            success = SampleDisneySpecTransmission(hitDat, v, thin, sample, TruTanMat, refracted);
            pLobe = pTransmission;
            Case = 3;
        }
        else {
            // -- Make sure we notice if this is occurring.
            sample.reflectance = float3(1000000.0f, 0.0f, 0.0f);
            sample.forwardPdfW = 0.000000001f;
            sample.reversePdfW = 0.000000001f;
            Case = 4;
        }

        if(pLobe > 0.0f) {
            sample.reflectance = sample.reflectance * (1.0f / pLobe);
            sample.forwardPdfW *= pLobe;
            sample.reversePdfW *= pLobe;
        }

        return bool2(success, refracted);
    }

    static float3 ReconstructDisneyBRDF(const HitMat hitDat, const float3 wo, float3 wm,
       const float3 wi, inout float fPdf, inout float rPdf, inout bool Success)
    {
        fPdf = 0.0f;
        rPdf = 0.0f;

        float dotNL = CosTheta(wi);
        float dotNV = CosTheta(wo);
        if(CosTheta(wi) <= 0.0f) {
            Success = false;
            return 0;
        }

        float ax, ay;
        CalculateAnisotropicParams(hitDat.roughness, hitDat.anisotropic, ax, ay);

        //     float r0 = random(203).x;
        // float r1 = random(203).y;
        // wm = SampleGgxVndfAnisotropic(wo, ay, ax, r1, r0);

        float3 f = DisneyFresnel(hitDat, wo, wm, wi);

        GgxVndfAnisotropicPdf(wi, wm, wo, ay, ax, fPdf, rPdf);
        fPdf *= 1.0f / (4 * abs(dot(wo, wm)));
        rPdf *= (1.0f / (4 * abs(dot(wi, wm))));

        float G1v = SeparableSmithGGXG1(wo, wm, ay, ax);
        float3 specular = G1v * f;
        Success = (fPdf > 0.00025f);
    // _DebugTex[int2(pixel_index % screen_width, pixel_index / screen_width)] = float4(d * gl * gv * f/ (4.0f * dotNL * dotNV),1);
    return specular;//d * gl * gv * f / (4.0f * dotNL * dotNV); 
}
static float ReconstructDisneyClearcoat(float clearcoat, float alpha, const float3 wo, const float3 wm,
   const float3 wi, inout float fPdfW, inout float rPdfW, out bool success)
{
    fPdfW = 0;
    rPdfW = 0;
    if(clearcoat <= 0.0f) {
        success = false;
        return 0.0f;
    }
    float absDotNH = AbsCosTheta(wm);
    float dotHL = dot(wm, wi);

    float gloss = lerp(.1,.001,alpha);
    float Dr = GTR1(absDotNH, gloss);
    float FH = SchlickWeight(dotHL);
    float Fr = lerp(0.04f, 1.0f, FH);
    float Gr = SeparableSmithGGXG1(wi, 0.25f) * SeparableSmithGGXG1(wo, 0.25f);
    fPdfW = Dr / (4.0f * abs(dot(wo, wm)));
    rPdfW = fPdfW;
    success = fPdfW > 0.1f;
    return 0.25f * clearcoat * Fr * Gr * Dr;
}
float3 EvaluateDisney(HitMat hitDat, float3 V, float3 L, bool thin,
  inout float forwardPdf, float3x3 TruTan, int Case, float3 Norm, inout bool Success)
{

    float reversePdf;
    float3 wo = ToLocal(TruTan, V); // NDotL = L.z; NDotV = V.z; NDotH = H.z
    float3 wi = ToLocal(TruTan, L); // NDotL = L.z; NDotV = V.z; NDotH = H.z
    hitDat.surfaceColor *= PI;
    float3 wm =normalize(wo + wi);

    float dotNV = CosTheta(wo);
    float dotNL = CosTheta(wi);

    float3 reflectance = 0;
    forwardPdf = 0.0f;
    reversePdf = 0.0f;

    float pBRDF, pDiffuse, pClearcoat, pSpecTrans;
    CalculateLobePdfs(hitDat, pBRDF, pDiffuse, pClearcoat, pSpecTrans);

    float3 baseColor = hitDat.surfaceColor;
    float metallic = hitDat.metallic;
    float specTrans = hitDat.specTrans;
    float roughness = hitDat.roughness;

    // calculate all of the anisotropic params
    float ax, ay;
    CalculateAnisotropicParams(hitDat.roughness, hitDat.anisotropic, ax, ay);

    float diffuseWeight = (1.0f - metallic) * (1.0f - specTrans);
    float transWeight   = (1.0f - metallic) * specTrans;


    Success = true;
    switch(Case) {
        case 0:
        float forwardMetallicPdfW;
        float reverseMetallicPdfW;
        hitDat.surfaceColor /= PI;
        float3 specular = ReconstructDisneyBRDF(hitDat, wo, wm, wi, forwardMetallicPdfW, reverseMetallicPdfW, Success);

            reflectance =  rcp(pBRDF) * specular;// / forwardMetallicPdfW * abs(dotNL);
            forwardPdf = pBRDF * forwardMetallicPdfW;// / (4 * abs(dot(wo, wm)));
            break;
            case 2:
            float forwardDiffusePdfW = AbsCosTheta(wi);
            float reverseDiffusePdfW = AbsCosTheta(wo);
            float diffuse = EvaluateDisneyDiffuse(hitDat, wo, wm, wi, thin);

            float3 sheen = EvaluateSheen(hitDat, wo, wm, wi);

            reflectance = rcp(pDiffuse) * (diffuse * hitDat.surfaceColor + sheen);

            forwardPdf = pDiffuse * forwardDiffusePdfW;
            Success = forwardPdf > 0;
            break;
            case 1:    
            float forwardClearcoatPdfW;
            float reverseClearcoatPdfW;

            float clearcoat = ReconstructDisneyClearcoat(hitDat.clearcoat, hitDat.clearcoatGloss, wo, wm, wi,
              forwardClearcoatPdfW, reverseClearcoatPdfW, Success);
            reflectance = rcp(pClearcoat) * clearcoat / (forwardClearcoatPdfW);
            forwardPdf = pClearcoat * forwardClearcoatPdfW;
            // Success = forwardPdf > 0;
            break;
            case 3:
            reflectance = 1;
            forwardPdf = 1;
            Success = true;
            break;
            default:
            reflectance = 0;
            forwardPdf = 0;
            break;

        }

    reflectance = reflectance;// * abs(dotNL);
        // _DebugTex[int2(pixel_index % screen_width, pixel_index / screen_width)] = float4(reflectance,1);

        return reflectance;
    }
    static const float sigma_s = 0.09, sigma_a = 0.06, sigma_t = sigma_s+sigma_a;

    inline float3 sampleHG(float g, float e1, float e2) {
    //double s=2.0*e1-1.0, f = (1.0-g*g)/(1.0+g*s), cost = 0.5*(1.0/g)*(1.0+g*g-f*f), sint = sqrt(1.0-cost*cost);
    float s = 1.0-2.0*e1, cost = (s + 2.0*g*g*g * (-1.0 + e1) * e1 + g*g*s + 2.0*g*(1.0 - e1+e1*e1))/((1.0+g*s)*(1.0+g*s)), sint = sqrt(1.0-cost*cost);
    return float3(cos(2.0 * PI * e2) * sint, sin(2.0 * PI * e2) * sint, cost);
}

inline float sampleSegment(float epsilon, float sigma, float smax) {
    return -log(1.0 - epsilon * (1.0 - exp(-sigma * smax))) / sigma;
}


inline void generateOrthoBasis(inout float3 u, inout float3 v, float3 w) {
    float3 coVec = w;
    if (abs(w.x) <= abs(w.y)) {
        if (abs(w.x) <= abs(w.z)) coVec = float3(0,-w.z,w.y);
        else coVec = float3(-w.y,w.x,0);
        }else if (abs(w.y) <= abs(w.z)) {coVec = float3(-w.z,0,w.x);
            }else coVec = float3(-w.y,w.x,0);
            coVec *= 1/sqrt(dot(coVec, coVec));
            u = w%coVec,
            v = w%u;
        }

        inline float scatter(const Ray r, inout float3 dir, inout float dist, float tin, float tout, float3x3 TanNorm) {
            dist = sampleSegment(random(23).x, sigma_s, tout - tin);
    //Vec dir = sampleSphere(XORShift::frand(), XORShift::frand()); //Sample a direction ~ uniform phase function
    dir = sampleHG(-0.5,random(95).x, random(95).y); //Sample a direction ~ Henyey-Greenstein's phase function
    float3 u, v = 0;
    // GetTangentSpace
    // generateOrthoBasis(u, v, r.direction);
    dir = ToWorld(TanNorm, dir);
    return (1.0 - exp(-sigma_s * (tout - tin)));
}

inline bool EvaluateBsdf(const HitMat hitDat, float3 DirectionIn, float3 DirectionOut, float3 Normal, out float PDF) {
    float throwaway = 0;
    float3 bsdf_value = 0;
    bool validbsdf = false;
    float cos_theta_hit = dot(DirectionOut, Normal);
    [branch]switch(hitDat.MatType) {//Switch between different materials
        default:
        validbsdf = evaldiffuse(DirectionOut, cos_theta_hit, bsdf_value, PDF);
        break;
        case 1:
            bsdf_value = EvaluateDisney(hitDat, -DirectionIn, DirectionOut, hitDat.Thin == 1, PDF, throwaway, GetTangentSpace2(Normal));// DisneyEval(mat, -PrevDirection, norm, to_light, bsdf_pdf, hitDat);
            validbsdf = PDF > 0;
            break;
            case 3:
            validbsdf = false;
            break;
            case 4:
            validbsdf = true;
            break;
            case 5:
            validbsdf = evaldiffuse(DirectionOut, cos_theta_hit, bsdf_value, PDF);
            break;
            case 6:
            validbsdf = evaldiffuse(DirectionOut, cos_theta_hit, bsdf_value, PDF);
            break;
            case 7:
            validbsdf = evalplastic(hitDat, mul(GetTangentSpace(Normal), DirectionOut), cos_theta_hit, bsdf_value, PDF,  mul(GetTangentSpace(Normal), -DirectionIn));
            break;

        }
        return validbsdf;
    } 
    inline bool EvaluateBsdf(const HitMat hitDat, float3 DirectionIn, float3 DirectionOut, float3 Normal, out float PDF, out float3 bsdf_value) {
        float throwaway = 0;
        bool validbsdf = false;
        float cos_theta_hit = dot(DirectionOut, Normal);
    [branch]switch(hitDat.MatType) {//Switch between different materials
        default:
        validbsdf = evaldiffuse(DirectionOut, cos_theta_hit, bsdf_value, PDF);
        break;
        case 1:
            bsdf_value = EvaluateDisney(hitDat, -DirectionIn, DirectionOut, hitDat.Thin == 1, PDF, throwaway, GetTangentSpace2(Normal));// DisneyEval(mat, -PrevDirection, norm, to_light, bsdf_pdf, hitDat);
            validbsdf = PDF > 0;
            break;
            case 3:
            validbsdf = false;
            break;
            case 4:
            validbsdf = true;
            break;
            case 5:
            validbsdf = evaldiffuse(DirectionOut, cos_theta_hit, bsdf_value, PDF);
            break;
            case 6:
            validbsdf = evaldiffuse(DirectionOut, cos_theta_hit, bsdf_value, PDF);
            break;
            case 7:
            validbsdf = evalplastic(hitDat, mul(GetTangentSpace(Normal), DirectionOut), cos_theta_hit, bsdf_value, PDF,  mul(GetTangentSpace(Normal), -DirectionIn));
            break;

        }
        return validbsdf;
    } 
    inline bool ReconstructBsdf(const HitMat hitDat, float3 DirectionIn, float3 DirectionOut, float3 Normal, out float PDF, out float3 bsdf_value, int Case, const float3x3 TangentSpaceNorm) {
        float throwaway = 0;
        bool validbsdf = false;
        float cos_theta_hit = dot(DirectionOut, Normal);
        bsdf_value = 0;
        PDF = 0;
    [branch]switch(hitDat.MatType) {//Switch between different materials
        default:
        validbsdf = evaldiffuse(DirectionOut, cos_theta_hit, bsdf_value, PDF);
        bsdf_value = hitDat.surfaceColor;
        break;
        case 1:
        bsdf_value = EvaluateDisney(hitDat, -DirectionIn, DirectionOut, false, PDF, TangentSpaceNorm, Case, Normal, validbsdf);
        break;
        case 3:
        validbsdf = false;
        break;
        case 4:
        validbsdf = true;
        break;
        case 5:
        validbsdf = evaldiffuse(DirectionOut, cos_theta_hit, bsdf_value, PDF);
        break;
        case 6:
        validbsdf = evaldiffuse(DirectionOut, cos_theta_hit, bsdf_value, PDF);
        break;
        case 7:
        validbsdf = evalplastic(hitDat, mul(GetTangentSpace(Normal), DirectionOut), cos_theta_hit, bsdf_value, PDF,  mul(GetTangentSpace(Normal), -DirectionIn));
        break;

    }
    return validbsdf;
} 





Texture3D<float4> CloudTex;
SamplerState sampler_trilinear_repeat;

float inverseLerp(float minValue, float maxValue, float v) {
  return (v - minValue) / (maxValue - minValue);
}


float4 SamplePerlinWorleyNoise(float3 pos) {
  float3 coord = pos.xyz * float3(1.0 / 32.0, 1.0 / 32.0, 1.0 / 64.0) * 0.1f;
  float4 s = CloudTex.SampleLevel(sampler_trilinear_repeat, coord, 0);

  return s;
}

float remap(float v, float inMin, float inMax, float outMin, float outMax) {
  float t = inverseLerp(inMin, inMax, v);
  return lerp(outMin, outMax, t);
}

float circularOut(float t) {
  return sqrt((2.0 - t) * t);
}

float HenyeyGreenstein(float g, float mu) {
  float gg = g * g;
  return (1.0 / (4.0 * PI))  * ((1.0 - gg) / pow(1.0 + gg - 2.0 * g * mu, 1.5));
}
float linearstep(float minValue, float maxValue, float v) {
  return clamp((v - minValue) / (maxValue - minValue), 0.0, 1.0);
}

float DualHenyeyGreenstein(float g, float costh) {
  return lerp(HenyeyGreenstein(-g, costh), HenyeyGreenstein(g, costh), 0.7f);
}

float PhaseFunction(float g, float costh) {
  return DualHenyeyGreenstein(g, costh);
}

float3 MultipleOctaveScattering(float density, float mu) {
  float attenuation = 0.2;
  float contribution = 0.2;
  float phaseAttenuation = 0.5;

  float a = 1.0;
  float b = 1.0;
  float c = 1.0;
  float g = 0.85;
  const float scatteringOctaves = 4.0;
  
  float3 luminance = 0.0;

  for (float i = 0.0; i < scatteringOctaves; i++) {
    float phaseFunction = PhaseFunction(0.3 * c, mu);
    float3 beers = exp(-density * float3(0.8,0.8,1) * a);

    luminance += b * phaseFunction * beers;

    a *= attenuation;
    b *= contribution;
    c *= (1.0 - phaseAttenuation);
}
return luminance;
}

float GetDensity(float3 pos, float3 campos) {
    float3 prevPos = pos;
    float4 perlinworley = SamplePerlinWorleyNoise(pos * 10);
    float cloud = circularOut(linearstep(0.0, -25.0, -length(prevPos - 20.0f) / 2.0f)) * 0.85;
    pos = pos + float3(-2.0, 0.0, 1) * 0.01 * frames_accumulated;
    cloud =saturate(remap(cloud, 0.8f * perlinworley.x, 1.0, 0.0, 1.0));

    if(cloud > 0) {
        float distToSample = length(prevPos - campos );
        float t_detailDropout = smoothstep(1000.0, 800.0, distToSample);
        if (t_detailDropout > 0.0) {
            pos += float3(4.0, 3.0, 2.0) * 0.1 * frames_accumulated;

            float detailSize = 1.8;
            float detailStrength = 0.4f * t_detailDropout;
            float detail = SamplePerlinWorleyNoise(detailSize * pos).y;
            cloud = saturate(remap(cloud, detailStrength * detail, 1.0, 0.0, 1.0));
        }
    }
    return cloud;
}

float3 Clouds(float3 SunDir, Ray ray, out float3 direct) {
    float3 campos = ray.origin;
    float mu = dot(ray.direction, SunDir);
    int MaxSteps = 1000;
    int CurSteps = 0;
    while(MaxSteps > CurSteps && length(ray.origin - 20.0f) > 40) {
        ray.origin += (length(ray.origin - 20.0f) - 20) * ray.direction;
        CurSteps++;
    }
    CurSteps = 0;
    float Distance = 0;
    float3 transmittance = 1;
    while(MaxSteps > CurSteps && length(ray.origin - 20.0f) < 40) {
        CurSteps++;
    // Distance += 0.1f * GetDensity(ray.origin, campos);
    int secondarysteps = 0;
    float3 secondaryorigin = ray.origin;
    float tolightdensity = 0;
    while(MaxSteps > secondarysteps && length(secondaryorigin - 20.0f) < 40) {
        secondaryorigin += SunDir * 0.5;
        tolightdensity += 0.5 * GetDensity(secondaryorigin, campos);
        secondarysteps++;
    }
    float3 beerslaw = MultipleOctaveScattering(tolightdensity, mu);
    float3 powder = 1.0f - exp(-tolightdensity * 2 * float3(0.8,0.8,1));
    float3 lum = 12.0f * beerslaw * lerp(2 * powder, 1, remap(mu, -1, 1, 0, 1));


    float3 transmittance2 = exp(-0.5 * GetDensity(ray.origin, campos)* float3(0.8,0.8,1));
    float3 integscatter = (lum - lum * transmittance2);


    direct += transmittance * integscatter;
    transmittance *= transmittance2;
    ray.origin += ray.direction * 0.5f;
}
return transmittance;

}


void calcFinalColor(inout Ray ray, inout ColData Color,  HitMat hitDat, RayHit hit, uint2 Uv, float2 NormalUV, bool HitVoxel, bool IsEmissiveTex, RayData RayDat, MaterialData mat, int prevIndex, bool HitHeightmap) {//main function
// bool cb = (int(Uv.x)/64 + int(Uv.y)/64)%2==0;
float3 pos = ray.direction * hit.t + ray.origin;
float3 PrevDirection = ray.direction;
float3 PrevOrigin = ray.origin;
const uint index = hit.triangle_id;
const int Index = Uv.x + Uv.y * screen_width;
float3 Geomnorm;
[branch]if(TerrainExists && HitHeightmap) {
    Geomnorm.x = (GetHeight(pos + float3(0.01f,0,0), Terrains[hit.triangle_id]) - GetHeight(pos - float3(0.01f,0,0), Terrains[hit.triangle_id]));
    Geomnorm.y = (GetHeight(pos + float3(0,0.01f,0), Terrains[hit.triangle_id]) - GetHeight(pos - float3(0,0.01f,0), Terrains[hit.triangle_id]));
    Geomnorm.z = (GetHeight(pos + float3(0,0,0.01f), Terrains[hit.triangle_id]) - GetHeight(pos - float3(0,0,0.01f), Terrains[hit.triangle_id]));
    Geomnorm = normalize(Geomnorm);
    } else {
        Geomnorm = (DoVoxels || !HitVoxel) ? normalize(mul(_MeshData[hit.mesh_id].Inverse, float4(AggTris[index].norm0 + hit.u * AggTris[index].normedge1 + hit.v * AggTris[index].normedge2, 0.0f)).xyz) : float3(0,0,0);
    }
    const float3 PrevThroughput = Color.throughput;
    if(DoVoxels && HitVoxel) {
        Geomnorm = float3(1,0,0);
        float3 VoxPos = floor(mul(_MeshData[hit.mesh_id].Transform, float4(ray.origin + ray.direction * hit.t,1)).xyz) + 0.5f;
        float3 initdiff = mul(_MeshData[hit.mesh_id].Transform, float4(pos, 1)).xyz - VoxPos;
        float Greatest = max(max(abs(initdiff.x), abs(initdiff.y)), abs(initdiff.z));
        if(Greatest == abs(initdiff.y)) Geomnorm = float3(0,1,0);
        if(Greatest == abs(initdiff.z)) Geomnorm = float3(0,0,1);
        Geomnorm = normalize(mul(_MeshData[hit.mesh_id].Inverse, float4(Geomnorm, 0)).xyz);
    }

    // _DebugTex[Uv] = float4(hit.u, hit.v, 0, 1);
    bool GotFlipped = false;
    [branch]if(dot(ray.direction, Geomnorm) >= 0.0f) {
        Geomnorm *= -1;
        GotFlipped = true;
    }
    float3 norm = Geomnorm;
    [branch]if(NormalUV.x != -1) {//Handle Normal Maps
        float3 LocalTan = normalize(mul(_MeshData[hit.mesh_id].Inverse, float4(AggTris[index].tan0 + hit.u * AggTris[index].tanedge1 + hit.v * AggTris[index].tanedge2, 0.0f)).xyz);
        float3 LocalBinorm = normalize(cross(Geomnorm, LocalTan));
        float4 Norm = _NormalAtlas.SampleLevel(sampler_NormalAtlas, NormalUV,0);
        float2 InputNormal;
        InputNormal = Norm.rg * Norm.w;

        float3 LocalNormIN = float3((2.0f * InputNormal.xy - 1.0f),0.0f);
        LocalNormIN.z = 1.0 - 0.5 * dot(LocalNormIN, LocalNormIN );
        norm = normalize(mul(normalize(LocalNormIN), float3x3(LocalTan, LocalBinorm, Geomnorm)).xyz);
        norm = clamp(norm, -1, 1);
        if(abs(norm.x) == abs(norm.y) == abs(norm.z)) norm = Geomnorm;
    }
    if(CurBounce == 1) {
        #ifdef UseReflectionReproject 
            TempPosTex[Uv] = float4(TempPosTex[Uv].xyz,hit.t);
        #endif
        CurrentReservoirGI[Index].SecondaryNormal = packUnormArb(Geomnorm);
    }
    [branch]if(UseReSTIRGI && CurBounce == 0) {//Initialize Buffer
        GIReservoir CurrentRes = CurrentReservoirGI[Index];
        CurrentRes.W = 0;
        CurrentRes.M = 0;
        CurrentRes.HistoricFrame = (ReSTIRGIUpdateRate != 0) ? RandomNums[Uv].x : curframe;
        CurrentRes.HistoricID = (ReSTIRGIUpdateRate != 0) ? RandomNums[Uv].y : (Uv.x + Uv.y * screen_width);
        CurrentRes.SecondaryHitDirectionOut = PreviousReservoirGI[prevIndex].SecondaryHitDirectionOut;
        CurrentRes.SecondaryHitPosition = pos;
        CurrentRes.RadianceIncomming = 0;
        CurrentRes.ThisCase = 0;
        CurrentRes.NEERay = 0;
        CurrentReservoirGI[Index] = CurrentRes;
    }

    [branch]if(hitDat.emmis > 0.0f) {//if we hit a light, this ray is done
        if(!UseNEE || IsEmissiveTex) {
            if(CurBounce == 0) {
                Color.Direct = hitDat.emmis;
                CurrentReservoirGI[Index].RadianceIncomming = luminance(hitDat.emmis);

                TempAlbedoTex[Uv] = float4(hitDat.surfaceColor,1);
                TempNormTex[Uv] = packUnormArb(norm);
                TempPosTex[Uv] = float4(pos,1);
                RenderMaskTex[Uv] = 0;
                } else if(CurBounce == 1) {
                    Color.Direct += hitDat.surfaceColor * (hitDat.emmis);
                    CurrentReservoirGI[Index].RadianceIncomming +=  luminance(hitDat.surfaceColor * hitDat.emmis);

                    CurrentReservoirGI[Index].SecondaryHitPosition = pos;
                    } else {
                        SHData ThisSH = SH[Index];
                        accumulate_SH(ThisSH, irradiance_to_SH(Color.throughput * hitDat.emmis * hitDat.surfaceColor * 1024, Rays[Uv.x + Uv.y * screen_width].direction), 1.0f);
                        SH[Index] = ThisSH;
                        Color.Indirect += Color.throughput * hitDat.emmis * hitDat.surfaceColor;
                        CurrentReservoirGI[Index].RadianceIncomming += luminance(Color.throughput * hitDat.surfaceColor * hitDat.emmis);
                    }
            } else if(CurBounce != 1 || !UseRestir) {
                float3 a0 = mul(_MeshData[hit.mesh_id].Inverse, float4(AggTris[index].pos0, 1)).xyz;
                float3 a1 = mul(_MeshData[hit.mesh_id].Inverse, float4(AggTris[index].pos0 + AggTris[index].posedge1, 1)).xyz;
                float3 a2 = mul(_MeshData[hit.mesh_id].Inverse, float4(AggTris[index].pos0 + AggTris[index].posedge2, 1)).xyz;

                float a = AreaOfTriangle(a0, a1, a2);
                float SA = abs(dot(norm, ray.direction)) * a / (hit.t * hit.t);
                float light_pdf = 1.0f / (SA * LightMeshCount) * ((_LightMeshes[LightMeshCount - 1].CDF / (_UnityLights[unitylightcount - 1].CDF + _LightMeshes[LightMeshCount - 1].CDF))) * (a / _MeshData[hit.mesh_id].LightPDF);
                float w = power_heuristic(RayDat.last_pdf, light_pdf);
                if(CurBounce == 0) {
                    Color.Direct = hitDat.emmis * hitDat.surfaceColor;
                    TempAlbedoTex[Uv] = float4(hitDat.surfaceColor,1);
                    TempNormTex[Uv] = packUnormArb(norm);
                    TempPosTex[Uv] = float4(pos,1);
                    RenderMaskTex[Uv] = 0;
                    CurrentReservoirGI[Index].RadianceIncomming = luminance(hitDat.emmis);
                } else if(CurBounce == 1) {
                    Color.Direct += (hitDat.surfaceColor * hitDat.emmis) * w;
                    CurrentReservoirGI[Index].SecondaryHitPosition = pos;
                    CurrentReservoirGI[Index].RadianceIncomming += luminance((hitDat.surfaceColor * hitDat.emmis));
                } else {
                    SHData ThisSH = SH[Uv.x + Uv.y * screen_width];
                    accumulate_SH(ThisSH, irradiance_to_SH(Color.throughput * hitDat.emmis * hitDat.surfaceColor * w * 1024, Rays[Uv.x + Uv.y * screen_width].direction), 1.0f);
                    SH[Uv.x + Uv.y * screen_width] = ThisSH;
                    Color.Indirect += Color.throughput * hitDat.surfaceColor * hitDat.emmis * w; 
                    CurrentReservoirGI[Index].RadianceIncomming += luminance(Color.throughput * hitDat.surfaceColor * hitDat.emmis);
                }
            }
            return;
        }   
        float3 throughput = Color.throughput;

        float3 tempraydir = float3(0.0f, 0.0f, 0.0f);
        bool valid = true;
        float pdf = 0.0f;

        float3 omega_i = mul(GetTangentSpace(norm), -ray.direction);

        int Case = 2;
        if(CurBounce < 2 && ReSTIRGIUpdateRate != 0 &&UseReSTIRGI && RandomNums[Uv].z == 1) {
            float3 bsdf_value;
            float bsdf_pdf;
            bool validbsdf;
            if(CurBounce == 0) {
                ray.direction = normalize(PreviousReservoirGI[prevIndex].SecondaryHitPosition - (pos + Geomnorm * 0.001f));
                float cos_theta_hit = dot(ray.direction, norm);
                validbsdf = ReconstructBsdf(hitDat, PrevDirection, ray.direction, norm, bsdf_pdf, bsdf_value, PreviousReservoirGI[prevIndex].ThisCase.x, GetTangentSpace2(norm));// evaldiffuse(ray.direction, cos_theta_hit, bsdf_value, bsdf_pdf);

                CurrentReservoirGI[Index].ThisCase = PreviousReservoirGI[prevIndex].ThisCase;
            valid = validbsdf && all(bsdf_value < 0 || bsdf_value > 0 || bsdf_value == 0) && luminance(bsdf_value) < 100.0f;

            throughput *= bsdf_value;
            pdf = bsdf_pdf;
            } else if(CurBounce == 1) {
                ray.direction = PreviousReservoirGI[prevIndex].SecondaryHitDirectionOut;
                float cos_theta_hit = dot(ray.direction, norm);
            validbsdf = ReconstructBsdf(hitDat, PrevDirection, ray.direction, norm, bsdf_pdf, bsdf_value, PreviousReservoirGI[prevIndex].ThisCase.y, GetTangentSpace2(norm));// evaldiffuse(ray.direction, cos_theta_hit, bsdf_value, bsdf_pdf);
            valid = validbsdf && all(bsdf_value < 0 || bsdf_value > 0 || bsdf_value == 0) && luminance(bsdf_value) < 100.0f;
            
            throughput *= bsdf_value;
            pdf = bsdf_pdf;
        }
    } else {//if(random(92).x < 0.5f) {
        [branch]switch(hitDat.MatType) {//Switch between different materials
            case 1://Disney BSDF
            BsdfSample Thissample = initbsdf();
            if(!GotFlipped) {
                hitDat.relativeIOR = rcp(hitDat.ior);
            }
            bool2 tempvalid = SampleDisney(hitDat, -ray.direction, hitDat.Thin == 1, Thissample, GetTangentSpace2(norm), Case);
            valid = tempvalid.x;
            ray.direction = Thissample.wi;
            pdf = Thissample.forwardPdfW;
            throughput *= max(Thissample.reflectance,0.000001f);
            if(CurBounce == 0) CurrentReservoirGI[Index].ThisCase.x = Case;
            if(CurBounce == 1) CurrentReservoirGI[Index].ThisCase.y = Case;
                // valid = valid && all(Thissample.reflectance < 0 || Thissample.reflectance > 0 || Thissample.reflectance == 0) && all(Thissample.forwardPdfW <= 1);
                
                if(tempvalid.y) {
                    Geomnorm *= -1; norm *= -1;
                }
                break;
            case 2://"Glossy" material
            ray.direction = normalize(mul(sample(pdf), GetTangentSpace(norm)) * hitDat.roughness + reflect(ray.direction, norm) * (1.0f - hitDat.roughness));
            throughput *= hitDat.surfaceColor;
            break;
            case 3://mask material
            if(hitDat.DoesPassThrough) {
                Geomnorm *= -1;
                norm *= -1;
                } else {
                    ray.direction = normalize(mul(sample(pdf), GetTangentSpace(norm)));
                    valid = pdf > 0;
                    throughput *= hitDat.surfaceColor;
                }
                break;
            case 4://"Volumetric" material
            if(GotFlipped) {
                if(VolumetricScatter(throughput, hit, ray, pos, hitDat)) {
                    norm = -norm;
                    Geomnorm = -Geomnorm;
                }
                } else {
                    ray.direction = ray.direction;
                    norm = -norm;
                    Geomnorm = -Geomnorm;
                }
                break;
            case 5://SSS

            if(GotFlipped) {
                norm = -norm;
                Geomnorm = -Geomnorm;
                float tempdist = hit.t * 24.0f;
                        throughput *= exp(-hitDat.transmittanceColor * tempdist * tempdist * tempdist * 2.0f);//Beers law
                        } else {
                            pos -= Geomnorm  * 0.005f;
                            throughput *= hitDat.surfaceColor;
                        }
                        float3 modifier = hitDat.roughness * normalize(mul(sample(pdf, 14), GetTangentSpace(-norm)));
                        ray.direction = normalize(normalize(mul(sample(pdf), GetTangentSpace(norm))) + ( modifier));

                        break;
            case 6://DiffTrans
            if(random(10).x > 0.5f) {
                norm = -norm;
                Geomnorm = -Geomnorm;
                throughput *= hitDat.surfaceColor;
                } else {
                   throughput *= hitDat.surfaceColor * 2.0f;
                        if(GotFlipped) throughput *= exp(-hitDat.surfaceColor * hit.t);//Beers law
                    }
                    ray.direction = normalize(normalize(mul(sample(pdf), GetTangentSpace(norm))) * (1.0f - hitDat.roughness) + hitDat.roughness * ray.direction);
                    break;
                    case 7:
                    valid = sampleplastic(hitDat, throughput, tempraydir, pdf, omega_i);
                    ray.direction = normalize(mul(tempraydir, GetTangentSpace(norm)));    
                    break;
                    default:
                    ray.direction = normalize(mul(sample(pdf), GetTangentSpace(norm)));
                    valid = pdf > 0;
                    throughput *= hitDat.surfaceColor;
                    break;      
                }
        if(!valid) return;//If the ray failed, we have no choice but to terminate this path
    }// else {
    //     float dist = 0;
    //     float3 tempdir = 0;
    //     throughput *= scatter(ray, tempdir, dist, 0, hit.t, GetTangentSpace(ray.direction)) * (2);
    //     pos = dist * ray.direction + ray.origin;
    //     ray.direction = tempdir;
    // }


    ray.origin = Geomnorm * 0.001f + pos;//Offset the ray origin so we dont self intersect with the triangle we just bounced off of

    [branch]if(UseReSTIRGI && CurBounce == 1) {
        CurrentReservoirGI[Index].SecondaryHitDirectionOut = ray.direction;
        CurrentReservoirGI[Index].SecondaryHitPosition = pos;
    }

    [branch]if(CurBounce == 0 || TempAlbedoTex[Uv].w == -1) {//Setting textures for denosier to use
        Rays[Index].direction = ray.direction;
        TempAlbedoTex[Uv] = float4(max(throughput, 0.00001f),Case == 3? -1 : 1);
       if(CurBounce == 0) CurrentReservoirGI[Index].BaseColor = max(throughput, 0.00001f);
        TempNormTex[Uv] = packUnormArb(Geomnorm);
        TempPosTex[Uv] = float4(pos,hit.t);
        throughput = 1;
    }
    [branch]if((UseNEE) && CurBounce < MaxBounce && !hitDat.DoesPassThrough) {//Next event estimation
        float3 pos2;
        float3 LightNorm;
        int triindex;
        bool IsAboveHorizon = true;
        bool IsDirectional = false;
        float LightPDF = 0.0f;
        bool UseUnityLight;
        int TriCount = 0;
        int MeshIndex = 0;
        Reservoir CurRes = CurrentReservoir[Index];

        [branch]if(UseRestir && CurBounce == 0 && CurRes.y != -1) {
            UseUnityLight = CurRes.MeshIndex < 0;//(unitylightcount != 0) ? (LightMeshCount != 0) ? (random(11).x <= (_UnityLights[unitylightcount - 1].CDF / (_UnityLights[unitylightcount - 1].CDF + _LightMeshes[LightMeshCount - 1].CDF))) : true : false;//Choose whether to sample unity lights or mesh lights based off which is more powerful
            if(UseUnityLight) {
                triindex = CurRes.y;
                [branch]switch(_UnityLights[triindex].Type) {
                    default:
                    pos2 = CurRes.Position;
                    LightNorm = CurRes.Norm;
                    break;
                    case 1:
                    pos2 = ray.origin + _UnityLights[triindex].Direction;
                    LightNorm = -_UnityLights[triindex].Direction;
                    IsAboveHorizon = (LightNorm.y <= 0.0f);
                    IsDirectional = true;
                    break;
                    case 2:
                    pos2 = CurRes.Position;
                    LightNorm = CurRes.Norm;
                    IsAboveHorizon = false;
                    break;
                }
                } else {
                 triindex = CurRes.y;
                 pos2 = CurRes.Position;
                 LightNorm = CurRes.Norm;
                 LightPDF = CurRes.wsum;
                 MeshIndex = CurRes.MeshIndex;
                 TriCount = (_LightMeshes[CurRes.MeshIndex].IndexEnd - _LightMeshes[CurRes.MeshIndex].StartIndex);

             }
             } else {
            UseUnityLight = (unitylightcount != 0) ? (LightMeshCount != 0) ? (random(11).x <= (_UnityLights[unitylightcount - 1].CDF / (_UnityLights[unitylightcount - 1].CDF + _LightMeshes[LightMeshCount - 1].CDF))) : true : false;//Choose whether to sample unity lights or mesh lights based off which is more powerful
            if(UseUnityLight) {
                triindex = SelectUnityLight();
                LightData Light = _UnityLights[triindex];
                [branch]switch(Light.Type) {
                    default:
                    pos2 = Light.Position;
                    LightNorm = normalize(ray.origin - pos2);
                    break;
                    case 1:
                    pos2 = ray.origin + Light.Direction;
                    LightNorm = -Light.Direction;
                    IsAboveHorizon = (LightNorm.y <= 0.0f);
                    IsDirectional = true;
                    break;
                    case 2:
                    pos2 = Light.Position;
                    LightNorm = Light.Direction;
                    IsAboveHorizon = false;
                    break;
                }
                } else {
                    MeshIndex = SelectLightMesh();
                    triindex = SelectLight(MeshIndex, false);
                    TrianglePos CurTri = triangle_get_positions2(triindex);
                    float2 rand_triangle = random(24);
                    float2 CurUv = sample_triangle(rand_triangle.x, rand_triangle.y);
                    pos2 = mul(_LightMeshes[MeshIndex].Inverse, float4(CurTri.pos0 + CurUv.x * CurTri.posedge1 + CurUv.y * CurTri.posedge2, 1.0f)).xyz;
                    LightNorm = normalize(mul(_LightMeshes[MeshIndex].Inverse, float4(LightTriangles[triindex].Norm, 0.0f)).xyz);
                    TriCount = (_LightMeshes[MeshIndex].IndexEnd - _LightMeshes[MeshIndex].StartIndex);
                }
            }
            float3 to_light = pos2 - ray.origin;

            float distance_to_light_squared = dot(to_light, to_light);
            float distance_to_light = sqrt(max(distance_to_light_squared, 0.0f));

            to_light = to_light / distance_to_light;
            if(IsDirectional) {
                float diskRadius = 2 * sin(0.5f * PI / 180.0f);
                float2 rand = random(23);
                float3 DirectionAdjustment = float3(diskRadius * cos(rand.x * 2 * PI), diskRadius * sin(rand.y * 2 * PI), 0);
                float3 DirectionNormal = float3(0,0,1);
                float3 z = normalize(cross(DirectionNormal, to_light));
                float3 y = normalize(cross(z, DirectionNormal));
                float3x3 rotationmatrix = float3x3(
                    DirectionNormal.x, y.x, z.x,
                    DirectionNormal.y, y.y, z.y,
                    DirectionNormal.z, y.z, z.z
                    );
                to_light = normalize(to_light + (mul(DirectionAdjustment, rotationmatrix)));
            }
            float Attenuation = 1.0f;
            if(!IsDirectional && !IsAboveHorizon) {
                Attenuation = saturate(dot(to_light, -LightNorm) * _UnityLights[triindex].SpotAngle.x + _UnityLights[triindex].SpotAngle.y);
                IsAboveHorizon = true;
            }

            bool validbsdf = false;
            float3 bsdf_value = 0.0f;
            float bsdf_pdf = 0.0f;
            float throwaway = 0;

            float cos_theta_light = abs(dot(to_light, LightNorm));
            float cos_theta_hit = dot(to_light, norm);
        [branch]switch(hitDat.MatType) {//Switch between different materials
            default:
            validbsdf = evaldiffuse(to_light, cos_theta_hit, bsdf_value, bsdf_pdf);
            bsdf_value *= hitDat.surfaceColor;
            break;
            case 1:
                bsdf_value = EvaluateDisney(hitDat, -PrevDirection, to_light, hitDat.Thin == 1, bsdf_pdf, throwaway, GetTangentSpace2(norm));// DisneyEval(mat, -PrevDirection, norm, to_light, bsdf_pdf, hitDat);
                validbsdf = bsdf_pdf > 0;
                break;
                case 3:
                validbsdf = false;
                break;
                case 4:
                validbsdf = true;
                break;
                case 5:
                validbsdf = evaldiffuse(to_light, cos_theta_hit, bsdf_value, bsdf_pdf);
                break;
                case 6:
                validbsdf = evaldiffuse(to_light, cos_theta_hit, bsdf_value, bsdf_pdf);
                break;
                case 7:
                validbsdf = evalplastic(hitDat, mul(GetTangentSpace(norm), to_light), cos_theta_hit, bsdf_value, bsdf_pdf, omega_i);
                break;

            }

            float LightCos = abs(dot(to_light, LightNorm));
            float SurfaceCos = dot(to_light, norm);
            if(SurfaceCos > 0){
                float3 Radiance;
                float NEE_pdf;
                float3 Illum;
                float RadianceIncomming;
                if(UseUnityLight) {
                    float3 transmittance = 1;
                    if(IsDirectional) {
                        float3 Radiance = GetSkyRadiance(ray.origin, to_light, 0, SunDir, transmittance);
                    }
                    RadianceIncomming = luminance(_UnityLights[triindex].Radiance);
                    Radiance = _UnityLights[triindex].Radiance * transmittance;
                    NEE_pdf = distance_to_light_squared * LightCos / (unitylightcount) * (_UnityLights[unitylightcount - 1].CDF / (_UnityLights[unitylightcount - 1].CDF + _LightMeshes[LightMeshCount - 1].CDF));
                    float NEEMISWeight = power_heuristic(NEE_pdf, bsdf_pdf);
                    Illum = PrevThroughput * (Radiance * bsdf_value) /  NEE_pdf * Attenuation * ((UseRestir && CurBounce == 0 && (CurRes.W > 0 || CurRes.W < 0 || CurRes.W == 0)) ? CurRes.W : 1);
                    } else {
                        float SA = LightCos * LightTriangles[triindex].area / distance_to_light_squared;
                        NEE_pdf = (1.0f / (LightMeshCount * SA)) * (LightTriangles[triindex].pdf / _LightMeshes[MeshIndex].pdf) * (_LightMeshes[LightMeshCount - 1].CDF / (_UnityLights[unitylightcount - 1].CDF + _LightMeshes[LightMeshCount - 1].CDF));
                        Radiance = LightTriangles[triindex].radiance;
                        RadianceIncomming = luminance(Radiance);
                        float NEEMISWeight = power_heuristic(NEE_pdf, bsdf_pdf);
                        Illum = PrevThroughput * (Radiance * bsdf_value) /  NEE_pdf * Attenuation * ((UseRestir && CurBounce == 0 && (CurRes.W > 0 || CurRes.W < 0 || CurRes.W == 0)) ? CurRes.W : NEEMISWeight) / max(hitDat.surfaceColor,0.0000001f);
                    }
                    if(CurBounce == 0) CurrentReservoirGI[Index].NEEPosition = pos2;

                    bool DoNEERR = (CurBounce == 0 && UseRestir);
                    float maxillum = max(max(Illum.x, Illum.y), Illum.z);
            if((DoNEERR || maxillum > random(9).y) && (CurRes.W != 0 || !UseRestir || CurBounce != 0)) {//NEE russian roulette, massively improves performance while giivng the same result
                uint index3;//Congrats we shoot a shadow ray for NEE

                InterlockedAdd(BufferSizes[CurBounce].shadow_rays, 1, index3); 
                ShadowRaysBuffer[index3].origin = ray.origin;
                ShadowRaysBuffer[index3].direction = to_light;
                ShadowRaysBuffer[index3].t = (IsDirectional) ? 10000.0f : distance_to_light - 0.00001f;//2.0f * EPSILON;
                ShadowRaysBuffer[index3].illumination = Illum * ((DoNEERR) ? 1 : rcp(saturate(maxillum)))* max(hitDat.surfaceColor,0.0000001f);// / (CurBounce == 0 && TempAlbedoTex[Uv].xyz != 0.00001f ? TempAlbedoTex[Uv].xyz : 1);// * max(hitDat.surfaceColor,0.0000001f);
                ShadowRaysBuffer[index3].RadianceIncomming = Illum * ((DoNEERR) ? 1 : rcp(saturate(maxillum)))* max(hitDat.surfaceColor,0.0000001f) / bsdf_value ;
                ShadowRaysBuffer[index3].PixelIndex = Uv.y * screen_width + Uv.x;
                ShadowRaysBuffer[index3].LuminanceIncomming = luminance(Radiance);
                ShadowRaysBuffer[index3].PrimaryNEERay = (CurBounce != 0);
                } else if(UseRestir && CurBounce == 0) {
                    CurrentReservoir[Uv.y * screen_width + Uv.x].W = 0;
                    CurrentReservoir[Uv.y * screen_width + Uv.x].wsum = 0;
                }
                } else if(UseRestir && CurBounce == 0) {
                    CurrentReservoir[Uv.y * screen_width + Uv.x].W = 0;
                    CurrentReservoir[Uv.y * screen_width + Uv.x].wsum = 0;
                }
            }
    if(UseRussianRoulette) {
        float3 AdjustedCol = throughput * ((UseReSTIRGI && ReSTIRGIUpdateRate != 0 && RandomNums[Uv].z == 1) ? PreviousReservoirGI[prevIndex].BaseColor : TempAlbedoTex[Uv].xyz);
        float p = saturate(max(AdjustedCol.x, max(AdjustedCol.y, AdjustedCol.z)));
        if(random(2).x > p && CurBounce > 0)//Simple Russian Roulette
            return;
        if(CurBounce > 0)
           throughput *= rcp(p);//rcp is a slightly faster but less accurate version of 1 / p, I decided the inaccuracy was worth the performance bump
    }
    if(any(throughput > 10000.0f)) return;
    Color.throughput = throughput;
    uint index2;//Congrats, the ray will continue its path
    InterlockedAdd(BufferSizes[CurBounce + 1].tracerays, 1, index2);
    GlobalRays1[index2].origin = ray.origin;
    GlobalRays1[index2].direction = ray.direction;
    GlobalRays1[index2].PixelIndex = Uv.x + Uv.y * screen_width;
    GlobalRays1[index2].PrevIndex = prevIndex;
    GlobalRays1[index2].last_pdf = pdf;
    set(index2, hit);
}

Texture2D<float4> TerrainAlphaMap;
SamplerState sampler_TerrainAlphaMap;
int MaterialCount;

[numthreads(8,8,1)]
void kernel_shade () {

    int index;
    InterlockedAdd(BufferSizes[CurBounce].shade_rays, 1, index);
    if(index >= BufferSizes[CurBounce].tracerays) return;
    int PixIndex = GlobalRays2[index].PixelIndex;
    uint2 TempUv = uint2(PixIndex % screen_width, PixIndex / screen_width);
    pixel_index = PixIndex;//TempUv is the origional screen coordinates of the ray

    Ray ray;
    RayHit bestHit = get2(index);
    ray.origin = GlobalRays2[index].origin;
    ray.direction = GlobalRays2[index].direction;
    ray.direction_inv = float3(0.0f, 0.0f, 0.0f);//We dont need to calculate this, but we do need to give it some value or Unity complains

    ColData Color = GlobalColors[PixIndex];
    if(CurBounce == 0) RenderMaskTex[TempUv] = 1;
    if(bestHit.t > 1000.0) {//if ray goes into the void, sample skybox
        float3 SkyColAcc;
        #ifdef UseSkyBox
            float theta = acos(ray.direction.y) / -PI;
            float phi = atan2(ray.direction.x, -ray.direction.z) / -PI * 0.5f;
            float3 sky = _SkyboxTexture.SampleLevel(sampler_SkyboxTexture, float2(phi, theta), CurBounce == 0 ? 0 : 4).xyz;
            if(CurBounce == 0) {//Seperated into direct and indirect channels
                Color.Direct = sky;
                RenderMaskTex[TempUv] = 0;
            } else if(CurBounce == 1) {
                Color.Direct += sky;
            } else {
                Color.Indirect += Color.throughput * sky;
            }
            SkyColAcc = Color.throughput * sky;
        #else
            float3 transmittance = 0;
            float3 Radiance = GetSkyRadiance(ray.origin, ray.direction, 0, SunDir, transmittance);
            Radiance = float3(1,1,1) - exp(-Radiance / 1 * 10.0f);
            float3 SkyBoxCol = saturate(Radiance);
            float3 Sun = 0;//(saturate(max(min(exp(-acos(max(dot(-SunDir, -ray.direction), 0.0f))* 60.0f),12.0f),0) * transmittance));
            if(dot(ray.direction, SunDir) > cos(0.0235f / 2.0f)) {
                Sun = saturate(Radiance + transmittance * (1.5f / (PI * (0.0235f / 2.0f) * (0.0235f / 2.0f))));
            }
            // float3 direct;
            // float3 transmittance2 = Clouds(SunDir, ray, direct);
            if(all(SkyBoxCol > 0 || SkyBoxCol < 0 || SkyBoxCol == 0)) {
                if(CurBounce == 0) {//Seperated into direct and indirect channels
                    RenderMaskTex[TempUv] = 0;
                    Color.Direct = ((SkyBoxCol) + Sun);// * transmittance2 + direct;
                    // CurrentReservoirGI[TempUv.x + TempUv.y * screen_width].RadianceIncomming = luminance((SkyBoxCol) + Sun);

                    } else if(CurBounce == 1) {
                        Color.Direct += Color.throughput * (SkyBoxCol) + Sun;
                        CurrentReservoirGI[TempUv.x + TempUv.y * screen_width].SecondaryHitPosition = ray.origin + ray.direction * 12.0f;

                    // CurrentReservoirGI[TempUv.x + TempUv.y * screen_width].RadianceIncomming += luminance(Color.throughput * (SkyBoxCol) + Sun);
                    } else {
                        SHData ThisSH = SH[TempUv.x + TempUv.y * screen_width];
                        accumulate_SH(ThisSH, irradiance_to_SH((Color.throughput * (SkyBoxCol) + Sun) * 1024, ray.direction), 1.0f);
                        SH[TempUv.x + TempUv.y * screen_width] = ThisSH;
                        Color.Indirect += Color.throughput * (SkyBoxCol) + Sun;

                    }
                }
                #endif
        // float3 col = 0.051f;//float3(0.972549, 0.9568627, 0.9294118);
        //         if(CurBounce == 0) {//Seperated into direct and indirect channels
        //             RenderMaskTex[TempUv] = 0;
        //             Color.Direct = col;
        //         } else if(CurBounce == 1) {
        //             Color.Direct += Color.throughput * col;
        //             CurrentReservoirGI[TempUv.x + TempUv.y * screen_width].SecondaryHitPosition = ray.origin + ray.direction * 12.0f;
        //         } else {
        //             SHData ThisSH = SH[TempUv.x + TempUv.y * screen_width];
        //             accumulate_SH(ThisSH, irradiance_to_SH((Color.throughput * 0.051f) * 1024, ray.direction), 1.0f);
        //             SH[TempUv.x + TempUv.y * screen_width] = ThisSH;
        //             Color.Indirect += Color.throughput * col;
        //         }
        if(CurBounce == 0) {
            TempAlbedoTex[TempUv] = 1;
        }
        GlobalColors[PixIndex] = Color;
        return;
    }


    float2 BaseUv = AggTris[bestHit.triangle_id].tex0 * (1.0f - bestHit.u - bestHit.v) + AggTris[bestHit.triangle_id].texedge1 * bestHit.u + AggTris[bestHit.triangle_id].texedge2 * bestHit.v;
    int MatOffset = 0;
    if(TerrainExists && (GlobalRays2[index].HitVoxel == 2)) {
        BaseUv = float2(bestHit.u, bestHit.v);
        float4 Mats = TerrainAlphaMap.SampleLevel(sampler_TerrainAlphaMap, float2(bestHit.u, bestHit.v) * ( Terrains[bestHit.triangle_id].AlphaMap.xy -  Terrains[bestHit.triangle_id].AlphaMap.zw) +  Terrains[bestHit.triangle_id].AlphaMap.zw, 0);

        MatOffset = Mats.y + Mats.z * 2 + Mats.a * 3;
    }

    int MaterialIndex = (GlobalRays2[index].HitVoxel == 2) ? (MaterialCount + MatOffset + Terrains[bestHit.triangle_id].MatOffset) : (GlobalRays2[index].HitVoxel == 1) ? (_MeshData[bestHit.mesh_id].MaterialOffset + (-(bestHit.triangle_id + 2))) : (_MeshData[bestHit.mesh_id].MaterialOffset + AggTris[bestHit.triangle_id].MatDat);
    MaterialData TempMat = _Materials[MaterialIndex];
    if(TerrainExists && (GlobalRays2[index].HitVoxel == 2)) BaseUv = BaseUv * TempMat.BaseColor.xy + TempMat.transmittanceColor.xy;

    float2 Uv = fmod(BaseUv + 100.0f, float2(1.0f, 1.0f)) * (_Materials[MaterialIndex].AlbedoTex.xy - _Materials[MaterialIndex].AlbedoTex.zw) + _Materials[MaterialIndex].AlbedoTex.zw;
    float2 NormalUV = (_Materials[MaterialIndex].HasNormalTex == 1) ? fmod(BaseUv + 100.0f, float2(1.0f, 1.0f)) * (_Materials[MaterialIndex].NormalTex.xy - _Materials[MaterialIndex].NormalTex.zw) + _Materials[MaterialIndex].NormalTex.zw : float2(-1,-1);
    HitMat hitmat = CreateHitMat();//Transfer Material properties
    float4 BaseCol = (TempMat.HasAlbedoTex > 0) ? _TextureAtlas.SampleLevel(my_point_repeat_sampler, Uv, 0) : float4(TempMat.BaseColor, 1.0f);
    hitmat.surfaceColor = BaseCol.xyz * BaseCol.w;
    hitmat.emmis = TempMat.emmissive;
    TempMat.roughness = max(TempMat.roughness,0.00001f) + max((CurBounce != 0) ? CurBounce / (float)MaxBounce : 0,0);
    hitmat.roughness = max(TempMat.roughness,0.00001f);
    hitmat.MatType = TempMat.MatType;
    hitmat.transmittanceColor = TempMat.transmittanceColor;
    hitmat.metallic = TempMat.metallic;
    hitmat.ior = TempMat.ior;
    hitmat.specTrans = TempMat.specTrans;
    hitmat.specularTint = TempMat.specularTint;
    hitmat.clearcoat = TempMat.clearcoat;
    hitmat.clearcoatGloss = TempMat.clearcoatGloss;
    hitmat.diffTrans = TempMat.diffTrans;
    hitmat.sheen = TempMat.sheen;
    hitmat.sheenTint = TempMat.sheenTint;
    hitmat.anisotropic = TempMat.anisotropic;
    hitmat.flatness = TempMat.flatness;
    hitmat.transmittanceColor = TempMat.transmittanceColor;    
    hitmat.phaseFunction = 0;
    hitmat.extinction = 0;
    hitmat.relativeIOR = TempMat.ior;
    hitmat.Thin = TempMat.Thin;
    hitmat.scatterDistance = 0.5f;//bestHit.t;
    hitmat.Specular = TempMat.Specular;//bestHit.t;


    if(TempMat.MatType == 3) {
        if(_MetalAlphaRoughnessAtlas.SampleLevel(sampler_MetalAlphaRoughnessAtlas, Uv, 0).y == 0) {
            hitmat.DoesPassThrough = true;
        }
    }

    if(TempMat.HasMetallicTex > 0 && hitmat.specTrans != 1) {
        // hitmat.clearcoat = 1;
        // hitmat.ior = 1.33;
        float2 MetallicUV = fmod(BaseUv + 100.0f, float2(1.0f, 1.0f)) * (_Materials[MaterialIndex].MetallicTex.xy - _Materials[MaterialIndex].MetallicTex.zw) + _Materials[MaterialIndex].MetallicTex.zw;
        float4 MetallicCol = _MetalAlphaRoughnessAtlas.SampleLevel(sampler_MetalAlphaRoughnessAtlas, MetallicUV, 0);
        MetallicCol.xyz *= MetallicCol.w;
        // hitmat.roughness = saturate(1 - pow(MetallicCol.g, 0.4545f));
        if(MetallicCol.r > 0.001f) {
            hitmat.metallic = MetallicCol.r;
            // hitmat.metallic = pow(MetallicCol.g, 0.4545f);
            // hitmat.MatType = 1;
            // hitmat.roughness = MetallicCol.b;
            // TempMat.roughness = MetallicCol.b;
        }
        if(MetallicCol.g > 0.001f) {
            // hitmat.roughness = MetallicCol.a;
            // hitmat.Specular = pow(MetallicCol.g, 0.4545f);
            // hitmat.ior = 1.33;
           // hitmat.clearcoat = pow(MetallicCol.g, 0.4545f);
           // hitmat.clearcoatGloss = pow(MetallicCol.g, 0.4545f);
       }
    }
    if(TempMat.HasRoughnessTex > 0) {
        float2 RoughnessUV = fmod(BaseUv + 100.0f, float2(1.0f, 1.0f)) * (_Materials[MaterialIndex].RoughnessTex.xy - _Materials[MaterialIndex].RoughnessTex.zw) + _Materials[MaterialIndex].RoughnessTex.zw;
        float4 RoughnessCol = _MetalAlphaRoughnessAtlas.SampleLevel(sampler_MetalAlphaRoughnessAtlas, RoughnessUV, 0);
        hitmat.roughness = 1.0f - saturate(RoughnessCol.z * RoughnessCol.w);
    }
    bool IsEmissiveTex = false;
    if(TempMat.HasEmissiveTex > 0) {
        float2 EmissionUV = fmod(BaseUv + 100.0f, float2(1.0f, 1.0f)) * (_Materials[MaterialIndex].EmissiveTex.xy - _Materials[MaterialIndex].EmissiveTex.zw) + _Materials[MaterialIndex].EmissiveTex.zw;
        float3 EmissCol = _Materials[MaterialIndex].EmissionColor;
        bool IsMask = !(EmissCol.x == 0 && EmissCol.y == 0 && EmissCol.z == 0);
        float4 EmissTexture = _EmissiveAtlas.SampleLevel(sampler_EmissiveAtlas, EmissionUV, 0);
        if(!IsMask) EmissCol = EmissTexture.xyz * EmissTexture.w;
        else EmissCol *= EmissTexture.xyz * EmissTexture.w;
        if(dot(EmissCol,EmissCol) > 0.001f) {
            IsEmissiveTex = true;
            hitmat.surfaceColor += EmissCol * (IsMask ? hitmat.surfaceColor : hitmat.surfaceColor);
            hitmat.emmis = sqrt(dot(EmissCol,EmissCol));
            } else {
                hitmat.emmis = 0;
            }
            } else if(_Materials[MaterialIndex].EmissionColor.x != 0 || _Materials[MaterialIndex].EmissionColor.y != 0 || _Materials[MaterialIndex].EmissionColor.z != 0) {
                hitmat.surfaceColor += _Materials[MaterialIndex].EmissionColor * hitmat.surfaceColor;
            }
            if(CurBounce == 0) {
                CurrentReservoirGI[PixIndex].MaterialIndex = MaterialIndex;
                PerMatInfo TempMatModifier = {hitmat.Specular, hitmat.roughness, hitmat.clearcoat, hitmat.clearcoatGloss, hitmat.metallic, hitmat.surfaceColor};
                MatModifiers[PixIndex] = TempMatModifier;
            }

            calcFinalColor(ray, Color, hitmat, bestHit, TempUv, NormalUV, GlobalRays2[index].HitVoxel == 1, IsEmissiveTex, GlobalRays2[index], TempMat, GlobalRays2[index].PrevIndex, GlobalRays2[index].HitVoxel == 2);
            GlobalColors[PixIndex] = Color;
        }



        #pragma kernel kernel_finalize


        Texture2D<float> Depth;
        SamplerState my_linear_clamp_sampler;
        RWTexture2D<float> PrevDepthTex;
        bool UseAtrous;
        bool DiffRes;
        float FarPlane;
        RWTexture2D<int> PrevNormalTex;

        [numthreads(16,16,1)]
void kernel_finalize (uint3 id : SV_DispatchThreadID) {//Moved final accumulation into its own kernel, improves performance

    if(id.x >= screen_width || id.y >= screen_height) return;
    int final_pixel_index = id.y * screen_width + id.x;
    float2 Uv = id.xy / float2(screen_width, screen_height);
    if(UseReSTIRGI) PrevDepthTex[id.xy] = Linear01Depth(Depth.SampleLevel(my_linear_clamp_sampler, Uv, 0).x) * FarPlane;
    if(UseReSTIRGI) PrevNormalTex[id.xy] = packUnormArb(NormalTex.SampleLevel(sampler_NormalTex, Uv, 0).xyz);
    float3 res =  (GlobalColors[final_pixel_index].Direct + GlobalColors[final_pixel_index].Indirect) * ((DiffRes || UseAtrous) ? 1.0f : AlbedoTex[id.xy].xyz) + GlobalColors[final_pixel_index].PrimaryNEERay;
    if(!all(res < 100000)) res = 0;
    // MatModifiersPrev[id.x + id.y * screen_width] = MatModifiers[id.x + id.y * screen_width];
    Result[id.xy] = float4(res, 1.0f);
}




#pragma kernel kernel_reservoir
bool UseRestirPrecomputedSamples;


float4x4 viewprojection;
float4x4 prevviewprojection;

void UpdateReservoir(inout Reservoir r, float x, float w, float rndnum, float m, float3 Pos, float3 Norm)
{
    r.wsum += w;
    r.M += 1;
    if (rndnum < (w/r.wsum)) {
        r.y = x;
        r.MeshIndex = m;
        r.Position = Pos;
        r.Norm = Norm;
    }

}


void UpdateReservoir(inout Reservoir r, float x, float w, float rndnum, float m, float3 Pos, float3 Norm, Reservoir V)
{
    r.wsum += w;
    r.M += 1;
    if (rndnum < (w/r.wsum)) {
        r.y = x;
        r.MeshIndex = m;
        r.Position = Pos;
        r.Norm = Norm;
        r.PrevWorld = V.PrevWorld;
        r.PrevNorm = V.PrevNorm;
        r.W = V.W;
    }

}

float RadicalInverse_VdC(uint bits)
{
    bits = (bits << 16u) | (bits >> 16u);
    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);
    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);
    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);
    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);
    return float(bits) * 2.3283064365386963e-10; // / 0x100000000
}

//function to generate a hammersly low discrepency sequence for importance sampling
float2 Hammersley(uint i, uint N)
{
    return float2(float(i) / float(N), RadicalInverse_VdC(i));
}

struct LightBlockData {
    float3 Pos;
    float3 Norm;
    float3 Misc;
    float3 Rad;
    float2 PDFArea;
};


StructuredBuffer<LightBlockData> Blocks;

float3 camPos;

int lightsamplecount;
int spatialsamplecount;

static const float MultiplyData = (1.0 / 4294967296.0);
bool UseRestirTemporal;

groupshared LightBlockData tileBlock[512];

uniform bool UseSpatial;

int SpatialMCap;

[numthreads(8,8,1)]
void kernel_reservoir (uint3 id : SV_DispatchThreadID, uint3 id2 : SV_GroupThreadID, uint3 id3 : SV_GroupID) {//Moved final accumulation into its own kernel, improves performance


    int i = 0;
    rng_state = (id3.x + id3.y * screen_width / 8);
    pixel_index = rng_state;
    if(UseRestirPrecomputedSamples) {
        const uint BlockIndex = floor(min(random(12).x * 128, 127)) * 512;
        const int Index = (id2.x + id2.y * 8) * 8;
        [unroll]for(int i = 0; i < 8; i++) {
            tileBlock[Index + i] = Blocks[BlockIndex + Index + i];
        }
    }
    GroupMemoryBarrierWithGroupSync();
    if(id.x >= screen_width || id.y >= screen_height) return;
    pixel_index = id.y * screen_width + id.x;
    rng_state = pixel_index * curframe;
    const float2 UV = id.xy / float2(screen_width, screen_height);

    const float3 Norm = unpackUnormArb(TempNormTex[id.xy]);//.SampleLevel(sampler_NormalTex, UV, 0).xyz;
    const float3 WorldPosition =  TempPosTex[id.xy].xyz;
    const float LightPDFAddtion = (_UnityLights[unitylightcount - 1].CDF / (_UnityLights[unitylightcount - 1].CDF + _LightMeshes[LightMeshCount - 1].CDF));
    const float LightTriPDFAddtion = (_LightMeshes[LightMeshCount - 1].CDF / (_UnityLights[unitylightcount - 1].CDF + _LightMeshes[LightMeshCount - 1].CDF));

    Reservoir prevReservoir = {-1,0,0,0,0,0,0,0,0,0,0,0,0,-1,0,0,0,0,0,0,0,0,0};
    uint2 prevIndex =     int2(floor(((float2(id.xy) + 0.5) * float2(rcp(screen_width), rcp(screen_height)) - MotionVectors.SampleLevel(sampler_MotionVectors, UV, 0).xy) * float2(screen_width, screen_height)));
    if (prevIndex.x >= 0 && prevIndex.x < screen_width && prevIndex.y >= 0 && prevIndex.y < screen_height)
    {
        prevReservoir = PreviousReservoir[prevIndex.y * screen_width + prevIndex.x];
        if(prevReservoir.W == 0) prevReservoir.wsum = 0;
    }
    Reservoir reservoir = {-1,0,0,0,0,0,0,0,0,0,0,0,0,-1,0,0,0,0,0,0,0,0,0};
    [branch]if(UseRestirPrecomputedSamples) {
        float3 LightPos;
        for(i = 0; i < lightsamplecount; i++) {
            const float Rand = floor(min(random(34 + i).y * 512, 511));
            LightPos = ((tileBlock[Rand].Misc.z == 1) ? (WorldPosition - tileBlock[Rand].Norm) : tileBlock[Rand].Pos);
            float3 L = (LightPos - WorldPosition);
            const float Dist = dot(L, L);
            L /= sqrt(Dist);
            float3 LightNorm = ((tileBlock[Rand].Misc.x < 0) ? ((tileBlock[Rand].Misc.z == 2) ? -tileBlock[Rand].Norm : -L) : tileBlock[Rand].Norm);
            float LightCos = abs(dot(L, LightNorm));
            float w;
            int LightMeshIndex = 0;
            [branch]if(tileBlock[Rand].Misc.z == -1) {
                float SA = LightCos * tileBlock[Rand].PDFArea.y / Dist;
                float NEE_pdf = (1.0f / (LightMeshCount * SA)) * tileBlock[Rand].PDFArea.x * LightTriPDFAddtion;
                float bsdf_pdf = dot(L, Norm) / PI;
                w = length((tileBlock[Rand].Rad * bsdf_pdf) / NEE_pdf);
                LightMeshIndex = tileBlock[Rand].Misc.x;
                } else {
                float NEE_pdf = Dist * LightCos / (tileBlock[Rand].PDFArea.x) * LightPDFAddtion;//PI is cuz of area
                float bsdf_pdf = dot(L, Norm) / PI;
                float Attenuation = 1.0f;
                if(tileBlock[Rand].Misc.z == 2) {
                    Attenuation = saturate(dot(L, -LightNorm) * _UnityLights[tileBlock[Rand].Misc.y].SpotAngle.x + _UnityLights[tileBlock[Rand].Misc.y].SpotAngle.y);
                }
                w = length((tileBlock[Rand].Rad * bsdf_pdf) / NEE_pdf) * Attenuation;
                LightMeshIndex = -tileBlock[Rand].Misc.z - 1;
            }
            UpdateReservoir(reservoir, tileBlock[Rand].Misc.y, w, random(34 + i).x, LightMeshIndex, LightPos, LightNorm);
        }   

        } else {
            int LightCount = unitylightcount;
            for(i = 0; i < min(lightsamplecount, LightCount); i++) {
                int lighttosample;
                float w;
                int LightMesh = 0;
                float3 LightNorm;
                float3 lightPos;
                float rand1 = random(43).x;
            lighttosample = SelectUnityLight(float2(rand1, random(43).y));//floor(min(float(rand_xorshift()) * MultiplyData * LightCount, LightCount - 1));
            LightData light = _UnityLights[lighttosample];
            lightPos = (light.Type == 1) ? (WorldPosition - light.Direction) : light.Position;
            float3 L = (lightPos - WorldPosition);
            float Dist = dot(L, L);
            L /= sqrt(Dist);
            LightNorm = -L;
            LightMesh = -1;
            float LightCos = abs(dot(L, LightNorm));
            float Attenuation = 1;
            if(light.Type  == 2) {
                Attenuation = saturate(dot(L, -LightNorm) * light.SpotAngle.x + light.SpotAngle.y);
            }
            float NEE_pdf = Dist * LightCos / (unitylightcount) * (light.CDF / (_UnityLights[unitylightcount - 1].CDF));
            float bsdf_pdf = dot(L, Norm) / PI;
            w = length((light.Radiance * bsdf_pdf) / NEE_pdf) * Attenuation;

            UpdateReservoir(reservoir, lighttosample, w, float(rand_xorshift()) * MultiplyData, -light.Type - 1, lightPos, (light.Type == 2) ? light.Direction : LightNorm);

        }
        LightCount = lighttricount;

        for(i = 0; i < min(LightCount, lightsamplecount); i++) {//Look through light triangles
            int lighttosample;
            float w;
            float3 LightNorm;
            float3 lightPos;
            const uint LightMeshIndex = floor(min(float(rand_xorshift()) * MultiplyData * LightMeshCount, LightMeshCount - 1));
            const LightMeshData LightMesh = _LightMeshes[LightMeshIndex];
            float rand1 = float(rand_xorshift()) * MultiplyData;
            lighttosample = SelectLight(LightMeshIndex, float2(rand1, float(rand_xorshift()) * MultiplyData));// clamp((float(rand_xorshift()) * MultiplyData * (IndexEnd - StartIndex)) + StartIndex, StartIndex, IndexEnd - 1);
            const LightTriangleData Light = LightTriangles[lighttosample];
            float rand = float(rand_xorshift()) * MultiplyData;
            float2 CurUv = sample_triangle(rand, float(rand_xorshift()) * MultiplyData);
            lightPos = mul(LightMesh.Inverse, float4(Light.pos0 + CurUv.x * Light.posedge1 + CurUv.y * Light.posedge2,1)).xyz;
            LightNorm = normalize(mul(LightMesh.Inverse, float4(Light.Norm, 0.0f)).xyz);
            float3 L = lightPos - WorldPosition;
            float Dist = abs(dot(L, L));
            L /= sqrt(Dist);
            float LightCos = abs(dot(L, LightNorm));
            float SA = LightCos * LightTriangles[lighttosample].area / Dist;
            float NEE_pdf = (1.0f / (LightMeshCount * SA)) * (LightTriangles[lighttosample].pdf / LightMesh.pdf);
            float bsdf_pdf = dot(L, Norm) / PI;
            w = length((Light.radiance * bsdf_pdf) / NEE_pdf);

            UpdateReservoir(reservoir, lighttosample, w, float(rand_xorshift()) * MultiplyData, LightMeshIndex, lightPos, LightNorm);

        }

    }

    float p_hat;
    if(reservoir.MeshIndex >= 0) {
        float3 lightPos = reservoir.Position;
        float3 L = lightPos - WorldPosition;
        float Dist = dot(L, L);
        L /= sqrt(Dist);
        float LightCos = abs(dot(L, reservoir.Norm));
        float SA = LightCos * LightTriangles[reservoir.y].area / Dist;
        float NEE_pdf = (1.0f / (LightMeshCount * SA)) * (LightTriangles[reservoir.y].pdf / _LightMeshes[reservoir.MeshIndex].pdf);
        float bsdf_pdf = dot(L, Norm) / PI;
        p_hat = length((LightTriangles[reservoir.y].radiance * bsdf_pdf) / NEE_pdf);
        } else {
            LightData light = _UnityLights[reservoir.y];
            float3 lightPos = reservoir.Position;
            float3 L = lightPos - WorldPosition;
            float Dist = dot(L, L);
            L /= sqrt(Dist);
            float LightCos = abs(dot(L, reservoir.Norm));
            float NEE_pdf = Dist * LightCos / (unitylightcount) * (_UnityLights[unitylightcount - 1].CDF / (_UnityLights[unitylightcount - 1].CDF + _LightMeshes[LightMeshCount - 1].CDF));
            float bsdf_pdf = dot(L, Norm) / PI;
            p_hat = length((light.Radiance * bsdf_pdf) / NEE_pdf);
        }
    reservoir.W = reservoir.wsum / max(p_hat * reservoir.M,0.00001f);//(1.0f / max(p_hat, 0.00001f)) * (reservoir.wsum / max(reservoir.M, 0.0000001f));


    if(UseRestirTemporal) {
        float Dist1 = length(WorldPosition - camPos);
        float Dist2 = length(prevReservoir.PrevWorld - camPos);
        if(abs(Dist1 - Dist2) / abs(Dist1) < 0.1f) {
            float normalDot = dot(Norm, prevReservoir.PrevNorm);
            if(normalDot > 0.5f) {
                float3 lightPos;
                float p_hat;
                    if(prevReservoir.MeshIndex >= 0) {
                        lightPos = prevReservoir.Position;
                        float3 L = lightPos - WorldPosition;
                        float Dist = dot(L, L);
                        L /= sqrt(Dist);
                        float LightCos = abs(dot(L, prevReservoir.Norm));
                        float SA = LightCos * LightTriangles[prevReservoir.y].area / Dist;
                        float NEE_pdf = (1.0f / (LightMeshCount * SA)) * (LightTriangles[prevReservoir.y].pdf / _LightMeshes[prevReservoir.MeshIndex].pdf);
                        float bsdf_pdf = dot(L, Norm) / PI;
                        p_hat = length((LightTriangles[prevReservoir.y].radiance * bsdf_pdf) / NEE_pdf);
                    } else {
                        LightData light = _UnityLights[prevReservoir.y];
                        lightPos = prevReservoir.Position;
                        float3 L = lightPos - WorldPosition;
                        float Dist = dot(L, L);
                        L /= sqrt(Dist);
                        float LightCos = abs(dot(L, prevReservoir.Norm));
                        float NEE_pdf = Dist * LightCos / (unitylightcount) * (_UnityLights[unitylightcount - 1].CDF / (_UnityLights[unitylightcount - 1].CDF + _LightMeshes[LightMeshCount - 1].CDF));
                        float bsdf_pdf = dot(L, Norm) / PI;
                        float Attenuation = 1;
                        if(light.Type  == 2) {
                            Attenuation = saturate(dot(L, -light.Direction) * light.SpotAngle.x + light.SpotAngle.y);
                        }
                        p_hat = length((light.Radiance * bsdf_pdf) / NEE_pdf) * Attenuation;
                    }
                    prevReservoir.M = min(prevReservoir.M, 320);
                    UpdateReservoir(reservoir, prevReservoir.y, p_hat * prevReservoir.W * prevReservoir.M, random(43).x, prevReservoir.MeshIndex, prevReservoir.Position, prevReservoir.Norm, prevReservoir);

                    reservoir.M = prevReservoir.M + reservoir.M - 1;

                    if(reservoir.MeshIndex >= 0) {
                        lightPos = reservoir.Position;
                        float3 L = lightPos - WorldPosition;
                        float Dist = dot(L, L);
                        L /= sqrt(Dist);
                        float LightCos = abs(dot(L, reservoir.Norm));
                        float SA = LightCos * LightTriangles[reservoir.y].area / Dist;
                        float NEE_pdf = (1.0f / (LightMeshCount * SA)) * (LightTriangles[reservoir.y].pdf / _LightMeshes[reservoir.MeshIndex].pdf);
                        float bsdf_pdf = dot(L, Norm) / PI;
                        p_hat = length((LightTriangles[reservoir.y].radiance * bsdf_pdf) / NEE_pdf);
                        } else {
                            LightData light = _UnityLights[reservoir.y];
                            lightPos = reservoir.Position;
                            float3 L = lightPos - WorldPosition;
                            float Dist = dot(L, L);
                            L /= sqrt(Dist);
                            float LightCos = abs(dot(L, reservoir.Norm));
                            float NEE_pdf = Dist * LightCos / (unitylightcount) * (_UnityLights[unitylightcount - 1].CDF / (_UnityLights[unitylightcount - 1].CDF + _LightMeshes[LightMeshCount - 1].CDF));
                            float bsdf_pdf = dot(L, Norm) / PI;
                            p_hat = length((light.Radiance * bsdf_pdf) / NEE_pdf);
                        }
                    reservoir.W = (1.0f / max(reservoir.M,0.0001f)) * reservoir.wsum / max(p_hat,0.00001f); //reservoir.wsum / (p_hat * reservoir.M);
                }
            }
        }

        if(UseSpatial) {
            int2 CenterIndex = prevIndex;

            uint2 neighborOffset;
            uint2 neighborIndex;
            float WorldDepth = length(WorldPosition - camPos);
            for (int i = 0; i < spatialsamplecount;i++) {
                float radius = 30 * random(i).x;
                float angle = 2.0f * PI * random(i).y;

                int2 neighborIndex = round(CenterIndex + radius * float2(cos(angle), sin(angle)));

                if (neighborIndex.x < 0 || neighborIndex.x >= (int)screen_width || neighborIndex.y < 0 || neighborIndex.y >= (int)screen_height)
                {
                    continue;
                }
                Reservoir neighborRes = PreviousReservoir[neighborIndex.y * uint(screen_width) + neighborIndex.x];           
                float Depth = length(neighborRes.PrevWorld - camPos);
                if (
                    abs(Depth - WorldDepth) / abs(Depth) >= 0.1f || 
                    dot(neighborRes.PrevNorm, Norm) < 0.5f
                    ) {
                    continue;
                }
                neighborRes.M = min(neighborRes.M, SpatialMCap);
                float p_hat;
                if(neighborRes.MeshIndex >= 0) {
                    float3 lightPos = neighborRes.Position;
                    float3 L = lightPos - WorldPosition;
                    float Dist = dot(L, L);
                    L /= sqrt(Dist);
                    float LightCos = abs(dot(L, neighborRes.Norm));
                    float SA = LightCos * LightTriangles[neighborRes.y].area / Dist;
                    float NEE_pdf = (1.0f / (LightMeshCount * SA)) * (LightTriangles[neighborRes.y].pdf / _LightMeshes[neighborRes.MeshIndex].pdf);
                    float bsdf_pdf = dot(L, Norm) / PI;
                    p_hat = length((LightTriangles[neighborRes.y].radiance * bsdf_pdf) / NEE_pdf);
                    } else {
                        LightData light = _UnityLights[neighborRes.y];
                        float3 L = neighborRes.Position - WorldPosition;
                        float Dist = dot(L, L);
                        L /= sqrt(Dist);
                        float LightCos = abs(dot(L, neighborRes.Norm));
                        float NEE_pdf = Dist * LightCos / (unitylightcount) * (_UnityLights[unitylightcount - 1].CDF / (_UnityLights[unitylightcount - 1].CDF + _LightMeshes[LightMeshCount - 1].CDF));
                        float bsdf_pdf = dot(L, Norm) / PI;
                        float Attenuation = 1;
                        if(light.Type  == 2) {
                            Attenuation = saturate(dot(L, -neighborRes.Norm) * light.SpotAngle.x + light.SpotAngle.y);
                        }
                        p_hat = length((light.Radiance * bsdf_pdf) / NEE_pdf) * Attenuation;
                    }
                    UpdateReservoir(reservoir, neighborRes.y, p_hat * neighborRes.M * neighborRes.W, random(i + 16).x, neighborRes.MeshIndex, neighborRes.Position, neighborRes.Norm, neighborRes);  
                    reservoir.M = reservoir.M + neighborRes.M - 1;  

                }

                float p_hat;

                float3 lightPos;
                if(reservoir.MeshIndex >= 0) {
                    lightPos = reservoir.Position;
                    float3 L = lightPos - WorldPosition;
                    float Dist = dot(L, L);
                    L /= sqrt(Dist);
                    float LightCos = abs(dot(L, reservoir.Norm));
                    float SA = LightCos * LightTriangles[reservoir.y].area / Dist;
                    float NEE_pdf = (1.0f / (LightMeshCount * SA)) * (LightTriangles[reservoir.y].pdf / _LightMeshes[reservoir.MeshIndex].pdf);
                    float bsdf_pdf = dot(L, Norm) / PI;
                    p_hat = length((LightTriangles[reservoir.y].radiance * bsdf_pdf) / NEE_pdf);
                    } else {
                        LightData light = _UnityLights[reservoir.y];
                        lightPos = reservoir.Position;
                        float3 L = lightPos - WorldPosition;
                        float Dist = dot(L, L);
                        L /= sqrt(Dist);
                        float LightCos = abs(dot(L, reservoir.Norm));
                        float NEE_pdf = Dist * LightCos / (unitylightcount) * (_UnityLights[unitylightcount - 1].CDF / (_UnityLights[unitylightcount - 1].CDF + _LightMeshes[LightMeshCount - 1].CDF));
                        float bsdf_pdf = dot(L, Norm) / PI;
                        p_hat = length((light.Radiance * bsdf_pdf) / NEE_pdf);
                    }
        reservoir.W = (1.0f / max(reservoir.M,0.00001f)) * reservoir.wsum / p_hat; //reservoir.wsum / (p_hat * reservoir.M);
    }
    if(reservoir.y == -1 || !(reservoir.W > 0 || reservoir.W < 0 || reservoir.W == 0)) {
        reservoir.y = -1;
        reservoir.W = 0;
        reservoir.wsum = 0;
        reservoir.M = 0;
    }

    reservoir.PrevWorld = WorldPosition;
    reservoir.PrevNorm = Norm;
    CurrentReservoir[id.y * screen_width + id.x] = reservoir;


}

RWStructuredBuffer<LightBlockData> WriteBlocks;


#pragma kernel kernel_reservoir_precompute

[numthreads(64,1,1)]
void kernel_reservoir_precompute (uint3 id : SV_DispatchThreadID, uint3 id2 : SV_GroupThreadID, uint3 id3 : SV_GroupID) {//Moved final accumulation into its own kernel, improves performance
    rng_state = (id.x + id.y * screen_width);
    pixel_index = rng_state;
    for(int i = 0; i < 8; i++) {
        bool UseUnityLight = (unitylightcount != 0) ? (LightMeshCount != 0) ? (random(i).x <= (_UnityLights[unitylightcount - 1].CDF / (_UnityLights[unitylightcount - 1].CDF + _LightMeshes[LightMeshCount - 1].CDF))) : true : false;//Choose whether to sample unity lights or mesh lights based off which is more powerful
        int lighttosample;
        float w;
        int LightMesh = 0;
        float3 LightNorm;
        float3 lightPos;
        int LightMeshIndex;
        float3 Radiance;
        int LightType = -1;
        float PDF;
        float Area = 0;
        if(UseUnityLight) {
            lighttosample = floor(min(random(i).y * unitylightcount, unitylightcount - 1));
            LightData light = _UnityLights[lighttosample];
            lightPos = light.Position;
            LightNorm = -light.Direction;
            Radiance = light.Radiance;
            LightMeshIndex = -1;
            LightType = light.Type;
            PDF = (_UnityLights[lighttosample].CDF / (_UnityLights[unitylightcount - 1].CDF) * unitylightcount);
        } else {
            LightMeshIndex = floor(min(random(i + 16).x * LightMeshCount, LightMeshCount - 1));
            const LightMeshData LightMesh = _LightMeshes[LightMeshIndex];
            lighttosample = SelectLight(LightMeshIndex, random(i + 36));// clamp((random(i + 16).y * (IndexEnd - StartIndex)) + StartIndex, StartIndex, IndexEnd - 1);
            const LightTriangleData Light = LightTriangles[lighttosample];
            float2 CurUv = sample_triangle(random(i + 32).x, random(i + 32).y);
            lightPos = mul(LightMesh.Inverse, float4(Light.pos0 + CurUv.x * Light.posedge1 + CurUv.y * Light.posedge2,1)).xyz;
            LightNorm = normalize(mul(LightMesh.Inverse, float4(Light.Norm, 0.0f)).xyz);
            Radiance = Light.radiance;
            Area =  Light.area;
            PDF = (LightTriangles[lighttosample].pdf / _LightMeshes[LightMeshIndex].pdf);
        }
        WriteBlocks[id2.x * 8 + i + id3.x * 512].Pos = lightPos;
        WriteBlocks[id2.x * 8 + i + id3.x * 512].Norm = LightNorm;
        WriteBlocks[id2.x * 8 + i + id3.x * 512].Rad = Radiance;
        WriteBlocks[id2.x * 8 + i + id3.x * 512].Misc = float3(LightMeshIndex, lighttosample, LightType);
        WriteBlocks[id2.x * 8 + i + id3.x * 512].PDFArea = float2(PDF, Area);
    }
}


#pragma kernel kernel_GI_Reserviour

void UpdateReservoir(inout GIReservoir A, GIReservoir B, float w, float rndnum, inout float wsum) {
    A.M += B.M + 1;
    wsum += w;
    if (rndnum < (w/wsum)) {
        A.SecondaryHitPosition = B.SecondaryHitPosition;
        A.HistoricID = B.HistoricID;
        A.HistoricFrame = B.HistoricFrame;
        A.RadianceDirect = B.RadianceDirect;
        A.RadianceIndirect = B.RadianceIndirect;
        A.NEERay = B.NEERay;
        A.SecondaryHitDirectionOut = B.SecondaryHitDirectionOut;
        A.RadianceIncomming = B.RadianceIncomming;
        A.BaseColor = B.BaseColor;
        A.ThisCase = B.ThisCase;
        A.NEEPosition = B.NEEPosition;
    }

}

bool UseReSTIRGISpatial;
bool UseReSTIRGITemporal;
int ReSTIRGISpatialCount;
bool DoReSTIRGIConnectionValidation;
bool AbandonSamples;
int ReSTIRGITemporalMCap;
bool SpatialStabalizer;
float3 PrevCamPos;
float3 CamPos;
float3 cameraForward;
float4x4 inverseview;
float4x4 prevviewmatrix;

float3 proj_point_in_plane(float3 p, float3 v0, float3 n, out float d) {
   d = dot(n, p - v0);
   return p - (n * d);
}

float3 find_reflection_incident_point(float3 p0, float3 p1, float3 v0, float3 n) {
   float d0 = 0;
   float d1 = 0;
   float3 proj_p0 = proj_point_in_plane(p0, v0, n, d0);
   float3 proj_p1 = proj_point_in_plane(p1, v0, n, d1);

   if(d1 < d0)
   return (proj_p0 - proj_p1) * d1/(d0+d1) + proj_p1;
   else
   return (proj_p1 - proj_p0) * d0/(d0+d1) + proj_p0;
}
float3 InvProjectPosition(float3 coord, float4x4 mat) {
     // coord.y = (1 - coord.y);
     // coord.xy = 2 * coord.xy - 1;
     float4 projected = mul(mat, float4(coord, 1));
     projected.xyz /= projected.w;
     return projected.xyz;
}

Texture2D<float4> PrevPosTex;

float2 find_previous_reflection_position(
    float2 ss_pos, float2 ss_ray,
    float2 surface_motion_vector, float2 reflection_motion_vector,
    float3 world_normal, float camlength) {
    float3 ss_p0 = 0;
    ss_p0.xy = ss_pos.xy - surface_motion_vector;
    ss_p0.z = PrevPosTex[ss_p0.xy * float2(screen_width, screen_height)].w;

    float3 ss_p1 = 0;
    ss_p1.xy = ss_ray.xy - reflection_motion_vector;
    ss_p1.z = PrevPosTex[ss_p1.xy * float2(screen_width, screen_height)].w;

    float3 view_n = world_normal;//normalize(mul(prevviewmatrix, float4(world_normal, 0)));
    float3 view_p0 = float3(0,0,0);
    float3 view_v0 = InvProjectPosition(ss_p0, _CameraInverseProjection);// mul(_CameraInverseProjection, float4(ss_p0, 1)).xyz / mul(_CameraInverseProjection, float4(ss_p0, 1)).w;
    float3 view_p1 = InvProjectPosition(ss_p1, _CameraInverseProjection);//mul(_CameraInverseProjection, float4(ss_p1, 1)).xyz / mul(_CameraInverseProjection, float4(ss_p1, 1)).w;

    float3 view_intersection = 
    find_reflection_incident_point(view_p0, view_p1, view_v0, view_n);
    float4 ss_intersection = mul(float4(view_intersection, 1), _CameraInverseProjection);//view_to_ss(view_intersection, 1);

    return ss_intersection.xy / ss_intersection.w;
}

float EvalPHat(const GIReservoir TargetRes, float3 bsdfVal, float3 NEEbsdfVal, float bsdfpdf, float NEEbsdfpdf) {
    return luminance((TargetRes.RadianceDirect + TargetRes.RadianceIndirect) * bsdfVal + TargetRes.NEERay * NEEbsdfVal) * step(0, bsdfpdf) * step(0, NEEbsdfpdf);
}


    const static int2 offsets[4] = {
        int2(-1, -1),
        int2(1, 1),
        int2(-1, 1),
        int2(1, -1),
    };
    const static uint2 xor_seq[4] = {
        uint2(3, 3),
        uint2(2, 1),
        uint2(1, 2),
        uint2(3, 3),
    };

int2 get_rpx_offset(uint sample_i, uint frame_index) {

    const int2 reservoir_px_offset_base =
    offsets[frame_index & 3]
    + offsets[(sample_i + (frame_index ^ 1)) & 3];

    return
    sample_i == 0
    ? 0
    : int2(reservoir_px_offset_base)
    ;
}
bool UpdateReservoir2(inout GIReservoir A, GIReservoir B, float w, float rndnum, inout float wsum) {
    A.M += B.M;
    wsum += w;
    if (rndnum < (w/wsum)) {
        A.SecondaryHitPosition = B.SecondaryHitPosition;
        A.HistoricID = B.HistoricID;
        A.HistoricFrame = B.HistoricFrame;
        A.RadianceDirect = B.RadianceDirect;
        A.RadianceIndirect = B.RadianceIndirect;
        A.NEERay = B.NEERay;
        A.SecondaryHitDirectionOut = B.SecondaryHitDirectionOut;
        A.RadianceIncomming = B.RadianceIncomming;
        A.BaseColor = B.BaseColor;
        A.ThisCase = B.ThisCase;
        A.NEEPosition = B.NEEPosition;
        return true;
    }
    return false;

}

[numthreads(12,12,1)]
void kernel_GI_Reserviour (uint3 id : SV_DispatchThreadID, uint3 id2 : SV_GroupThreadID, uint3 id3 : SV_GroupID, uint id4 : SV_GroupIndex) {
    if(id.x >= screen_width || id.x < 0 || id.y >= screen_height || id.x < 0) return;
    int index = id.x + id.y * screen_width;
    pixel_index = index;
    GIReservoir CurrentRes = CurrentReservoirGI[index];
    float3 PrimaryHitPosition = TempPosTex[id.xy].xyz;
    Ray ray = CreateCameraRay(id.xy / float2(screen_width, screen_height) * 2.0f - 1.0f);
    // float CurDist = length(ray.direction / dot(ray.direction, Forward) * LinearEyeDepth(Depth.SampleLevel(my_linear_clamp_sampler, id.xy / float2(screen_width, screen_height), 0).x));
    if(ReSTIRGIUpdateRate == 0) {
        CurrentRes.RadianceDirect = GlobalColors[id.x + id.y * screen_width].Direct;
        CurrentRes.RadianceIndirect = GlobalColors[id.x + id.y * screen_width].Indirect;
    }
    GIReservoir prevReservoir = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};

    MaterialData TempMat = _Materials[(int)CurrentRes.MaterialIndex.x];
    const PerMatInfo MatModifier = MatModifiers[index];
    HitMat hitmat;
    hitmat.surfaceColor = MatModifier.Albedo;
    hitmat.emmis = TempMat.emmissive;
    hitmat.roughness = MatModifier.Roughness;
    hitmat.MatType = TempMat.MatType;
    hitmat.metallic = MatModifier.Metallic;
    hitmat.ior = TempMat.ior;
    hitmat.specTrans = TempMat.specTrans;
    hitmat.specularTint = TempMat.specularTint;
    hitmat.clearcoat = MatModifier.Clearcoat;
    hitmat.clearcoatGloss = MatModifier.ClearCoatGloss;
    hitmat.diffTrans = TempMat.diffTrans;
    hitmat.sheen = TempMat.sheen;
    hitmat.sheenTint = TempMat.sheenTint;
    hitmat.anisotropic = TempMat.anisotropic;
    hitmat.flatness = TempMat.flatness;
    hitmat.transmittanceColor = TempMat.transmittanceColor;    
    hitmat.phaseFunction = 0;
    hitmat.extinction = 0;
    hitmat.relativeIOR = TempMat.ior;
    hitmat.Thin = TempMat.Thin;
    hitmat.scatterDistance = 0;
    hitmat.Specular = MatModifier.Specular;

    bool ActuallyRender = (RenderMaskTex[id.xy] == 1);
    float2 UV = id.xy / float2(screen_width, screen_height);
    const float3 Norm = normalize(NormalTex.SampleLevel(sampler_NormalTex, UV, 0).xyz * 2.0f - 1.0f);
    const float3x3 NormTangentSpace = GetTangentSpace2(Norm);
    const float3 GeomNorm = unpackUnormArb(TempNormTex[id.xy]);
    bool SuccessfullyReprojected = false;
    float2 MotionVector = MotionVectors.SampleLevel(my_linear_clamp_sampler, UV, 0).xy;


    uint2 prevIndex;
    #ifdef UseReflectionReproject 
        if(CurrentRes.ThisCase.x == 0 && hitmat.roughness < 0.15f) {
            float4 curprojectedrefl = mul(viewprojection, float4(CamPos + normalize(PrimaryHitPosition - CamPos) * (TempPosTex[id.xy].w + length(PrimaryHitPosition - CamPos)), 1));
            float4 prevprojectedrefl = mul(prevviewprojection, float4(CamPos + normalize(PrimaryHitPosition - CamPos) * (TempPosTex[id.xy].w + length(PrimaryHitPosition - CamPos)), 1));
            float2 reflprojection = ((curprojectedrefl.xy / curprojectedrefl.w) - (prevprojectedrefl.xy / prevprojectedrefl.w)) * 0.5f;
            MotionVector = reflprojection;
        }
    #endif
    int2 ID = id.xy;
    prevIndex = int2(floor(((float2(ID.xy) + 0.5) * float2(rcp(screen_width), rcp(screen_height))- MotionVector) * float2(screen_width, screen_height)));
    if (prevIndex.x >= 0 && prevIndex.x < screen_width && prevIndex.y >= 0 && prevIndex.y < screen_height) {
        prevReservoir = PreviousReservoirGI[prevIndex.y * screen_width + prevIndex.x];
        SuccessfullyReprojected = true;
    }
    float3 minCol = 9999.0f;
    float3 maxCol = -9999.0f;

    if(UsePermutatedSamples) {
        [unroll]for(int x = -1; x <= 1; ++x) {
            [unroll]for(int y = -1; y <= 1; ++y) {
                int2 OffsetIndex = id.xy + int2(x,y);
                float3 color = CurrentReservoirGI[OffsetIndex.x + OffsetIndex.y * screen_width].BaseColor;
                minCol = min(minCol, color);
                maxCol = max(maxCol, color);
            }
        }
        if(!all(prevReservoir.BaseColor >= minCol && prevReservoir.BaseColor <= maxCol)) {prevReservoir.M = 0;}
    }

    PrimaryHitPosition  += GeomNorm  * 0.001f;
    if(ActuallyRender && !AbandonSamples) {
        float fpdf3;
        float3 bsdf_value;
        const float3 RayDir = normalize(PrimaryHitPosition - CamPos);
        float CurDist = Linear01Depth(Depth.SampleLevel(my_linear_clamp_sampler, UV, 0).x) * FarPlane;
        float p_q;
        float fpdf;
        float wsum = 0;
        bool Valid = ReconstructBsdf(hitmat, RayDir, normalize(CurrentRes.SecondaryHitPosition - PrimaryHitPosition), Norm, fpdf, bsdf_value, CurrentRes.ThisCase.x, NormTangentSpace);
        float3 bsdf_value2;
        float fpdf2;
        bsdf_value2 = EvaluateDisney(hitmat, -RayDir, normalize(CurrentRes.NEEPosition - PrimaryHitPosition), hitmat.Thin == 1, fpdf3, fpdf2, NormTangentSpace);
        p_q = EvalPHat(CurrentRes, bsdf_value, bsdf_value2, fpdf, fpdf3);

        if(ReSTIRGIUpdateRate != 0 && RandomNums[id.xy].z == 1) wsum = CurrentRes.W * CurrentRes.M;
        else wsum = p_q;
        if(!Valid) wsum = 0;
        if(!UsePermutatedSamples) {
            if(ReSTIRGIUpdateRate == 0 || RandomNums[id.xy].z != 1) {
                float PrevDist = PrevDepthTex[prevIndex].x;
                float DistDiff = ((abs(CurDist - PrevDist) - length(CamPos - PrevCamPos))) / CurDist;

                bool DoTemporal = DistDiff < 0.1f && (dot(unpackUnormArb(PrevNormalTex[prevIndex]), Norm) > 0.9f);
                if(DoTemporal && UseReSTIRGITemporal) {
                    if(ReSTIRGITemporalMCap != 0) prevReservoir.M = min(prevReservoir.M, ReSTIRGITemporalMCap);
                    Valid = ReconstructBsdf(hitmat, RayDir, normalize(prevReservoir.SecondaryHitPosition - PrimaryHitPosition), Norm, fpdf, bsdf_value, prevReservoir.ThisCase.x, NormTangentSpace);
                    bsdf_value2 = EvaluateDisney(hitmat, -RayDir, normalize(prevReservoir.NEEPosition - PrimaryHitPosition), hitmat.Thin == 1, fpdf3, fpdf2, NormTangentSpace);



                    Valid = Valid && all(bsdf_value < 0 || bsdf_value > 0 || bsdf_value == 0) && luminance(bsdf_value) < 100000.0f;
                    frames_accumulated++;
                    float Prev_p_q = EvalPHat(prevReservoir, bsdf_value, bsdf_value2, fpdf, fpdf3);
                    if(Valid)UpdateReservoir(CurrentRes, prevReservoir, max(Prev_p_q * prevReservoir.M * prevReservoir.W * Valid,0), random(23).x, wsum);
                    } else {
                        CurrentRes.M++;
                    }
            bsdf_value2 = EvaluateDisney(hitmat, -RayDir, normalize(CurrentRes.NEEPosition - PrimaryHitPosition), hitmat.Thin == 1, fpdf3, fpdf2, NormTangentSpace);


            Valid = ReconstructBsdf(hitmat, RayDir, normalize(CurrentRes.SecondaryHitPosition - PrimaryHitPosition), Norm, fpdf, bsdf_value, CurrentRes.ThisCase.x, NormTangentSpace);
            Valid = Valid && all(bsdf_value < 0 || bsdf_value > 0 || bsdf_value == 0) && luminance(bsdf_value) < 100000.0f;

            if(!Valid) return;

            p_q = EvalPHat(CurrentRes, bsdf_value, bsdf_value2, fpdf, fpdf3);
            CurrentRes.W = wsum / max((CurrentRes.M * p_q),0.00001f);
                }
        } else {
            const uint2 permutation_xor_val =
                xor_seq[frames_accumulated & 3];  
            ID = (ID + get_rpx_offset(0, frames_accumulated)) ^ permutation_xor_val;
            ID += get_rpx_offset(0, frames_accumulated);
            prevIndex = int2(floor(((float2(ID.xy) + 0.5) * float2(rcp(screen_width), rcp(screen_height))- MotionVector) * float2(screen_width, screen_height)));
            for(int i = 0; i < 4; i++) {
                int2 rpx_offset = get_rpx_offset(i, frames_accumulated);


                const uint2 xor_seq[4] = {
                    uint2(3, 3),
                    uint2(2, 1),
                    uint2(1, 2),
                    uint2(3, 3),
                };
                 // MotionVector =  MotionVectors.SampleLevel(my_linear_clamp_sampler, UV + rpx_offset / rcp(float2(screen_width, screen_height)), 0).xy;
                const uint2 permutation_xor_val =
                    xor_seq[frames_accumulated & 3];  
                const float2 reproj_rand_offset = 0.0;
                const int2 permuted_reproj_px = floor(
                (i == 0
                    ? id.xy
                    // My poor approximation of permutation sampling.
                    // https://twitter.com/more_fps/status/1457749362025459715
                    //
                    // When applied everywhere, it does nicely reduce noise, but also makes the GI less reactive
                    // since we're effectively increasing the lifetime of the most attractive samples.
                    // Where it does come in handy though is for boosting convergence rate for newly revealed
                    // locations.
                    : ((id.xy + rpx_offset) ^ permutation_xor_val))
                    - float2(screen_width, screen_height) * MotionVector.xy + reproj_rand_offset + 0.5);
                const int2 rpx = permuted_reproj_px + rpx_offset;

                if (rpx.x >= 0 && rpx.x < (int)screen_width && rpx.y >= 0 && rpx.y < (int)screen_height) {
                    prevReservoir = PreviousReservoirGI[rpx.y * screen_width + rpx.x];
                    SuccessfullyReprojected = true;
                }
                float PrevDist = PrevDepthTex[rpx].x;
                float DistDiff = ((abs(CurDist - PrevDist) - length(CamPos - PrevCamPos))) / CurDist;

                bool DoTemporal = DistDiff < 0.1f && (dot(unpackUnormArb(PrevNormalTex[rpx]), Norm) > 0.9f);
                if(DoTemporal && UseReSTIRGITemporal) {
                    if(ReSTIRGITemporalMCap != 0) prevReservoir.M = min(prevReservoir.M, ReSTIRGITemporalMCap);
                    Valid = ReconstructBsdf(hitmat, RayDir, normalize(prevReservoir.SecondaryHitPosition - PrimaryHitPosition), Norm, fpdf, bsdf_value, prevReservoir.ThisCase.x, NormTangentSpace);
                    bsdf_value2 = EvaluateDisney(hitmat, -RayDir, normalize(prevReservoir.NEEPosition - PrimaryHitPosition), hitmat.Thin == 1, fpdf3, fpdf2, NormTangentSpace);



                    Valid = Valid && all(bsdf_value < 0 || bsdf_value > 0 || bsdf_value == 0) && luminance(bsdf_value) < 100000.0f && (abs(hitmat.metallic - MatModifiersPrev[rpx.x + rpx.y * screen_width].Metallic) <= 0.05f);
                    frames_accumulated++;
                    float Prev_p_q = EvalPHat(prevReservoir, bsdf_value, bsdf_value2, fpdf, fpdf3);
                    if(Valid)if(UpdateReservoir2(CurrentRes, prevReservoir, max(Prev_p_q * prevReservoir.M * prevReservoir.W * Valid,0), random(23 + i).x, wsum)) prevIndex = rpx;
                }
                if(CurrentRes.M > 12) break;
            }
               CurrentRes.M++; 
            bsdf_value2 = EvaluateDisney(hitmat, -RayDir, normalize(CurrentRes.NEEPosition - PrimaryHitPosition), hitmat.Thin == 1, fpdf3, fpdf2, NormTangentSpace);


            Valid = ReconstructBsdf(hitmat, RayDir, normalize(CurrentRes.SecondaryHitPosition - PrimaryHitPosition), Norm, fpdf, bsdf_value, CurrentRes.ThisCase.x, NormTangentSpace);
            Valid = Valid && all(bsdf_value < 0 || bsdf_value > 0 || bsdf_value == 0) && luminance(bsdf_value) < 100000.0f;

            if(!Valid) return;

            p_q = EvalPHat(CurrentRes, bsdf_value, bsdf_value2, fpdf, fpdf3);
            CurrentRes.W = wsum / max((CurrentRes.M * p_q),0.00001f);
            #ifdef ExtraSampleValidation
            if(DoReSTIRGIConnectionValidation) {
                float Distance = length(PrimaryHitPosition - (CurrentRes.SecondaryHitPosition)) - 0.001f;
                Ray ray = CreateRay(PrimaryHitPosition + GeomNorm * 0.0001f,normalize(((CurrentRes.SecondaryHitPosition) - PrimaryHitPosition)));

                bool ConnectedlyVisable = VisabilityCheck(ray, Distance);
                if(!ConnectedlyVisable) {CurrentRes.W = 0; CurrentRes.M = 0;}
                if(all(CurrentRes.NEERay != 0)) {
                    Distance = length(PrimaryHitPosition - (CurrentRes.NEEPosition)) - 0.001f;
                    ray = CreateRay(PrimaryHitPosition + GeomNorm * 0.0001f,normalize(((CurrentRes.NEEPosition) - PrimaryHitPosition)));

                    ConnectedlyVisable = VisabilityCheck(ray, Distance);
                    if(!ConnectedlyVisable) {CurrentRes.NEERay = 0;}  
                }
            }
            #endif
           }
        
        int PrevM = CurrentRes.M;
        if((CurrentRes.W > 10)) {
            CurrentRes.W = 0;
        }
        CurrentReservoirGI[index] = CurrentRes;

        if(UseReSTIRGISpatial && !(SpatialStabalizer && RandomNums[id.xy].z == 1)) {
            uint2 CenterIndex = prevIndex;
            uint2 neighborOffset;
            uint2 neighborIndex;
            for (int i = 0; i < ReSTIRGISpatialCount;i++) {
                float radius = random(i).x * 30;
                float angle = 2.0f * PI * random(i).y;
                int2 neighborIndex = round(CenterIndex + radius * float2(cos(angle), sin(angle)));
                if (neighborIndex.x < 0 || neighborIndex.x >= (int)screen_width || neighborIndex.y < 0 || neighborIndex.y >= (int)screen_height) continue;
                GIReservoir neighborRes = PreviousReservoirGI[neighborIndex.y * uint(screen_width) + neighborIndex.x];   
                float PrevDist = PrevDepthTex[neighborIndex].x;        
                float DistDiff = (abs(CurDist - PrevDist)) / CurDist;
                if (
                    DistDiff >= 0.1f || 
                    dot(unpackUnormArb(PrevNormalTex[neighborIndex]), Norm) < 0.99f || (abs(hitmat.metallic - MatModifiersPrev[neighborIndex.x + neighborIndex.y * screen_width].Metallic) > 0.05f)
                    ) {
                    continue;
                }
                frames_accumulated++;
                Valid = ReconstructBsdf(hitmat, RayDir, normalize(neighborRes.SecondaryHitPosition - PrimaryHitPosition), Norm, fpdf, bsdf_value, neighborRes.ThisCase.x, NormTangentSpace);
                Valid = Valid && all(bsdf_value < 0 || bsdf_value > 0 || bsdf_value == 0) && luminance(bsdf_value) < 100000.0f;// && fpdf > 0.25f;
                if(!Valid) continue;
                bsdf_value2 = EvaluateDisney(hitmat, -RayDir, normalize(neighborRes.NEEPosition - PrimaryHitPosition), hitmat.Thin == 1, fpdf3, fpdf2, NormTangentSpace);
                if(SpatialStabalizer) {neighborRes.M = min(neighborRes.M, 12);}
                CurrentRes.M--;


                p_q = EvalPHat(neighborRes, bsdf_value, bsdf_value2, fpdf, fpdf3);
                UpdateReservoir(CurrentRes, neighborRes, max(p_q * neighborRes.M * neighborRes.W,0), random(i + 16).x, wsum);  
           }

           Valid = ReconstructBsdf(hitmat, RayDir, normalize(CurrentRes.SecondaryHitPosition - PrimaryHitPosition), Norm, fpdf, bsdf_value, CurrentRes.ThisCase.x, NormTangentSpace);
           Valid = Valid && all(bsdf_value < 0 || bsdf_value > 0 || bsdf_value == 0) && luminance(bsdf_value) < 100000.0f;
           if(!Valid) return;
           bsdf_value2 = EvaluateDisney(hitmat, -RayDir, normalize(CurrentRes.NEEPosition - PrimaryHitPosition), hitmat.Thin == 1, fpdf3, fpdf2, NormTangentSpace);
           
           p_q = EvalPHat(CurrentRes, bsdf_value, bsdf_value2, fpdf, fpdf3);
           CurrentRes.W = wsum / max((CurrentRes.M * p_q),0.00001f);
        }

        if((p_q == 0 || CurrentRes.M == 0) || CurrentRes.W > 10) {
            CurrentRes.W = 0;
        }

        if(DoReSTIRGIConnectionValidation) {
            float Distance = length(PrimaryHitPosition - (CurrentRes.SecondaryHitPosition)) - 0.001f;
            Ray ray = CreateRay(PrimaryHitPosition + GeomNorm * 0.0001f,normalize(((CurrentRes.SecondaryHitPosition) - PrimaryHitPosition)));

            bool ConnectedlyVisable = VisabilityCheck(ray, Distance);
            if(!ConnectedlyVisable) {CurrentRes.W = 0; CurrentRes.M = 0;}
            #ifdef ExtraSampleValidation
            if(all(CurrentRes.NEERay != 0)) {
                Distance = length(PrimaryHitPosition - (CurrentRes.NEEPosition)) - 0.001f;
                ray = CreateRay(PrimaryHitPosition + GeomNorm * 0.0001f,normalize(((CurrentRes.NEEPosition) - PrimaryHitPosition)));

                ConnectedlyVisable = VisabilityCheck(ray, Distance);
                if(!ConnectedlyVisable) {CurrentRes.NEERay = 0;}  
            }
            #endif
        }

        if(SpatialStabalizer) CurrentReservoirGI[index] = CurrentRes;

        CurrentRes.W = clamp(CurrentRes.W, 0, 1);
        if(SuccessfullyReprojected) {
            bsdf_value2 = EvaluateDisney(hitmat, -RayDir, normalize(CurrentRes.NEEPosition - PrimaryHitPosition), hitmat.Thin == 1, fpdf3, fpdf2, NormTangentSpace);

            Valid = ReconstructBsdf(hitmat, RayDir, normalize(CurrentRes.SecondaryHitPosition - PrimaryHitPosition), Norm, fpdf, bsdf_value, CurrentRes.ThisCase.x, NormTangentSpace);
            Valid = Valid && all(bsdf_value < 0 || bsdf_value > 0 || bsdf_value == 0) && luminance(bsdf_value) < 100000.0f;
            if(Valid) TempAlbedoTex[id.xy] = float4(abs(bsdf_value),1);
            GlobalColors[id.x + id.y * screen_width].Direct = CurrentRes.RadianceDirect * CurrentRes.W; 
            GlobalColors[id.x + id.y * screen_width].Indirect = CurrentRes.RadianceIndirect * CurrentRes.W;
            GlobalColors[id.x + id.y * screen_width].PrimaryNEERay = (all(CurrentRes.NEERay * CurrentRes.W * bsdf_value2 < 1000000) ? CurrentRes.NEERay * CurrentRes.W * bsdf_value2 : 0);

            SHData ThisSH = init_SH();
            accumulate_SH(ThisSH, irradiance_to_SH(CurrentRes.RadianceIndirect * CurrentRes.W * 1024, clamp(normalize(CurrentRes.SecondaryHitPosition - PrimaryHitPosition),-1,1)), 1.0f);
            SH[id.x + id.y * screen_width] = ThisSH;
        }
    } else {
       CurrentReservoirGI[index] = CurrentRes;
    }



}


#pragma kernel forwardprojectionkernel


[numthreads(16,16,1)]
void forwardprojectionkernel (uint3 id : SV_DispatchThreadID, uint3 id2 : SV_GroupThreadID, uint3 id3 : SV_GroupID, uint id4 : SV_GroupIndex) {

    if(RandomNums[id.xy].w == 1 && !AbandonSamples) return;
    RandomNums[id.xy] = float4(curframe, id.x + id.y * screen_width, 0, 0);
    float2 uv = float2((id.xy) / float2(screen_width, screen_height) * 2.0f - 1.0f);
    Ray ray = CreateCameraRay(uv);

    Rays[id.x + id.y * screen_width] = ray;

    if(ReSTIRGIUpdateRate != 0 && (id.x + id.y * screen_width) % ReSTIRGIUpdateRate == (uint)curframe % (uint)ReSTIRGIUpdateRate && RenderMaskTex[id.xy].x == 1) {
        float2 uv = id.xy / float2(screen_width, screen_height);
        float2 pos_prev = ((float2(id.xy) + 0.5) * float2(rcp(screen_width), rcp(screen_height)) - MotionVectors.SampleLevel(sampler_MotionVectors, uv, 0).xy) * float2(screen_width, screen_height);
        int2 pp = int2(floor(pos_prev));
        if(pp.x > 0 && pp.x < (int)screen_width && pp.y > 0 && pp.y < (int)screen_height) {
            RandomNums[id.xy] = float4(CurrentReservoirGI[pp.x + pp.y * screen_width].HistoricFrame, CurrentReservoirGI[pp.x + pp.y * screen_width].HistoricID, 1, 0);
        }
    }




}

#pragma kernel ValidateGI


[numthreads(16,16,1)]
void ValidateGI (uint3 id : SV_DispatchThreadID, uint3 id2 : SV_GroupThreadID, uint3 id3 : SV_GroupID, uint id4 : SV_GroupIndex) {

    GIReservoir CurrentRes = CurrentReservoirGI[id.x + id.y * screen_width];
    CurrentRes.RadianceDirect = GlobalColors[id.x + id.y * screen_width].Direct;
    CurrentRes.RadianceIndirect = GlobalColors[id.x + id.y * screen_width].Indirect;

    if(ReSTIRGIUpdateRate != 0 && RandomNums[id.xy].z == 1) {
        float2 uv = id.xy / float2(screen_width, screen_height);
        float2 pos_prev = ((float2(id.xy) + 0.5) * float2(rcp(screen_width), rcp(screen_height)) - MotionVectors.SampleLevel(sampler_MotionVectors, uv, 0).xy) * float2(screen_width, screen_height);
        int2 prevIndex = int2(floor(pos_prev));        
        if (prevIndex.x >= 0 && prevIndex.x < (int)screen_width && prevIndex.y >= 0 && prevIndex.y < (int)screen_height)
        {
            GIReservoir prevReservoir = PreviousReservoirGI[prevIndex.y * screen_width + prevIndex.x];
            if(abs(CurrentRes.RadianceIncomming - prevReservoir.RadianceIncomming) > 0.001f) {
                prevReservoir.RadianceDirect = 0; 
                prevReservoir.RadianceIndirect = 0;
                prevReservoir.NEERay = 0;
                prevReservoir.M = 0; 
                prevReservoir.W = 0;
                PreviousReservoirGI[prevIndex.y * screen_width + prevIndex.x] = prevReservoir;
            } else {
                if(!UsePermutatedSamples) {
                CurrentRes.M = prevReservoir.M;
                CurrentRes.W = prevReservoir.W;
                CurrentRes.BaseColor = prevReservoir.BaseColor;
                CurrentRes.ThisCase = prevReservoir.ThisCase;
            }
        }

    }


}

CurrentReservoirGI[id.x + id.y * screen_width] = CurrentRes;


}