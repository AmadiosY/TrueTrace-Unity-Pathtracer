// Each #kernel tells which function to compile; you can have many kernels

static uint TransmittanceTexWidth = 256;
static uint TransmittanceTexHeight = 64;

static uint ScatteringTexRSize = 32;
static uint ScatteringTexMUSize = 128;
static uint ScatteringTexMUSSize = 32;
static uint ScatteringTexNUSize = 8;

static uint MultiScatteringLUTRes = 32;

static const float PI = 3.14159265f;

RWTexture2D<float4> TransmittanceTex;
RWTexture3D<float4> RayleighTex;
RWTexture3D<float4> MieTex;
RWTexture2D<float4> MultiScatTex;

Texture2D<float4> TransmittanceTexRead;

SamplerState linearClampSampler;





#pragma kernel Transmittance_Kernel

float top_radius;
float bottom_radius;
struct DensityProfileLayer {
    float width;
    float exp_term;
    float exp_scale;
    float linear_term;
    float constant_term;
};
StructuredBuffer<DensityProfileLayer> rayleigh_density;
StructuredBuffer<DensityProfileLayer> mie_density;
StructuredBuffer<DensityProfileLayer> absorption_density;



float3 solar_irradiance;
float sun_angular_radius;
float3 rayleigh_scattering;
float3 mie_scattering;
float3 mie_extinction;
float mie_phase_function_g;
float3 absorption_extinction;
float3 ground_albedo;
float mu_s_min;

bool RayIntersectsGround(float r, float mu) {
    return (mu < 0.0f && r * r * (mu * mu - 1.0f) + bottom_radius * bottom_radius >= 0.0f);
}



float DistanceToTopAtmosphereBoundary(float r, float mu) {
    float discriminant = r * r * (mu * mu - 1.0f) + top_radius * top_radius;
    return max(-r * mu + sqrt(max(discriminant, 0.0f)), 0.0f);
}

float DistanceToBottomAtmosphereBoundary(float r, float mu) {
    float discriminant = r * r * (mu * mu - 1.0f) + bottom_radius * bottom_radius;
    return max(-r * mu - sqrt(max(discriminant, 0.0f)), 0.0f);
}

float GetLayerDensity(DensityProfileLayer layer, float altitude) {
    float density = layer.exp_term * exp(layer.exp_scale * altitude) + layer.linear_term * altitude + layer.constant_term;
    return clamp(density, 0.0f, 1.0f);
}

float GetProfileDensity(DensityProfileLayer DensProf[2], float altitude) {
    return (altitude < DensProf[0].width) ? GetLayerDensity(DensProf[0], altitude) : GetLayerDensity(DensProf[1], altitude);
}

float ComputeOpticalLengthToTopAtmosphereBoundary(DensityProfileLayer DensProf1, DensityProfileLayer DensProf2, float r, float mu) {
    DensityProfileLayer DensProf[2] = {DensProf1, DensProf2};
    const int SAMPLE_COUNT = 80;
    float dx = DistanceToTopAtmosphereBoundary(r, mu) / (float)SAMPLE_COUNT;
    float result = 0.0f;
    for(int i = 0; i <= SAMPLE_COUNT; ++i) {
        float d_i = (float)i * dx;
        float r_i = sqrt(d_i * d_i + 2.0f * r * mu * d_i + r * r);

        float y_i = GetProfileDensity(DensProf, r_i - bottom_radius);

        float weight_i = i == 0 || i == SAMPLE_COUNT ? 0.5f : 1.0f;

        result += y_i * weight_i * dx;
    }
    return result;
}

float3 ComputeTransmittanceToTopAtmosphereBoundary(float r, float mu) {
    return exp(-(
        rayleigh_scattering * 
        ComputeOpticalLengthToTopAtmosphereBoundary(rayleigh_density[0], rayleigh_density[1], r, mu) + 
        mie_extinction * 
        ComputeOpticalLengthToTopAtmosphereBoundary(mie_density[0], mie_density[1], r, mu) + 
        absorption_extinction * 
        ComputeOpticalLengthToTopAtmosphereBoundary(absorption_density[0], absorption_density[1], r, mu)
        ));
}

float GetTextureCoordFromUnitRange(float x, int texture_size) {
    return 0.5f / (float)texture_size + x * (1.0f - 1.0f / (float)texture_size);
}

float GetUnitRangeFromTextureCoord(float u, int texture_size) {
    return (u - 0.5f / (float)texture_size) / (1.0f - 1.0f / (float)texture_size);
}

float2 GetTransmittanceTextureUvFromRMu(float r, float mu) {
    float H = sqrt(top_radius * top_radius - bottom_radius * bottom_radius);

    float rho = sqrt(max(r * r - bottom_radius * bottom_radius, 0.0f));

    float d = DistanceToTopAtmosphereBoundary(r, mu);
    float d_min = top_radius - r;
    float d_max = rho + H;
    float x_mu = (d - d_min) / (d_max - d_min);
    float x_r = rho / H;
    return float2(GetTextureCoordFromUnitRange(x_mu, TransmittanceTexWidth), GetTextureCoordFromUnitRange(x_mu, TransmittanceTexHeight));
}

void GetRMuFromTransmittanceTextureUv(float2 uv, inout float r, inout float mu) {
    float x_mu = GetUnitRangeFromTextureCoord(uv.x, TransmittanceTexWidth);
    float x_r = GetUnitRangeFromTextureCoord(uv.y, TransmittanceTexHeight);



    float H = sqrt(top_radius * top_radius - bottom_radius * bottom_radius);

    float rho = H * x_r;

    r = sqrt(rho * rho + bottom_radius * bottom_radius);

    float d_min = top_radius - r;
    float d_max = rho + H;
    float d = d_min + x_mu * (d_max - d_min);
    mu = (d == 0.0f) ? 1.0f : (H * H - rho * rho - d * d) / (2.0f * r * d);
    mu = clamp(mu, -1.0f, 1.0f);

}

float3 ComputeTransmittanceToTopAtmosphereBoundaryTexture(uint2 id) {
    float r;
    float mu;
    GetRMuFromTransmittanceTextureUv(id.xy / float2(TransmittanceTexWidth, TransmittanceTexHeight), r, mu);
    return ComputeTransmittanceToTopAtmosphereBoundary(r, mu);
}

float3 GetTransmittanceToTopAtmosphereBoundary(float r, float mu) {
    float2 uv = GetTransmittanceTextureUvFromRMu(r, mu) * float2(TransmittanceTexWidth, TransmittanceTexHeight);
    return float3(TransmittanceTex[(int2)uv].xyz);
}

float3 GetTransmittance(float r, float mu, float d, bool ray_r_mu_intersects_ground) {

    float r_d = clamp(sqrt(d * d + 2.0f * r * mu * d * r * r), 6371.0f, 6403.0f);
    float mu_d = clamp((r * mu + d) / r_d, -1.0f, 1.0f);
    if(ray_r_mu_intersects_ground) {
        return min(GetTransmittanceToTopAtmosphereBoundary(r_d, -mu_d) / 
            GetTransmittanceToTopAtmosphereBoundary(r, -mu), 
            float3(1.0f, 1.0f, 1.0f));

    } else {
        return min(GetTransmittanceToTopAtmosphereBoundary(r, mu) / 
            GetTransmittanceToTopAtmosphereBoundary(r_d, mu_d), 
            float3(1.0f, 1.0f, 1.0f));
    }
}   



float3 GetTransmissionToSun(float r, float mu_s) {
    float sin_theta_h = bottom_radius / r;
    float cos_theta_h = -sqrt(max(1.0f - sin_theta_h * sin_theta_h, 0.0f));
    return GetTransmittanceToTopAtmosphereBoundary(r, mu_s) * 
    smoothstep(-sin_theta_h * sun_angular_radius, sin_theta_h * sun_angular_radius, mu_s - cos_theta_h);
}

[numthreads(1,1,1)]
void Transmittance_Kernel (uint3 id : SV_DispatchThreadID)
{
    if(id.x >= TransmittanceTexWidth || id.y >= TransmittanceTexHeight) return;
    // TODO: insert actual code here!
    float3 col = ComputeTransmittanceToTopAtmosphereBoundaryTexture(id.xy);

    TransmittanceTex[id.xy] = float4(col, 1.0f);
}



#pragma kernel SingleScatter_Kernel

void ComputeSingleScatteringIntegrand(float r, float mu, float mu_s, float nu, float d, bool ray_r_mu_intersects_ground, inout float3 rayleigh, inout float3 mie) {
    float r_d = clamp(sqrt(d * d + 2.0f * r * mu * d + r * r), 6371.0f, 6403.0f);
    float mu_s_d = clamp((r * mu_s + d * nu) / r_d, -1.0f, 1.0f);

    float3 transmittance = GetTransmittance(r, mu, d, ray_r_mu_intersects_ground) *
        GetTransmissionToSun(r_d, mu_s_d);
    DensityProfileLayer DensProf[2] = {rayleigh_density[0], rayleigh_density[1]};
    rayleigh = transmittance * GetProfileDensity(DensProf, r_d - bottom_radius);
    DensProf[0] = mie_density[0]; 
    DensProf[1] = mie_density[1];
    mie = transmittance * GetProfileDensity(DensProf, r_d - bottom_radius);
}

float DistanceToNearestAtmosphereBoundary(float r, float mu, bool ray_r_mu_intersects_ground) {
    if(ray_r_mu_intersects_ground) {
        return DistanceToBottomAtmosphereBoundary(r, mu);
    } else {
        return DistanceToTopAtmosphereBoundary(r, mu);
    }
}

void ComputeSingleScattering(float r, float mu, float mu_s, float nu, bool ray_r_mu_intersects_ground, inout float3 rayleigh, inout float3 mie) {
    const int SAMPLE_COUNT = 100;
    float dx = DistanceToNearestAtmosphereBoundary(r, mu, ray_r_mu_intersects_ground) / (float)SAMPLE_COUNT;
    float3 rayleigh_sum = float3(0.0f, 0.0f, 0.0f);
    float3 mie_sum = float3(0.0f, 0.0f, 0.0f);
    for(int i = 0; i <= SAMPLE_COUNT; ++i) {
        float d_i = (float)i * dx;
        float3 rayleigh_i;
        float3 mie_i;
        ComputeSingleScatteringIntegrand(r, mu, mu_s, nu, d_i, ray_r_mu_intersects_ground, rayleigh_i, mie_i);
        float weight_i = (i == 0 || i == SAMPLE_COUNT) ? 0.5f : 1.0f;
        rayleigh_sum += rayleigh_i * weight_i;
        mie_sum += mie_i * weight_i;
    }
    rayleigh = rayleigh_sum * dx * solar_irradiance * rayleigh_scattering;
    mie = mie_sum * dx * solar_irradiance * mie_scattering;

}

float4 GetScatteringTextureUvwzFromRMuMuSNu(float r, float mu, float mu_s, float nu, bool ray_r_mu_intersects_ground) {
    float H = sqrt(top_radius * top_radius - bottom_radius * bottom_radius);
    float rho = sqrt(max(r * r - bottom_radius * bottom_radius, 0.0f));
    float u_r = GetTextureCoordFromUnitRange(rho / H, ScatteringTexRSize);

    float r_mu = r * mu;
    float discriminant = r_mu * r_mu - r * r + bottom_radius * bottom_radius;
    float u_mu;
    if(ray_r_mu_intersects_ground) {
        float d = -r_mu - sqrt(max(discriminant, 0.0f));
        float d_min = r - bottom_radius;
        float d_max = rho;
        u_mu = 0.5f - 0.5f * GetTextureCoordFromUnitRange((d_max == d_min) ? 0.0f : (d - d_min) / (d_max - d_min), ScatteringTexMUSize / 2);
    } else {
        float d = -r_mu + sqrt(max(discriminant + H * H, 0.0f));
        float d_min = top_radius - r;
        float d_max = rho + H;
        u_mu = 0.5f + 0.5f * GetTextureCoordFromUnitRange((d - d_min) / (d_max - d_min), ScatteringTexMUSize / 2);
    }

    float d = DistanceToTopAtmosphereBoundary(bottom_radius, mu_s);
    float d_min = top_radius - bottom_radius;
    float d_max = H;
    float a = (d - d_min) / (d_max - d_min);
    float D = DistanceToTopAtmosphereBoundary(bottom_radius, mu_s_min);
    float A = (D - d_min) / (d_max - d_min);

    float u_mu_s = GetTextureCoordFromUnitRange(max(1.0f - a / A, 0.0f) / (1.0f + a), ScatteringTexMUSSize);

    float u_nu = (nu + 1.0f) / 2.0f;
    return float4(u_nu, u_mu_s, u_mu, u_r);
}


void GetRMuMuSNuFromScatteringTextureUvwz(float4 uvwz, inout float r, inout float mu, inout float mu_s, inout float nu, inout bool ray_r_mu_intersects_ground) {
    float H = sqrt(top_radius * top_radius - bottom_radius * bottom_radius);
    float rho = H * GetUnitRangeFromTextureCoord(uvwz.w, ScatteringTexRSize);
    r = sqrt(rho * rho + bottom_radius * bottom_radius);




    if(uvwz.z < 0.5f) {
        float d_min = r - bottom_radius;
        float d_max = rho;
        float d = d_min + (d_max - d_min) * GetUnitRangeFromTextureCoord(1.0f - 2.0f * uvwz.z, ScatteringTexMUSize / 2);
        mu = (d == 0.0f) ? -1.0f : clamp(-(rho * rho + d * d) / (2.0f * r * d), -1.0f, 1.0f);
        ray_r_mu_intersects_ground = true;

    } else {
        float d_min = top_radius - r;
        float d_max = rho + H;
        float d = d_min + (d_max - d_min) * GetUnitRangeFromTextureCoord(2.0f * uvwz.z - 1.0f, ScatteringTexMUSize / 2);
        mu = (d == 0.0f) ? 1.0f : clamp((H * H - rho * rho - d * d) / (2.0f * r * d), -1.0f, 1.0f);
        ray_r_mu_intersects_ground = false;
    }
    float x_mu_s = GetUnitRangeFromTextureCoord(uvwz.y, ScatteringTexMUSSize);
    float d_min = top_radius - bottom_radius;
    float d_max = H;
    float D = DistanceToTopAtmosphereBoundary(bottom_radius, mu_s_min);
    float A = (D - d_min) / (d_max - d_min);
    float a = (A - x_mu_s * A) / (1.0f + x_mu_s * A);
    float d = d_min + min(a, A) * (d_max - d_min);
    mu_s = (d == 0.0f) ? 1.0f : clamp((H * H - d * d) / (2.0f * bottom_radius * d), -1.0f, 1.0f);
    nu = clamp(uvwz.x * 2.0f - 1.0f, -1.0f, 1.0f);

    float u_mu_s = GetTextureCoordFromUnitRange(max(1.0f - a / A, 0.0f) / (1.0f + a), ScatteringTexMUSSize);
}

void GetRMuMuSNuFromScatteringTextureFragCoord(float3 frag_coord, inout float r, inout float mu, inout float mu_s, inout float nu, inout bool ray_r_mu_intersects_ground) {
    const float4 SCATTERINGTEXTURESIZE = float4(
        ScatteringTexNUSize - 1,
        ScatteringTexMUSSize,
        ScatteringTexMUSize,
        ScatteringTexRSize
        );
    float frag_coord_nu = floor(frag_coord.x / (float)ScatteringTexMUSSize);
    float frag_coord_mu_s = fmod(frag_coord.x, (float)ScatteringTexMUSSize);
    float4 uvwz = float4(frag_coord_nu, frag_coord_mu_s, frag_coord.y, frag_coord.z) / SCATTERINGTEXTURESIZE;
    GetRMuMuSNuFromScatteringTextureUvwz(uvwz, r, mu, mu_s, nu, ray_r_mu_intersects_ground);
    nu = clamp(nu, mu * mu_s - sqrt((1.0 - mu * mu) * (1.0 - mu_s * mu_s)),mu * mu_s + sqrt((1.0 - mu * mu) * (1.0 - mu_s * mu_s)));
}

void ComputeSingleScatteringTexture(float3 frag_coord, inout float3 rayleigh, inout float3 mie) {
    float r;
    float mu;
    float mu_s;
    float nu;
    bool ray_r_mu_intersects_ground;
    GetRMuMuSNuFromScatteringTextureFragCoord(frag_coord, r, mu, mu_s, nu, ray_r_mu_intersects_ground);
    ComputeSingleScattering(r, mu, mu_s, nu, ray_r_mu_intersects_ground, rayleigh, mie);

}

float RayleighPhaseFunction(float nu) {
  float k = 3.0 / (16.0 * PI);
  return k * (1.0 + nu * nu);
}

float MiePhaseFunction(float g, float nu) {
  float k = 3.0 / (8.0 * PI) * (1.0 - g * g) / (2.0 + g * g);
  return k * (1.0 + nu * nu) / pow(1.0 + g * g - 2.0 * g * nu, 1.5);
}


float3 GetTransmittanceToSun(float r, float mu_s) {
  float sin_theta_h = bottom_radius / r;
  float cos_theta_h = -sqrt(max(1.0f - sin_theta_h * sin_theta_h, 0.0f));
  return GetTransmittanceToTopAtmosphereBoundary(r, mu_s) *
      smoothstep(-sin_theta_h * sun_angular_radius / 1.0f,
                 sin_theta_h * sun_angular_radius / 1.0f,
                 mu_s - cos_theta_h);
}

[numthreads(1,1,1)]
void SingleScatter_Kernel (uint3 id : SV_DispatchThreadID)
{
    if(id.x >= ScatteringTexNUSize * ScatteringTexMUSSize || id.y >= ScatteringTexMUSize || id.z > ScatteringTexRSize) return;
    // TODO: insert actual code here!
    float3 rayleigh;
    float3 mie;
    ComputeSingleScatteringTexture(id.xyz, rayleigh, mie);

    RayleighTex[id.xyz] = float4(rayleigh, 1.0f);
    MieTex[id.xyz] = float4(mie, 1.0f);
}


#pragma kernel NewMultiScattCS_kernel


float raySphereIntersectNearest(float3 r0, float3 rd, float3 s0, float sR)
{
    float a = dot(rd, rd);
    float3 s0_r0 = r0 - s0;
    float b = 2.0 * dot(rd, s0_r0);
    float c = dot(s0_r0, s0_r0) - (sR * sR);
    float delta = b * b - 4.0*a*c;
    if (delta < 0.0 || a == 0.0)
    {
        return -1.0;
    }
    float sol0 = (-b - sqrt(delta)) / (2.0*a);
    float sol1 = (-b + sqrt(delta)) / (2.0*a);
    if (sol0 < 0.0 && sol1 < 0.0)
    {
        return -1.0;
    }
    if (sol0 < 0.0)
    {
        return max(0.0, sol1);
    }
    else if (sol1 < 0.0)
    {
        return max(0.0, sol0);
    }
    return max(0.0, min(sol0, sol1));
}



struct SingleScatteringResult
{
    float3 L;                       // Scattered light (luminance)
    float3 OpticalDepth;            // Optical depth (1/m)
    float3 Transmittance;           // Transmittance in [0,1] (unitless)
    float3 MultiScatAs1;

    float3 NewMultiScatStep0Out;
    float3 NewMultiScatStep1Out;
};


struct MediumSampleRGB
{
    float3 scattering;
    float3 absorption;
    float3 extinction;

    float3 scatteringMie;
    float3 absorptionMie;
    float3 extinctionMie;

    float3 scatteringRay;
    float3 absorptionRay;
    float3 extinctionRay;

    float3 scatteringOzo;
    float3 absorptionOzo;
    float3 extinctionOzo;

    float3 albedo;
};

float3 getAlbedo(float3 scattering, float3 extinction)
{
    return scattering / max(0.001, extinction);
}

MediumSampleRGB sampleMediumRGB(float3 WorldPos)
{
    const float viewHeight = length(WorldPos) - bottom_radius;

    const float densityMie = exp(mie_density[1].exp_scale * viewHeight);
    const float densityRay = exp(rayleigh_density[1].exp_scale * viewHeight);
    const float densityOzo = saturate(viewHeight < absorption_density[0].width ?
        absorption_density[0].linear_term * viewHeight + absorption_density[0].constant_term :
        absorption_density[1].linear_term * viewHeight + absorption_density[1].constant_term);

    MediumSampleRGB s;

    s.scatteringMie = mie_scattering;
    s.absorptionMie = mie_extinction - mie_scattering;
    s.extinctionMie = mie_extinction;

    s.scatteringRay = rayleigh_scattering;// densityRay * Atmosphere.RayleighScattering;
    s.absorptionRay = 0.0f;
    s.extinctionRay = s.scatteringRay + s.absorptionRay;

    s.scatteringOzo = 0.0;
    s.absorptionOzo = absorption_extinction;// densityOzo * Atmosphere.AbsorptionExtinction;
    s.extinctionOzo = s.scatteringOzo + s.absorptionOzo;

    s.scattering = s.scatteringMie + s.scatteringRay + s.scatteringOzo;
    s.absorption = s.absorptionMie + s.absorptionRay + s.absorptionOzo;
    s.extinction = s.extinctionMie + s.extinctionRay + s.extinctionOzo;
    s.albedo = getAlbedo(s.scattering, s.extinction);

    return s;
}

void LutTransmittanceParamsToUv(float viewHeight, float viewZenithCosAngle, inout float2 uv)
{
    float H = sqrt(max(0.0f, top_radius * top_radius - bottom_radius * bottom_radius));
    float rho = sqrt(max(0.0f, viewHeight * viewHeight - bottom_radius * bottom_radius));

    float discriminant = viewHeight * viewHeight * (viewZenithCosAngle * viewZenithCosAngle - 1.0) + top_radius * top_radius;
    float d = max(0.0, (-viewHeight * viewZenithCosAngle + sqrt(discriminant))); // Distance to atmosphere boundary

    float d_min = top_radius - viewHeight;
    float d_max = rho + H;
    float x_mu = (d - d_min) / (d_max - d_min);
    float x_r = rho / H;

    uv = float2(x_mu, x_r);
    //uv = float2(fromUnitToSubUvs(uv.x, TRANSMITTANCE_TEXTURE_WIDTH), fromUnitToSubUvs(uv.y, TRANSMITTANCE_TEXTURE_HEIGHT)); // No real impact so off
}

float hgPhase(float g, float cosTheta)
{
#ifdef USE_CornetteShanks
    return CornetteShanksMiePhaseFunction(g, cosTheta);
#else
    // Reference implementation (i.e. not schlick approximation). 
    // See http://www.pbr-book.org/3ed-2018/Volume_Scattering/Phase_Functions.html
    float numer = 1.0f - g * g;
    float denom = 1.0f + g * g + 2.0f * g * cosTheta;
    return numer / (4.0f * PI * denom * sqrt(denom));
#endif
}

float RayleighPhase(float cosTheta)
{
    float factor = 3.0f / (16.0f * PI);
    return factor * (1.0f + cosTheta * cosTheta);
}

SingleScatteringResult IntegrateScatteredLuminance(
    float2 pixPos, float3 WorldPos, float3 WorldDir, float3 SunDir,
    bool ground, float SampleCountIni, float DepthBufferValue, bool VariableSampleCount,
    bool MieRayPhase, float tMaxMax = 9000000.0f)
{
    const bool debugEnabled = false;
    SingleScatteringResult result = (SingleScatteringResult)0;

    // Compute next intersection with atmosphere or ground 
    float3 earthO = float3(0.0f, 0.0f, 0.0f);
    float tBottom = raySphereIntersectNearest(WorldPos, WorldDir, earthO, bottom_radius);
    float tTop = raySphereIntersectNearest(WorldPos, WorldDir, earthO, top_radius);
    float tMax = 0.0f;
    if (tBottom < 0.0f)
    {
        if (tTop < 0.0f)
        {
            tMax = 0.0f; // No intersection with earth nor atmosphere: stop right away  
            return result;
        }
        else
        {
            tMax = tTop;
        }
    }
    else
    {
        if (tTop > 0.0f)
        {
            tMax = min(tTop, tBottom);
        }
    }

    tMax = min(tMax, tMaxMax);

    // Sample count 
    float SampleCount = SampleCountIni;
    float SampleCountFloor = SampleCountIni;
    float tMaxFloor = tMax;
    if (VariableSampleCount)
    {
        SampleCount = lerp(10, 30, saturate(tMax*0.01));//both 10 and 30 can go between 0 and 30, with the secon dnumber higher than the first
        SampleCountFloor = floor(SampleCount);
        tMaxFloor = tMax * SampleCountFloor / SampleCount;  // rescale tMax to map to the last entire step segment.
    }
    float dt = tMax / SampleCount;

    // Phase functions
    const float uniformPhase = 1.0 / (4.0 * PI);
    const float3 wi = SunDir;
    const float3 wo = WorldDir;
    float cosTheta = dot(wi, wo);
    float MiePhaseValue = hgPhase(0.35, -cosTheta); // mnegate cosTheta because due to WorldDir being a "in" direction.//0.35 can go between 0 and 0.999 
    float RayleighPhaseValue = RayleighPhase(cosTheta);


    // When building the scattering factor, we assume light illuminance is 1 to compute a transfert function relative to identity illuminance of 1.
    // This make the scattering factor independent of the light. It is now only linked to the atmosphere properties.
    float3 globalL = 1.0f;

    // Ray march the atmosphere to integrate optical depth
    float3 L = 0.0f;
    float3 throughput = 1.0;
    float3 OpticalDepth = 0.0;
    float t = 0.0f;
    float tPrev = 0.0;
    const float SampleSegmentT = 0.3f;
    for (float s = 0.0f; s < SampleCount; s += 1.0f)
    {
        if (VariableSampleCount)
        {
            // More expenssive but artefact free
            float t0 = (s) / SampleCountFloor;
            float t1 = (s + 1.0f) / SampleCountFloor;
            // Non linear distribution of sample within the range.
            t0 = t0 * t0;
            t1 = t1 * t1;
            // Make t0 and t1 world space distances.
            t0 = tMaxFloor * t0;
            if (t1 > 1.0)
            {
                t1 = tMax;
                //  t1 = tMaxFloor; // this reveal depth slices
            }
            else
            {
                t1 = tMaxFloor * t1;
            }
            //t = t0 + (t1 - t0) * (whangHashNoise(pixPos.x, pixPos.y, gFrameId * 1920 * 1080)); // With dithering required to hide some sampling artefact relying on TAA later? This may even allow volumetric shadow?
            t = t0 + (t1 - t0)*SampleSegmentT;
            dt = t1 - t0;
        }
        else
        {
            //t = tMax * (s + SampleSegmentT) / SampleCount;
            // Exact difference, important for accuracy of multiple scattering
            float NewT = tMax * (s + SampleSegmentT) / SampleCount;
            dt = NewT - t;
            t = NewT;
        }
        float3 P = WorldPos + t * WorldDir;



        MediumSampleRGB medium = sampleMediumRGB(P);
        const float3 SampleOpticalDepth = medium.extinction * dt;
        const float3 SampleTransmittance = exp(-SampleOpticalDepth);
        OpticalDepth += SampleOpticalDepth;

        float pHeight = length(P);
        const float3 UpVector = P / pHeight;
        float SunZenithCosAngle = dot(SunDir, UpVector);
        float2 uv;
        LutTransmittanceParamsToUv(pHeight, SunZenithCosAngle, uv);
        float3 TransmittanceToSun = TransmittanceTexRead.SampleLevel(linearClampSampler, uv, 0).rgb;

        float3 PhaseTimesScattering;
        if (MieRayPhase)
        {
            PhaseTimesScattering = medium.scatteringMie * MiePhaseValue + medium.scatteringRay * RayleighPhaseValue;
        }
        else
        {
            PhaseTimesScattering = medium.scattering * uniformPhase;
        }

        // Earth shadow 
        float tEarth = raySphereIntersectNearest(P, SunDir, earthO + 0.01f * UpVector, bottom_radius);
        float earthShadow = tEarth >= 0.0f ? 0.0f : 1.0f;

        // Dual scattering for multi scattering 

        float3 multiScatteredLuminance = 0.0f;
#if MULTISCATAPPROX_ENABLED
        multiScatteredLuminance = GetMultipleScattering(Atmosphere, medium.scattering, medium.extinction, P, SunZenithCosAngle);
#endif

        float shadow = 1.0f;
#if SHADOWMAP_ENABLED
        // First evaluate opaque shadow
        shadow = getShadow(Atmosphere, P);
#endif

        float3 S = globalL * (earthShadow * shadow * TransmittanceToSun * PhaseTimesScattering + multiScatteredLuminance * medium.scattering);

        // When using the power serie to accumulate all sattering order, serie r must be <1 for a serie to converge.
        // Under extreme coefficient, MultiScatAs1 can grow larger and thus result in broken visuals.
        // The way to fix that is to use a proper analytical integration as proposed in slide 28 of http://www.frostbite.com/2015/08/physically-based-unified-volumetric-rendering-in-frostbite/
        // However, it is possible to disable as it can also work using simple power serie sum unroll up to 5th order. The rest of the orders has a really low contribution.
#define MULTI_SCATTERING_POWER_SERIE 1

#if MULTI_SCATTERING_POWER_SERIE==0
        // 1 is the integration of luminance over the 4pi of a sphere, and assuming an isotropic phase function of 1.0/(4*PI)
        result.MultiScatAs1 += throughput * medium.scattering * 1 * dt;
#else
        float3 MS = medium.scattering * 1;
        float3 MSint = (MS - MS * SampleTransmittance) / medium.extinction;
        result.MultiScatAs1 += throughput * MSint;
#endif

        // Evaluate input to multi scattering 
        {
            float3 newMS;

            newMS = earthShadow * TransmittanceToSun * medium.scattering * uniformPhase * 1;
            result.NewMultiScatStep0Out += throughput * (newMS - newMS * SampleTransmittance) / medium.extinction;
            //  result.NewMultiScatStep0Out += SampleTransmittance * throughput * newMS * dt;

            newMS = medium.scattering * uniformPhase * multiScatteredLuminance;
            result.NewMultiScatStep1Out += throughput * (newMS - newMS * SampleTransmittance) / medium.extinction;
            //  result.NewMultiScatStep1Out += SampleTransmittance * throughput * newMS * dt;
        }

#if 0
        L += throughput * S * dt;
        throughput *= SampleTransmittance;
#else
        // See slide 28 at http://www.frostbite.com/2015/08/physically-based-unified-volumetric-rendering-in-frostbite/ 
        float3 Sint = (S - S * SampleTransmittance) / medium.extinction;    // integrate along the current step segment 
        L += throughput * Sint;                                                     // accumulate and also take into account the transmittance from previous steps
        throughput *= SampleTransmittance;
#endif

        tPrev = t;
    }

    if (ground && tMax == tBottom && tBottom > 0.0)
    {
        // Account for bounced light off the earth
        float3 P = WorldPos + tBottom * WorldDir;
        float pHeight = length(P);

        const float3 UpVector = P / pHeight;
        float SunZenithCosAngle = dot(SunDir, UpVector);
        float2 uv;
        LutTransmittanceParamsToUv(pHeight, SunZenithCosAngle, uv);
        float3 TransmittanceToSun = TransmittanceTexRead.SampleLevel(linearClampSampler, uv, 0).rgb;

        const float NdotL = saturate(dot(normalize(UpVector), normalize(SunDir)));
        L += globalL * TransmittanceToSun * throughput * NdotL * ground_albedo / PI;
    }

    result.L = L;
    result.OpticalDepth = OpticalDepth;
    result.Transmittance = throughput;
    return result;
}

float fromUnitToSubUvs(float u, float resolution) { return (u + 0.5f / resolution) * (resolution / (resolution + 1.0f)); }
float fromSubUvsToUnit(float u, float resolution) { return (u - 0.5f / resolution) * (resolution / (resolution - 1.0f)); }

groupshared float3 MultiScatAs1SharedMem[64];
groupshared float3 LSharedMem[64];

[numthreads(1, 1, 64)]
void NewMultiScattCS_kernel(uint3 ThreadId : SV_DispatchThreadID)
{
    float2 pixPos = float2(ThreadId.xy) + 0.5f;
    float2 uv = pixPos / MultiScatteringLUTRes;


    uv = float2(fromSubUvsToUnit(uv.x, MultiScatteringLUTRes), fromSubUvsToUnit(uv.y, MultiScatteringLUTRes));

    float cosSunZenithAngle = uv.x * 2.0 - 1.0;
    float3 sunDir = float3(0.0, sqrt(saturate(1.0 - cosSunZenithAngle * cosSunZenithAngle)), cosSunZenithAngle);
    // We adjust again viewHeight according to 0.01f to be in a valid range.
    float viewHeight = bottom_radius + saturate(uv.y + 0.01f) * (top_radius - bottom_radius - 0.01f);

    float3 WorldPos = float3(0.0f, 0.0f, viewHeight);
    float3 WorldDir = float3(0.0f, 0.0f, 1.0f);


    const bool ground = true;
    const float SampleCountIni = 20;// a minimum set of step is required for accuracy unfortunately
    const float DepthBufferValue = -1.0;
    const bool VariableSampleCount = false;
    const bool MieRayPhase = false;

    const float SphereSolidAngle = 4.0 * PI;
    const float IsotropicPhase = 1.0 / SphereSolidAngle;


    // Reference. Since there are many sample, it requires MULTI_SCATTERING_POWER_SERIE to be true for accuracy and to avoid divergences (see declaration for explanations)
#define SQRTSAMPLECOUNT 8
    const float sqrtSample = float(SQRTSAMPLECOUNT);
    float i = 0.5f + float(ThreadId.z / SQRTSAMPLECOUNT);
    float j = 0.5f + float(ThreadId.z - float((ThreadId.z / SQRTSAMPLECOUNT)*SQRTSAMPLECOUNT));
    {
        float randA = i / sqrtSample;
        float randB = j / sqrtSample;
        float theta = 2.0f * PI * randA;
        float phi = acos(1.0f - 2.0f * randB);  // uniform distribution https://mathworld.wolfram.com/SpherePointPicking.html
        //phi = PI * randB;                     // bad non uniform
        float cosPhi = cos(phi);
        float sinPhi = sin(phi);
        float cosTheta = cos(theta);
        float sinTheta = sin(theta);
        WorldDir.x = cosTheta * sinPhi;
        WorldDir.y = sinTheta * sinPhi;
        WorldDir.z = cosPhi;
        SingleScatteringResult result = IntegrateScatteredLuminance(pixPos, WorldPos, WorldDir, sunDir, ground, SampleCountIni, DepthBufferValue, VariableSampleCount, MieRayPhase);

        MultiScatAs1SharedMem[ThreadId.z] = result.MultiScatAs1 * SphereSolidAngle / (sqrtSample * sqrtSample);
        LSharedMem[ThreadId.z] = result.L * SphereSolidAngle / (sqrtSample * sqrtSample);
    }
#undef SQRTSAMPLECOUNT

    GroupMemoryBarrierWithGroupSync();

    // 64 to 32
    if (ThreadId.z < 32)
    {
        MultiScatAs1SharedMem[ThreadId.z] += MultiScatAs1SharedMem[ThreadId.z + 32];
        LSharedMem[ThreadId.z] += LSharedMem[ThreadId.z + 32];
    }
    GroupMemoryBarrierWithGroupSync();

    // 32 to 16
    if (ThreadId.z < 16)
    {
        MultiScatAs1SharedMem[ThreadId.z] += MultiScatAs1SharedMem[ThreadId.z + 16];
        LSharedMem[ThreadId.z] += LSharedMem[ThreadId.z + 16];
    }
    GroupMemoryBarrierWithGroupSync();

    // 16 to 8 (16 is thread group min hardware size with intel, no sync required from there)
    if (ThreadId.z < 8)
    {
        MultiScatAs1SharedMem[ThreadId.z] += MultiScatAs1SharedMem[ThreadId.z + 8];
        LSharedMem[ThreadId.z] += LSharedMem[ThreadId.z + 8];
    }
    GroupMemoryBarrierWithGroupSync();
    if (ThreadId.z < 4)
    {
        MultiScatAs1SharedMem[ThreadId.z] += MultiScatAs1SharedMem[ThreadId.z + 4];
        LSharedMem[ThreadId.z] += LSharedMem[ThreadId.z + 4];
    }
    GroupMemoryBarrierWithGroupSync();
    if (ThreadId.z < 2)
    {
        MultiScatAs1SharedMem[ThreadId.z] += MultiScatAs1SharedMem[ThreadId.z + 2];
        LSharedMem[ThreadId.z] += LSharedMem[ThreadId.z + 2];
    }
    GroupMemoryBarrierWithGroupSync();
    if (ThreadId.z < 1)
    {
        MultiScatAs1SharedMem[ThreadId.z] += MultiScatAs1SharedMem[ThreadId.z + 1];
        LSharedMem[ThreadId.z] += LSharedMem[ThreadId.z + 1];
    }
    GroupMemoryBarrierWithGroupSync();
    if (ThreadId.z > 0)
        return;

    float3 MultiScatAs1         = MultiScatAs1SharedMem[0] * IsotropicPhase;    // Equation 7 f_ms
    float3 InScatteredLuminance = LSharedMem[0] * IsotropicPhase;               // Equation 5 L_2ndOrder

    // MultiScatAs1 represents the amount of luminance scattered as if the integral of scattered luminance over the sphere would be 1.
    //  - 1st order of scattering: one can ray-march a straight path as usual over the sphere. That is InScatteredLuminance.
    //  - 2nd order of scattering: the inscattered luminance is InScatteredLuminance at each of samples of fist order integration. Assuming a uniform phase function that is represented by MultiScatAs1,
    //  - 3nd order of scattering: the inscattered luminance is (InScatteredLuminance * MultiScatAs1 * MultiScatAs1)
    //  - etc.
#if MULTI_SCATTERING_POWER_SERIE==0
    float3 MultiScatAs1SQR = MultiScatAs1 * MultiScatAs1;
    float3 L = InScatteredLuminance * (1.0 + MultiScatAs1 + MultiScatAs1SQR + MultiScatAs1 * MultiScatAs1SQR + MultiScatAs1SQR * MultiScatAs1SQR);
#else
    // For a serie, sum_{n=0}^{n=+inf} = 1 + r + r^2 + r^3 + ... + r^n = 1 / (1.0 - r), see https://en.wikipedia.org/wiki/Geometric_series 
    const float3 r = MultiScatAs1;
    const float3 SumOfAllMultiScatteringEventsContribution = 1.0f / (1.0 - r);
    float3 L = InScatteredLuminance * SumOfAllMultiScatteringEventsContribution;// Equation 10 Psi_ms
#endif

    MultiScatTex[ThreadId.xy] = float4(L.xyz, 1.0f);
}












#pragma kernel SkyView_Kernel

void UvToSkyViewLutParams(inout float viewZenithCosAngle, inout float lightViewCosAngle, float viewHeight, float2 uv)
{
    // Constrain uvs to valid sub texel range (avoid zenith derivative issue making LUT usage visible)
    uv = float2(fromSubUvsToUnit(uv.x, 192.0f), fromSubUvsToUnit(uv.y, 108.0f));

    float Vhorizon = sqrt(viewHeight * viewHeight - bottom_radius * bottom_radius);
    float CosBeta = Vhorizon / viewHeight;              // GroundToHorizonCos
    float Beta = acos(CosBeta);
    float ZenithHorizonAngle = PI - Beta;

    if (uv.y < 0.5f)
    {
        float coord = 2.0*uv.y;
        coord = 1.0 - coord;

        coord *= coord;

        coord = 1.0 - coord;
        viewZenithCosAngle = cos(ZenithHorizonAngle * coord);
    }
    else
    {
        float coord = uv.y*2.0 - 1.0;

        coord *= coord;

        viewZenithCosAngle = cos(ZenithHorizonAngle + Beta * coord);
    }

    float coord = uv.x;
    coord *= coord;
    lightViewCosAngle = -(coord*2.0 - 1.0);
}

float4x4 InvViewProjMat;


float3 camPos;

float3 sun_direction;

bool MoveToTopAtmosphere(inout float3 WorldPos, in float3 WorldDir, in float AtmosphereTopRadius)
{
    float viewHeight = length(WorldPos);
    if (viewHeight > AtmosphereTopRadius)
    {
        float tTop = raySphereIntersectNearest(WorldPos, WorldDir, float3(0.0f, 0.0f, 0.0f), AtmosphereTopRadius);
        if (tTop >= 0.0f)
        {
            float3 UpVector = WorldPos / viewHeight;
            float3 UpOffset = UpVector * -0.01f;
            WorldPos = WorldPos + WorldDir * tTop + UpOffset;
        }
        else
        {
            // Ray is not intersecting the atmosphere
            return false;
        }
    }
    return true; // ok to start tracing
}

RWTexture2D<float4> SkyViewTex;

[numthreads(16, 16, 1)]//192, 108
void SkyView_Kernel(uint3 id : SV_DispatchThreadID)
{
    if(id.x + id.y * 192 > 192 * 108) return;
    float2 pixPos = id.xy;

    float3 ClipSpace = float3((pixPos / float2(192.0,108.0))*float2(2.0, -2.0) - float2(1.0, -1.0), 1.0);
    float4 HPos = mul(InvViewProjMat, float4(ClipSpace, 1.0));

    float3 WorldDir = normalize(HPos.xyz / HPos.w - camPos);
    float3 WorldPos = camPos + float3(0, bottom_radius, 0);


    float2 uv = pixPos / float2(192.0, 108.0);

    float viewHeight = length(WorldPos);

    float viewZenithCosAngle;
    float lightViewCosAngle;
    UvToSkyViewLutParams(viewZenithCosAngle, lightViewCosAngle, viewHeight, uv);


    float3 SunDir;
    {
        float3 UpVector = WorldPos / viewHeight;
        float sunZenithCosAngle = dot(UpVector, sun_direction);
        SunDir = normalize(float3(sqrt(1.0 - sunZenithCosAngle * sunZenithCosAngle), 0.0, sunZenithCosAngle));
    }



    WorldPos = float3(0.0f, 0.0f, viewHeight);

    float viewZenithSinAngle = sqrt(1 - viewZenithCosAngle * viewZenithCosAngle);
    WorldDir = float3(
        viewZenithSinAngle * lightViewCosAngle,
        viewZenithSinAngle * sqrt(1.0 - lightViewCosAngle * lightViewCosAngle),
        viewZenithCosAngle);


    // Move to top atmospehre
    if (!MoveToTopAtmosphere(WorldPos, WorldDir, top_radius))
    {
        // Ray is not intersecting the atmosphere
        SkyViewTex[id.xy] = float4(0, 0, 0, 1);
        return;
    }

    const bool ground = false;
    const float SampleCountIni = 30;
    const float DepthBufferValue = -1.0;
    const bool VariableSampleCount = true;
    const bool MieRayPhase = true;
    SingleScatteringResult ss = IntegrateScatteredLuminance(pixPos, WorldPos, WorldDir, SunDir, ground, SampleCountIni, DepthBufferValue, VariableSampleCount, MieRayPhase);

    float3 L = ss.L;

    SkyViewTex[id.xy] = float4(L, 1);
}




