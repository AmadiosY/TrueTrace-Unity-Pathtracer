#pragma use_dxc
#include "CommonData.cginc"
#include "Materials.cginc"

#pragma kernel kernel_shade

Texture2D<float4> _SkyboxTexture;
SamplerState sampler_SkyboxTexture;

Texture2D<float4> _TextureAtlas;
SamplerState my_point_clamp_sampler;

Texture2D<float2> _NormalAtlas;
SamplerState sampler_NormalAtlas;

Texture2D<float4> _EmissiveAtlas;
SamplerState sampler_EmissiveAtlas;

//These are here purely for the Atrous




HitMat CreateHitMat() {
	HitMat hit;
	hit.surfaceColor = float3(0.0f, 0.0f, 0.0f);
	hit.emmis = 0.0f;
	hit.roughness = 0.0f;
	hit.MatType = 0;
	hit.DoesPassThrough = false;
	hit.relativeIOR = 0;
	hit.ior = 0;
	hit.anisotropic = 0;
	hit.clearcoatGloss = 0;
	hit.flatness = 0;
	hit.clearcoat = 0;
	hit.transmittanceColor = 0;
	hit.scatterDistance = 0;
	hit.phaseFunction = 0;
	hit.extinction = 0;
	hit.diffTrans = 0;
	hit.sheen = 0;

	hit.sheenTint = 0;


	return hit;
}

float2 sample_disc(float u1, float u2) {
	float a = 2.0f * u1 - 1.0f;
	float b = 2.0f * u2 - 1.0f;
	if (a == 0.0f) a = 0.00001;
	if (b == 0.0f) b = 0.00001;

	float phi, r;
	if (a * a > b * b) {
		r = a;
		phi = (0.25f * PI) * (b / a);
	}
	else {
		r = b;
		phi = (0.25f * PI) * (a / b) + (0.5f * PI);
	}

	float sin_phi, cos_phi;
	sincos(phi, sin_phi, cos_phi);

	return float2(r * cos_phi, r * sin_phi);
}

float3 sample_cosine_weighted_direction(float u1, float u2) {
	float2 d = sample_disc(u1, u2);
	return float3(d.x, d.y, sqrt(abs(1.0f - dot(d, d))));
}

float3 sample(inout float pdf, uint pixel_index) {//Diffuse
	float2 rando = random(5, pixel_index);
	float3 omega_o = sample_cosine_weighted_direction(rando.x, rando.y);
	pdf = omega_o.z * ONE_OVER_PI;
	return omega_o;
}

float3 sample(inout float pdf, int rand, uint pixel_index) {//Diffuse
	float2 rando = random(rand, pixel_index);
	float3 omega_o = sample_cosine_weighted_direction(rando.x, rando.y);
	pdf = omega_o.z * ONE_OVER_PI;
	return omega_o;
}

float3x3 GetTangentSpace(float3 normal) {
	// Choose a helper floattor for the cross product
	float3 helper = float3(1, 0, 0);
	if (abs(normal.x) > 0.99f)
		helper = float3(0, 0, 1);

	// Generate floattors
	float3 tangent = normalize(cross(normal, helper));
	float3 binormal = cross(normal, tangent);

	return float3x3(tangent, binormal, normal);
}
float3x3 GetTangentSpace2(float3 normal) {
	// Choose a helper floattor for the cross product
	float3 helper = float3(1, 0, 0);
	if (abs(normal.x) > 0.99f)
		helper = float3(0, 0, 1);

	// Generate floattors
	float3 tangent = normalize(cross(normal, helper));
	float3 binormal = cross(normal, tangent);

	return float3x3(tangent, normal, binormal);
}


inline float3 local_to_world(const float3 Dir, const float3 tangent, const float3 binormal, const float3 normal) {
	return float3(
		tangent.x * Dir.x + binormal.x * Dir.y + normal.x * Dir.z,
		tangent.y * Dir.x + binormal.y * Dir.y + normal.y * Dir.z,
		tangent.z * Dir.x + binormal.z * Dir.y + normal.z * Dir.z
		);
}

float3 sample_henyey_greenstein(const float3 omega, float g, float u1, float u2) {
	float cos_theta;
	if (abs(g) < 1e-3f) {
		// Isotropic case
		cos_theta = 1.0f - 2.0f * u1;
	}
	else {
		float sqr_term = (1.0f - g * g) / (1.0f + g - 2.0f * g * u1);
		cos_theta = -(1.0f + g * g - sqr_term * sqr_term) / (2.0f * g);
	}
	float sin_theta = sqrt(max(1.0f - cos_theta * cos_theta, 0.0f));

	float phi = (PI * 2.0f) * u2;
	float sin_phi, cos_phi;
	sincos(phi, sin_phi, cos_phi);

	float3 direction = float3(
		sin_theta * cos_phi,
		sin_theta * sin_phi,
		cos_theta
		);

	float3 v1, v2;
	orthonormal_basis(omega, v1, v2);

	return local_to_world(direction, v1, v2, omega);
}

bool VolumetricScatter(inout float3 throughput, RayHit hit, inout Ray ray, inout float3 Pos, HitMat hitDat, uint pixel_index) {
	float3 SigmaS = hitDat.surfaceColor;
	float3 SigmaA = hitDat.transmittanceColor;

	bool medium_can_scatter = (SigmaS.x + SigmaS.y + SigmaS.z) > 0.0f;

	if (medium_can_scatter) {
		float2 rand_scatter = random(3, pixel_index);
		float2 rand_phase = random(5, pixel_index);

		float3 sigma_t = SigmaA + SigmaS;

		float throughput_sum = throughput.x + throughput.y + throughput.z;
		float3 wavelength_pdf = throughput / throughput_sum;

		float sigma_t_used_for_sampling;
		if (rand_scatter.x * throughput_sum < throughput.x) {
			sigma_t_used_for_sampling = sigma_t.x;
		}
		else if (rand_scatter.x * throughput_sum < throughput.x + throughput.y) {
			sigma_t_used_for_sampling = sigma_t.y;
		}
		else {
			sigma_t_used_for_sampling = sigma_t.z;
		}

		float scatter_distance = -log(rand_scatter.y) / sigma_t_used_for_sampling;
		float dist = min(scatter_distance, hit.t);
		float3 transmittance = float3(
			exp(-sigma_t.x * dist),
			exp(-sigma_t.y * dist),
			exp(-sigma_t.z * dist)
			);

		if (scatter_distance < hit.t) {
			float3 pdf = wavelength_pdf * sigma_t * transmittance;
			throughput *= SigmaS * transmittance / (pdf.x + pdf.y + pdf.z);

			float3 direction_out = sample_henyey_greenstein(-ray.direction, hitDat.roughness, rand_phase.x, rand_phase.y);

			float3 ray_origin = ray.origin;
			ray.origin = ray_origin + scatter_distance * ray.direction;
			Pos = ray.origin;
			ray.direction = direction_out;
			return true;
		}
		else {
			float3 pdf = wavelength_pdf * transmittance;
			throughput *= transmittance / (pdf.x + pdf.y + pdf.z);
			return false;
		}
	}
	return false;
}

float3 SunDir;





inline float power_heuristic(float pdf_f, float pdf_g) {
	return (pdf_f * pdf_f) / (pdf_f * pdf_f + pdf_g * pdf_g); // Power of 2 hardcoded, best empirical results according to Veach
}

inline float luminance(const float r, const float g, const float b) {
	return 0.299f * r + 0.587f * g + 0.114f * b;
}


void sampleEquiAngular(float u, float maxDistance, float3 rOrigin, float3 rDirection, float3 lightPos, inout float dist, inout float pdf)
{
	// get coord of closest point to light along (infinite) ray
	float delta = clamp(dot(lightPos - rOrigin, rDirection), 0.0, 1.0);

	// get distance this point is from light
	float D = distance(rOrigin + delta * rDirection, lightPos);

	// get angle of endpoints
	float thetaA = atan((0.0 - delta) / D);
	float thetaB = atan((maxDistance - delta) / D);

	// take sample
	float t = D * tan(lerp(thetaA, thetaB, u));
	dist = delta + t;
	pdf = D / ((thetaB - thetaA) * (D * D + t * t));
}


float AreaOfTriangle(float3 pt1, float3 pt2, float3 pt3) {
	float a = distance(pt1, pt2);
	float b = distance(pt2, pt3);
	float c = distance(pt3, pt1);
	float s = (a + b + c) / 2.0f;
	return sqrt(s * (s - a) * (s - b) * (s - c));
}


static const float sigma_s = 0.09, sigma_a = 0.06, sigma_t = sigma_s + sigma_a;

inline float3 sampleHG(float g, float e1, float e2) {
	//double s=2.0*e1-1.0, f = (1.0-g*g)/(1.0+g*s), cost = 0.5*(1.0/g)*(1.0+g*g-f*f), sint = sqrt(1.0-cost*cost);
	float s = 1.0 - 2.0 * e1, cost = (s + 2.0 * g * g * g * (-1.0 + e1) * e1 + g * g * s + 2.0 * g * (1.0 - e1 + e1 * e1)) / ((1.0 + g * s) * (1.0 + g * s)), sint = sqrt(1.0 - cost * cost);
	return float3(cos(2.0 * PI * e2) * sint, sin(2.0 * PI * e2) * sint, cost);
}

inline float sampleSegment(float epsilon, float sigma, float smax) {
	return -log(1.0 - epsilon * (1.0 - exp(-sigma * smax))) / sigma;
}


inline void generateOrthoBasis(inout float3 u, inout float3 v, float3 w) {
	float3 coVec = w;
	if (abs(w.x) <= abs(w.y)) {
		if (abs(w.x) <= abs(w.z)) coVec = float3(0, -w.z, w.y);
		else coVec = float3(-w.y, w.x, 0);
	}
	else if (abs(w.y) <= abs(w.z)) {
		coVec = float3(-w.z, 0, w.x);
	}
	else coVec = float3(-w.y, w.x, 0);
	coVec *= 1 / sqrt(dot(coVec, coVec));
	u = w % coVec,
		v = w % u;
}

inline float scatter(const Ray r, inout float3 dir, inout float dist, float tin, float tout, float3x3 TanNorm, uint pixel_index) {
	dist = sampleSegment(random(23, pixel_index).x, sigma_s, tout - tin);
	//Vec dir = sampleSphere(XORShift::frand(), XORShift::frand()); //Sample a direction ~ uniform phase function
	dir = sampleHG(-0.5, random(95, pixel_index).x, random(95, pixel_index).y); //Sample a direction ~ Henyey-Greenstein's phase function
	float3 u, v = 0;
	// GetTangentSpace
	// generateOrthoBasis(u, v, r.direction);
	dir = ToWorld(TanNorm, dir);
	return (1.0 - exp(-sigma_s * (tout - tin)));
}


inline bool EvaluateBsdf(const HitMat hitDat, float3 DirectionIn, float3 DirectionOut, float3 Normal, out float PDF, out float3 bsdf_value, uint pixel_index) {
	float throwaway = 0;
	bool validbsdf = false;
	float cos_theta_hit = dot(DirectionOut, Normal);
	[branch] switch (hitDat.MatType) {//Switch between different materials
		default:
			validbsdf = evaldiffuse(DirectionOut, cos_theta_hit, bsdf_value, PDF);
			bsdf_value *= hitDat.surfaceColor;
		break;
		case DisneyIndex:
			bsdf_value = EvaluateDisney(hitDat, -DirectionIn, DirectionOut, hitDat.Thin == 1, PDF, throwaway, GetTangentSpace2(Normal), pixel_index);// DisneyEval(mat, -PrevDirection, norm, to_light, bsdf_pdf, hitDat);
			validbsdf = PDF > 0;
		break;
		case CutoutIndex:
			bsdf_value = EvaluateDisney(hitDat, -DirectionIn, DirectionOut, hitDat.Thin == 1, PDF, throwaway, GetTangentSpace2(Normal), pixel_index);// DisneyEval(mat, -PrevDirection, norm, to_light, bsdf_pdf, hitDat);
			validbsdf = PDF > 0;
		break;
		case VolumetricIndex:
			validbsdf = true;
		break;
	}
	return validbsdf;
}
inline bool ReconstructBsdf(const HitMat hitDat, float3 DirectionIn, float3 DirectionOut, float3 Normal, out float PDF, out float3 bsdf_value, int Case, const float3x3 TangentSpaceNorm, uint pixel_index) {
	float throwaway = 0;
	bool validbsdf = false;
	float cos_theta_hit = dot(DirectionOut, Normal);
	bsdf_value = 0;
	PDF = 0;
	[branch] switch (hitDat.MatType) {//Switch between different materials
		default:
			validbsdf = evaldiffuse(DirectionOut, cos_theta_hit, bsdf_value, PDF);
			bsdf_value = hitDat.surfaceColor;
		break;
		case DisneyIndex:
			bsdf_value = ReconstructDisney(hitDat, -DirectionIn, DirectionOut, false, PDF, TangentSpaceNorm, Case, Normal, validbsdf, pixel_index);
		break;
		case CutoutIndex:
			bsdf_value = ReconstructDisney(hitDat, -DirectionIn, DirectionOut, false, PDF, TangentSpaceNorm, Case, Normal, validbsdf, pixel_index);
		break;
		case VolumetricIndex:
			validbsdf = true;
		break;
	}
	return validbsdf;
}


float A;
bool ChangedExposure;
int RISCount;

int SelectUnityLight(int pixel_index, out float lightWeight, float3 Norm, float3 Position, float3 RayDir, HitMat hitmat) {
	lightWeight = 1;
	if (unitylightcount == 1) return 0;
	float2 Rand = random(0, pixel_index);
	if(RISCount == 0)	return clamp((Rand.y * unitylightcount), 0, unitylightcount - 1);
	int MinIndex = 0;
	float wsum = 0;
	int M = 0;
	float MinP_Hat = 0;
	for(int i = 0; i < RISCount; i++) {
		Rand = random(i, pixel_index);
		int Index = clamp((Rand.x * unitylightcount), 0, unitylightcount - 1);
		LightData light = _UnityLights[Index];
		float3 Pos = light.Type == 1 ? (light.Direction * 120000.0f + Position) : light.Position;
		float3 to_light = Pos - Position;
		float LengthSquared = dot(to_light, to_light);
		to_light /= sqrt(LengthSquared);
		float3 bsdf_value;
		float bsdf_pdf;
		bool A = EvaluateBsdf(hitmat, RayDir, to_light, Norm, bsdf_pdf, bsdf_value, pixel_index);
		// bool A = evaldiffuse(to_light, dot(to_light, Norm), bsdf_value, bsdf_pdf);
		float p_hat = luminance(bsdf_value * light.Radiance) / ((light.Type == 1) ? 1 : LengthSquared) * ((light.Type == 2) ? saturate(saturate(dot(to_light, -light.Direction)) * light.SpotAngle.x + light.SpotAngle.y) : 1);
		wsum += p_hat;
		M++;
		if(Rand.y < p_hat / wsum) {
			MinIndex = Index;
			MinP_Hat = p_hat;
		}

	}
	lightWeight = wsum / max((M + 1) *MinP_Hat, 0.000001f);
	return MinIndex;
}

float2 msign( float2 v )
{
    return float2( (v.x>=0.0) ? 1.0 : -1.0, 
                 (v.y>=0.0) ? 1.0 : -1.0 );
}

uint octahedral_32( in float3 nor )
{
    nor.xy /= ( abs( nor.x ) + abs( nor.y ) + abs( nor.z ) );
    nor.xy  = (nor.z >= 0.0) ? nor.xy : (1.0-abs(nor.yx))*msign(nor.xy);
    //return packSnorm2x16(nor.xy);
    uint2 d = uint2(round(32767.5 + nor.xy*32767.5));  return d.x|(d.y<<16u);
}
float3 i_octahedral_32( uint data )
{
    //vec2 v = unpackSnorm2x16(data);
    uint2 iv = uint2( data, data>>16u ) & 65535u; float2 v = float2(iv)/32767.5 - 1.0;
    float3 nor = float3(v, 1.0 - abs(v.x) - abs(v.y)); // Rune Stubbe's version,
    float t = max(-nor.z,0.0);                     // much faster than original
    nor.x += (nor.x>0.0)?-t:t;                     // implementation of this
    nor.y += (nor.y>0.0)?-t:t;                     // technique
    return normalize( nor );
}

void calcFinalColor(inout Ray ray, inout ColData Color, HitMat hitDat, RayHit hit, uint2 Uv, float2 NormalUV, bool HitVoxel, bool IsEmissiveTex, RayData RayDat, MaterialData mat, int prevIndex, bool HitHeightmap, const uint pixel_index, int PixIndex) {//main function
bool cb = (int(Uv.x)/2 + int(Uv.y)/2 + frames_accumulated)%2==0;
	float3 pos = ray.direction * hit.t + ray.origin;
	float3 PrevDirection = ray.direction;
	float3 PrevOrigin = ray.origin;
	const uint index = hit.triangle_id;
	const int Index = Uv.x + Uv.y * screen_width;
	float3 Geomnorm;
	[branch] if (TerrainExists && HitHeightmap) {
		Geomnorm.x = (GetHeight(pos + float3(0.01f, 0, 0), Terrains[hit.triangle_id]) - GetHeight(pos - float3(0.01f, 0, 0), Terrains[hit.triangle_id]));
		Geomnorm.y = (GetHeight(pos + float3(0, 0.01f, 0), Terrains[hit.triangle_id]) - GetHeight(pos - float3(0, 0.01f, 0), Terrains[hit.triangle_id]));
		Geomnorm.z = (GetHeight(pos + float3(0, 0, 0.01f), Terrains[hit.triangle_id]) - GetHeight(pos - float3(0, 0, 0.01f), Terrains[hit.triangle_id]));
		Geomnorm = normalize(Geomnorm);
	}
	else {
		float3 Normsx = i_octahedral_32(AggTris[index].norms.x);
		Geomnorm = (DoVoxels || !HitVoxel) ? normalize(mul(_MeshData[hit.mesh_id].Inverse, float4(Normsx + hit.u * (i_octahedral_32(AggTris[index].norms.y) - Normsx) + hit.v * (i_octahedral_32(AggTris[index].norms.z) - Normsx), 0.0f)).xyz) : float3(0, 0, 0);
	}

	const float3 PrevThroughput = Color.throughput;
	if (DoVoxels && HitVoxel) {
		Geomnorm = float3(1, 0, 0);
		float3 VoxPos = floor(mul(_MeshData[hit.mesh_id].Transform, float4(ray.origin + ray.direction * hit.t, 1)).xyz) + 0.5f;
		float3 initdiff = mul(_MeshData[hit.mesh_id].Transform, float4(pos, 1)).xyz - VoxPos;
		float Greatest = max(max(abs(initdiff.x), abs(initdiff.y)), abs(initdiff.z));
		if (Greatest == abs(initdiff.y)) Geomnorm = float3(0, 1, 0);
		if (Greatest == abs(initdiff.z)) Geomnorm = float3(0, 0, 1);
		Geomnorm = normalize(mul(_MeshData[hit.mesh_id].Inverse, float4(Geomnorm, 0)).xyz);
	}
	// _DebugTex[Uv] = float4(hit.u, hit.v, 0, 1);
	bool GotFlipped = false;
	[branch] if (dot(ray.direction, Geomnorm) >= 0.0f) {
		Geomnorm *= -1;
		GotFlipped = true;
	}
	float3 norm = Geomnorm;
	[branch] if (NormalUV.x != -1) {//Handle Normal Maps
		float3 Tansx = i_octahedral_32(AggTris[index].tans.x);
		float3 LocalTan = normalize(mul(_MeshData[hit.mesh_id].Inverse, float4(Tansx + hit.u * (i_octahedral_32(AggTris[index].tans.y) - Tansx) + hit.v * (i_octahedral_32(AggTris[index].tans.z) - Tansx), 0.0f)).xyz);
		float3 LocalBinorm = normalize(cross(Geomnorm, LocalTan));
		float2 Norm = _NormalAtlas.SampleLevel(sampler_NormalAtlas, NormalUV, 0);
		float2 InputNormal;
		InputNormal = Norm.rg;

		float3 LocalNormIN = float3((2.0f * InputNormal.xy - 1.0f), 0.0f);
		LocalNormIN.z = 1.0 - 0.5 * dot(LocalNormIN, LocalNormIN);
		norm = normalize(mul(normalize(LocalNormIN), float3x3(LocalTan, LocalBinorm, Geomnorm)).xyz);
		norm = clamp(norm, -1, 1);
		if (abs(norm.x) == abs(norm.y) == abs(norm.z)) norm = Geomnorm;
	}
	if (CurBounce == 1) {
		 ScreenSpaceInfo[PixIndex].ReflectedT = hit.t;
	}
	[branch] if (UseReSTIRGI && CurBounce == 0) {//Initialize Buffer
		CurrentReservoirGI[Index].M = 0;
		CurrentReservoirGI[Index].LuminanceIncomming = 0;
		CurrentReservoirGI[Index].HistoricFrame = curframe;
		CurrentReservoirGI[Index].HistoricID = (Uv.x + Uv.y * screen_width);
	}

	[branch] if (hitDat.emmis > 0.0f) {//if we hit a light, this ray is done
		if (!UseNEE || IsEmissiveTex) {
			if (CurBounce == 0) {
				Color.Direct = hitDat.emmis;

				TempAlbedoTex[Uv] = float4(hitDat.surfaceColor, 0);
			}
			else if (CurBounce == 1) {
				Color.Direct += hitDat.surfaceColor * (hitDat.emmis);

				CurrentReservoirGI[Index].SecondaryHitPosition = pos;
			}
			else {
				Color.Indirect += Color.throughput * hitDat.emmis * hitDat.surfaceColor;
			}
		}
		else {
			float3 a0 = mul(_MeshData[hit.mesh_id].Inverse, float4(AggTris[index].pos0, 1)).xyz;
			float3 a1 = mul(_MeshData[hit.mesh_id].Inverse, float4(AggTris[index].pos0 + AggTris[index].posedge1, 1)).xyz;
			float3 a2 = mul(_MeshData[hit.mesh_id].Inverse, float4(AggTris[index].pos0 + AggTris[index].posedge2, 1)).xyz;

			float a = AreaOfTriangle(a0, a1, a2);
			float SA = abs(dot(norm, ray.direction)) * a / (hit.t * hit.t);
			float light_pdf = 1.0f / (SA * LightMeshCount) * ((_LightMeshes[LightMeshCount - 1].CDF / (_UnityLights[unitylightcount - 1].CDF + _LightMeshes[LightMeshCount - 1].CDF))) * (a / _MeshData[hit.mesh_id].LightPDF);
			float w = power_heuristic(max(RayDat.last_pdf,0), light_pdf);
			if (CurBounce == 0) {
				Color.Direct = hitDat.emmis * hitDat.surfaceColor;
				TempAlbedoTex[Uv] = float4(hitDat.surfaceColor, 0);
			}
			else if (CurBounce == 1) {
				Color.Direct += (hitDat.surfaceColor * hitDat.emmis) * w;
				CurrentReservoirGI[Index].SecondaryHitPosition = pos;
			}
			else {
				Color.Indirect += Color.throughput * hitDat.surfaceColor * hitDat.emmis * w;
			}
		}
		return;
	}
	float3 throughput = Color.throughput;

	float3 tempraydir = float3(0.0f, 0.0f, 0.0f);
	bool valid = true;
	float pdf = 0.0f;

	float3 omega_i = mul(GetTangentSpace(norm), -ray.direction);

	int Case = 0;
		BsdfSample Thissample = initbsdf();
		bool2 tempvalid;
		if(RandomNums[Uv].z == 1 && !UseASVGF && ReSTIRGIUpdateRate != 0 && CurBounce == 0) {
			float RayDir = ray.direction;
			float3 bsdf_value;
			float fpdf;
			valid = ReconstructBsdf(hitDat, RayDir, normalize(PreviousReservoirGI[prevIndex].SecondaryHitPosition - (pos + Geomnorm * 0.001f)), norm, fpdf, bsdf_value, PreviousReservoirGI[prevIndex].ThisCase.x, GetTangentSpace2(norm), pixel_index);
			pdf = fpdf;
			ray.direction = normalize(PreviousReservoirGI[prevIndex].SecondaryHitPosition - (pos + Geomnorm * 0.001f));
			throughput *= max(bsdf_value, 0.000001f);
			if(CurBounce == 0) CurrentReservoirGI[Index].ThisCase = PreviousReservoirGI[prevIndex].ThisCase;

			} else {
		[branch] switch (hitDat.MatType) {//Switch between different materials
			case DisneyIndex://Disney BSDF
				if (!GotFlipped) {
					hitDat.relativeIOR = rcp(hitDat.ior);
				}
				tempvalid = SampleDisney(hitDat, -ray.direction, hitDat.Thin == 1, Thissample, GetTangentSpace2(norm), Case, pixel_index);
				valid = tempvalid.x;
				ray.direction = Thissample.wi;
				pdf = Thissample.forwardPdfW;
				throughput *= max(Thissample.reflectance, 0.000001f);
				if (CurBounce == 0 && Case == 0) Color.IsSpecular = 1;
				if (CurBounce == 0) {
					uint A = hitDat.metallic * 0xFFFF;
					uint B = hitDat.roughness * 0xFFFF;
					uint ABPacked = (A << 16) | (B & 0xFFFF);
					Color.pad = asfloat(ABPacked);
				}
				if(CurBounce == 0) CurrentReservoirGI[Index].ThisCase = Case;
				// valid = valid && all(Thissample.reflectance < 0 || Thissample.reflectance > 0 || Thissample.reflectance == 0) && all(Thissample.forwardPdfW <= 1);

				if (tempvalid.y) {
					Geomnorm *= -1; norm *= -1;
				}
			break;
			case CutoutIndex://mask material
				Thissample = initbsdf();
				if (!GotFlipped) {
					hitDat.relativeIOR = rcp(hitDat.ior);
				}
				tempvalid = SampleDisney(hitDat, -ray.direction, hitDat.Thin == 1, Thissample, GetTangentSpace2(norm), Case, pixel_index);
				valid = tempvalid.x;
				ray.direction = Thissample.wi;
				pdf = Thissample.forwardPdfW;
				throughput *= max(Thissample.reflectance, 0.000001f);
				if (CurBounce == 0 && Case == 0) Color.IsSpecular = 1;
				if (CurBounce == 0) {
					uint A = hitDat.metallic * 0xFFFF;
					uint B = hitDat.roughness * 0xFFFF;
					uint ABPacked = (A << 16) | (B & 0xFFFF);
					Color.pad = asfloat(ABPacked);
				}
				if(CurBounce == 0) CurrentReservoirGI[Index].ThisCase = Case;
				// valid = valid && all(Thissample.reflectance < 0 || Thissample.reflectance > 0 || Thissample.reflectance == 0) && all(Thissample.forwardPdfW <= 1);

				if (tempvalid.y) {
					Geomnorm *= -1; norm *= -1;
				}
			break;
			case VolumetricIndex://"Volumetric" material
				if (GotFlipped) {
					if (VolumetricScatter(throughput, hit, ray, pos, hitDat, pixel_index)) {
						norm = -norm;
						Geomnorm = -Geomnorm;
					}
				}
				else {
					ray.direction = ray.direction;
					norm = -norm;
					Geomnorm = -Geomnorm;
				}
			break;
			case VideoIndex:
				ray.direction = normalize(mul(sample(pdf, pixel_index), GetTangentSpace(norm)));
				valid = pdf > 0;
				throughput *= hitDat.surfaceColor;
			break;
			default:
				ray.direction = normalize(mul(sample(pdf, pixel_index), GetTangentSpace(norm)));
				valid = pdf > 0;
				throughput *= hitDat.surfaceColor;
			break;
		}
	}
		if (!valid) return;//If the ray failed, we have no choice but to terminate this path


	ray.origin = Geomnorm * 0.001f + pos;//Offset the ray origin so we dont self intersect with the triangle we just bounced off of

	[branch] if (UseReSTIRGI && CurBounce == 1) {
		CurrentReservoirGI[Index].SecondaryHitPosition = pos;
	}
	if(UseAlteredPipeline) {
		[branch] if (CurBounce == 0 || TempAlbedoTex[Uv].w == -1) {//Setting textures for denosier to use
			CurrentReservoirGI[PixIndex].PrimaryNormal = packUnormArb(Geomnorm);
			ScreenSpaceData TempMatModifier = { hitDat.Specular, hitDat.roughness, hitDat.clearcoat, hitDat.clearcoatGloss, hitDat.metallic, max(hitDat.surfaceColor, 0.00001f), hitDat.ior, packUnormArb(Geomnorm), pos, hit.t, ray.direction, packUnormArb(norm),0};
			ScreenSpaceInfo[PixIndex] = TempMatModifier;
			TempAlbedoTex[Uv] = float4(max(hitDat.surfaceColor, 0.00001f), 1);
			if (CurBounce == 0) CurrentReservoirGI[Index].BaseColor = packRGBE(max(hitDat.surfaceColor, 0.00001f));
			throughput = 1;//max(hitDat.surfaceColor,0.00001f);
		}
	} else {
		[branch] if (CurBounce == 0 || TempAlbedoTex[Uv].w == -1) {//Setting textures for denosier to use
			CurrentReservoirGI[PixIndex].PrimaryNormal = packUnormArb(Geomnorm);
			ScreenSpaceData TempMatModifier = { hitDat.Specular, hitDat.roughness, hitDat.clearcoat, hitDat.clearcoatGloss, hitDat.metallic, max(hitDat.surfaceColor, 0.00001f), hitDat.ior, packUnormArb(Geomnorm), pos, hit.t, ray.direction, packUnormArb(norm),0};
			ScreenSpaceInfo[PixIndex] = TempMatModifier;
			TempAlbedoTex[Uv] = float4(max(throughput, 0.00001f), 1);
			if (CurBounce == 0) CurrentReservoirGI[Index].BaseColor = packRGBE(max(throughput, 0.00001f));
			throughput = 1;
		}	
	}
	[branch] if ((UseNEE) && CurBounce < MaxBounce && !hitDat.DoesPassThrough) {//Next event estimation
		float3 pos2;
		float3 LightNorm;
		int triindex;
		bool IsAboveHorizon = true;
		bool IsDirectional = false;
		float LightPDF = 0.0f;
		bool UseUnityLight;
		int TriCount = 0;
		int MeshIndex = 0;
		Reservoir CurRes = CurrentReservoir[Index];
		float2 CurUv = 0;
		float Attenuation = 1.0f;
		bool IsSpecialized = false;
		float LightWeight = 1;
		UseUnityLight = (unitylightcount != 0) ? (LightMeshCount != 0) ? (random(11, pixel_index).x <= (_UnityLights[unitylightcount - 1].CDF / (_UnityLights[unitylightcount - 1].CDF + _LightMeshes[LightMeshCount - 1].CDF))) : true : false;//Choose whether to sample unity lights or mesh lights based off which is more powerful
		if (UseUnityLight) {
			triindex = SelectUnityLight(pixel_index, LightWeight, norm, pos, PrevDirection, hitDat);
			LightData Light = _UnityLights[triindex];
			[branch] switch (Light.Type) {
			default:
				pos2 = Light.Position;
				LightNorm = normalize(ray.origin - pos2);
				break;
			case 1:
				pos2 = ray.origin + Light.Direction;
				LightNorm = -Light.Direction;
				IsAboveHorizon = (LightNorm.y <= 0.0f);
				IsDirectional = true;
				break;
			case 2:
				pos2 = Light.Position;
				LightNorm = Light.Direction;
				IsAboveHorizon = false;
				IsSpecialized = true;
				break;
			case 3:
				IsSpecialized = true;
				float3 randVector = (float3(random(43, pixel_index).x * Light.SpotAngle.x, random(43, pixel_index).y * Light.SpotAngle.y, 0)) - float3(Light.SpotAngle.x, Light.SpotAngle.y, 0) / 2;
				float3 oldRand = randVector;
				Light.ZAxisRotation *= PI / 180.0f;
				randVector = float3(oldRand.x * cos(Light.ZAxisRotation) - oldRand.y * sin(Light.ZAxisRotation), oldRand.y * cos(Light.ZAxisRotation) + oldRand.x * sin(Light.ZAxisRotation), 0);
				float3 tangent0 = cross(Light.Direction, float3(0, 1, 0));
				if (dot(tangent0, tangent0) < 0.001f) tangent0 = cross(Light.Direction, float3(1, 0, 0));
				tangent0 = normalize(tangent0);
				float3 tangent1 = normalize(cross(Light.Direction, tangent0));
				float3x3 rotationmatrix = { tangent0, tangent1, Light.Direction };
				float3 Length = length(randVector);
				pos2 = Light.Position + mul(normalize(randVector), rotationmatrix) * Length;// - float3(Light.SpotAngle.x, 0, Light.SpotAngle.y) / 2;
				LightNorm = Light.Direction;
				break;
			}
		}
		else {
			MeshIndex = SelectLightMesh(pixel_index);
			triindex = SelectLight(MeshIndex, false, pixel_index);
			TrianglePos CurTri = triangle_get_positions2(triindex);
			float2 rand_triangle = random(24, pixel_index);
			CurUv = sample_triangle(rand_triangle.x, rand_triangle.y);
			pos2 = mul(_LightMeshes[MeshIndex].Inverse, float4(CurTri.pos0 + CurUv.x * CurTri.posedge1 + CurUv.y * CurTri.posedge2, 1.0f)).xyz;
			LightNorm = normalize(mul(_LightMeshes[MeshIndex].Inverse, float4(LightTriangles[triindex].Norm, 0.0f)).xyz);
			TriCount = (_LightMeshes[MeshIndex].IndexEnd - _LightMeshes[MeshIndex].StartIndex);
		}
		float3 to_light = pos2 - ray.origin;

		float distance_to_light_squared = dot(to_light, to_light);
		float distance_to_light = sqrt(max(distance_to_light_squared, 0.0f));

		to_light = to_light / distance_to_light;
		if (IsDirectional) {
			float diskRadius = 2 * sin(0.5f * PI / 180.0f);
			float2 rand = random(23, pixel_index);
			float3 DirectionAdjustment = float3(diskRadius * cos(rand.x * 2 * PI), diskRadius * sin(rand.y * 2 * PI), 0);
			float3 DirectionNormal = float3(0, 0, 1);
			float3 z = normalize(cross(DirectionNormal, to_light));
			float3 y = normalize(cross(z, DirectionNormal));
			float3x3 rotationmatrix = float3x3(
				DirectionNormal.x, y.x, z.x,
				DirectionNormal.y, y.y, z.y,
				DirectionNormal.z, y.z, z.z
				);
			to_light = normalize(to_light + (mul(DirectionAdjustment, rotationmatrix)));
		}
		Attenuation = (IsSpecialized) ? saturate(dot(to_light, -LightNorm)) : 1;
		if (!IsDirectional && !IsAboveHorizon) {
			Attenuation = saturate(Attenuation * _UnityLights[triindex].SpotAngle.x + _UnityLights[triindex].SpotAngle.y);
			IsAboveHorizon = true;
		}

		bool validbsdf = false;
		float3 bsdf_value = 0.0f;
		float bsdf_pdf = 0.0f;
		float throwaway = 0;

		float cos_theta_light = abs(dot(to_light, LightNorm));
		float cos_theta_hit = dot(to_light, norm);
		[branch] switch (hitDat.MatType) {//Switch between different materials
			default:
				validbsdf = evaldiffuse(to_light, cos_theta_hit, bsdf_value, bsdf_pdf);
				bsdf_value *= hitDat.surfaceColor;
			break;
			case DisneyIndex:
				bsdf_value = EvaluateDisney(hitDat, -PrevDirection, to_light, hitDat.Thin == 1, bsdf_pdf, throwaway, GetTangentSpace2(norm), pixel_index);// DisneyEval(mat, -PrevDirection, norm, to_light, bsdf_pdf, hitDat);
				validbsdf = bsdf_pdf > 0;
			break;
			case CutoutIndex:
				bsdf_value = EvaluateDisney(hitDat, -PrevDirection, to_light, hitDat.Thin == 1, bsdf_pdf, throwaway, GetTangentSpace2(norm), pixel_index);// DisneyEval(mat, -PrevDirection, norm, to_light, bsdf_pdf, hitDat);
				validbsdf = bsdf_pdf > 0;
			break;
			case VolumetricIndex:
				validbsdf = true;
			break;
		}

		float LightCos = abs(dot(to_light, LightNorm));
		float SurfaceCos = dot(to_light, norm);
		if (SurfaceCos > 0 && LightWeight < 10000.0f) {
			float3 Radiance;
			float NEE_pdf;
			float3 Illum;
			float RadianceIncomming;
			if (UseUnityLight) {
				float3 transmittance = 1;
				if (IsDirectional) {
					float3 Radiance = GetSkyRadiance(ray.origin, to_light, 0, SunDir, transmittance);
				}
				RadianceIncomming = luminance(_UnityLights[triindex].Radiance);
				Radiance = _UnityLights[triindex].Radiance * transmittance;
				NEE_pdf = distance_to_light_squared * LightCos / (unitylightcount) * (_UnityLights[unitylightcount - 1].CDF / (_UnityLights[unitylightcount - 1].CDF + _LightMeshes[LightMeshCount - 1].CDF));
				Illum = PrevThroughput * (Radiance * bsdf_value) / NEE_pdf * Attenuation * LightWeight;// / max(hitDat.surfaceColor, 0.0000001f);
			}
			else {
				float SA = LightCos * LightTriangles[triindex].area / distance_to_light_squared;
				NEE_pdf = (1.0f / (LightMeshCount * SA)) * (LightTriangles[triindex].pdf / _LightMeshes[MeshIndex].pdf) * (_LightMeshes[LightMeshCount - 1].CDF / (_UnityLights[unitylightcount - 1].CDF + _LightMeshes[LightMeshCount - 1].CDF));
				Radiance = LightTriangles[triindex].radiance;
				int MaterialIndex = LightTriangles[triindex].MatIndex + _LightMeshes[MeshIndex].MatOffset;
				if (_Materials[MaterialIndex].MatType == VideoIndex || _Materials[MaterialIndex].HasEmissiveTex > 0) {
					float2 BaseUv = LightTriangles[triindex].UV1 * (1.0f - CurUv.x - CurUv.y) + LightTriangles[triindex].UV2 * CurUv.x + LightTriangles[triindex].UV3 * CurUv.y;
					if (_Materials[MaterialIndex].MatType == VideoIndex) {
						Radiance *= VideoTex.SampleLevel(sampler_VideoTex, BaseUv, 0).xyz;
					}
					else {
						float2 EmissionUV = fmod(BaseUv + 100.0f, float2(1.0f, 1.0f)) * (_Materials[MaterialIndex].EmissiveTex.xy - _Materials[MaterialIndex].EmissiveTex.zw) + _Materials[MaterialIndex].EmissiveTex.zw;
						Radiance *= _EmissiveAtlas.SampleLevel(sampler_EmissiveAtlas, EmissionUV, 0).xyz * _EmissiveAtlas.SampleLevel(sampler_EmissiveAtlas, EmissionUV, 0).w;
					}
				}
				RadianceIncomming = luminance(Radiance);
				float NEEMISWeight = power_heuristic(NEE_pdf, bsdf_pdf);
				Illum = PrevThroughput * (Radiance * bsdf_value) / NEE_pdf * Attenuation * NEEMISWeight;// / max(hitDat.surfaceColor, 0.0000001f);
			}
			if (CurBounce == 0) CurrentReservoirGI[Index].NEEPosition = (IsDirectional) ? (ray.origin + to_light * 10000.0f) : pos2;

			bool DoNEERR = !UseRussianRoulette;
			float maxillum = max(max(Illum.x, Illum.y), Illum.z) * A;
			if ((DoNEERR || maxillum > random(9, pixel_index).y)) {//NEE russian roulette, massively improves performance while giivng the same result
				uint index3;//Congrats we shoot a shadow ray for NEE

				InterlockedAdd(BufferSizes[CurBounce].shadow_rays, 1, index3);
				ShadowRaysBuffer[index3].origin = ray.origin;
				ShadowRaysBuffer[index3].direction = to_light;
				ShadowRaysBuffer[index3].t = (IsDirectional) ? 10000.0f : distance_to_light - 0.00001f;//2.0f * EPSILON;
				ShadowRaysBuffer[index3].illumination = Illum * ((DoNEERR) ? 1 : rcp(saturate(maxillum)));// / (CurBounce == 0 && TempAlbedoTex[Uv].xyz != 0.00001f ? TempAlbedoTex[Uv].xyz : 1);// * max(hitDat.surfaceColor,0.0000001f);
				ShadowRaysBuffer[index3].RadianceIncomming = Illum * ((DoNEERR) ? 1 : rcp(saturate(maxillum))) * ((!UseAlteredPipeline) ? (((bsdf_value == 0) ? 1 : rcp(bsdf_value))) : (((hitDat.surfaceColor == 0) ? 1 : rcp(hitDat.surfaceColor))));
				ShadowRaysBuffer[index3].PixelIndex = Uv.y * screen_width + Uv.x;
				ShadowRaysBuffer[index3].LuminanceIncomming = luminance(Radiance);
				ShadowRaysBuffer[index3].PrimaryNEERay = (CurBounce != 0);
			}
		}
	}
	if (UseRussianRoulette) {
		float3 AdjustedCol = throughput * ((RandomNums[Uv].z == 1 && !UseASVGF && ReSTIRGIUpdateRate != 0) ? unpackRGBE(PreviousReservoirGI[prevIndex].BaseColor) : TempAlbedoTex[Uv].xyz);
		float p = saturate(max(AdjustedCol.x, max(AdjustedCol.y, AdjustedCol.z)));
		if (random(2, pixel_index).x > p && CurBounce > 0)//Simple Russian Roulette
			return;
		if (CurBounce > 0)
			throughput *= rcp(p);//rcp is a slightly faster but less accurate version of 1 / p, I decided the inaccuracy was worth the performance bump
	}
	if (any(throughput > 10000.0f)) return;
	Color.throughput = throughput * ((cb && CurBounce == 0 && DoCheckerboarding || (DoCheckerboarding && UseASVGF && RandomNums[Uv].w == 1 && ReSTIRGIUpdateRate == 0)) ? 2.0f : 1);

	if (cb || !DoCheckerboarding || (UseASVGF && RandomNums[Uv].w == 1 && ReSTIRGIUpdateRate == 0) || (RandomNums[Uv].z == 1 && !UseASVGF && ReSTIRGIUpdateRate != 0)) {
		uint index2;//Congrats, the ray will continue its path
		InterlockedAdd(BufferSizes[CurBounce + 1].tracerays, 1, index2);
		GlobalRays1[index2].origin = ray.origin;
		GlobalRays1[index2].direction = ray.direction;
		GlobalRays1[index2].PixelIndex = Uv.x + Uv.y * screen_width;
		GlobalRays1[index2].PrevIndex = prevIndex;
		GlobalRays1[index2].last_pdf = pdf;
		set(index2, hit);
	}
}

Texture2D<float4> TerrainAlphaMap;
SamplerState sampler_TerrainAlphaMap;
int MaterialCount;

int2 Unpack1To2(int A) {
	return int2(A >> 16, A & 0x0000FFFF);
}

[numthreads(64, 1, 1)]
void kernel_shade(uint3 id : SV_DispatchThreadID) {

	int index = id.x;
	// InterlockedAdd(BufferSizes[CurBounce].shade_rays, 1, index);
	if (index >= BufferSizes[CurBounce].tracerays) return;
	int PixIndex = GlobalRays1[index].PixelIndex;
	uint2 TempUv = uint2(PixIndex % screen_width, PixIndex / screen_width);
	const uint pixel_index = PixIndex;//TempUv is the origional screen coordinates of the ray

	Ray ray;
	RayHit bestHit = get(index);
	ray.origin = GlobalRays1[index].origin;
	ray.direction = GlobalRays1[index].direction;
	ray.direction_inv = float3(0.0f, 0.0f, 0.0f);//We dont need to calculate this, but we do need to give it some value or Unity complains

	#ifdef HardwareRT
		int2 Indexes = Unpack1To2(bestHit.mesh_id);
		// GlobalColors[PixIndex].Direct = Indexes.y / 4.0f;
		//y is instance ID, x is submesh index
		// return;
		int triangleOffset = SubMeshOffsets[MeshOffsets[Indexes.y].x + Indexes.x];
		bestHit.triangle_id += triangleOffset;
		// bestHit.triangle_id = CWBVHIndices[bestHit.triangle_id];
		bestHit.mesh_id = MeshOffsets[Indexes.y].y;
	#endif
	ColData Color = GlobalColors[PixIndex];
	if (bestHit.t == FarPlane) {//if ray goes into the void, sample skybox
		float3 SkyColAcc;
#ifdef UseSkyBox
		float theta = acos(ray.direction.y) / -PI;
		float phi = atan2(ray.direction.x, -ray.direction.z) / -PI * 0.5f;
		float3 sky = _SkyboxTexture.SampleLevel(sampler_SkyboxTexture, float2(phi, theta), CurBounce == 0 ? 0 : 4).xyz;
		if (CurBounce == 0) {//Seperated into direct and indirect channels
			Color.Direct = sky;
		}
		else if (CurBounce == 1) {
			Color.Direct += sky;
		}
		else {
			Color.Indirect += Color.throughput * sky;
		}
		SkyColAcc = Color.throughput * sky;
#else
float3 Direct = 1;
		float3 transmittance = 0;
		float3 Radiance = GetSkyRadiance(ray.origin, ray.direction, 0, SunDir, transmittance);
	// float3 trans2 = Clouds(SunDir, ray, Direct, luminance(Radiance));
		Radiance = float3(1, 1, 1) - exp(-Radiance / 1 * 10.0f);
		float3 SkyBoxCol = saturate(Radiance);// * Direct + trans2;
		float3 Sun = 0;//(saturate(max(min(exp(-acos(max(dot(-SunDir, -ray.direction), 0.0f))* 60.0f),12.0f),0) * transmittance));
		if (dot(ray.direction, SunDir) > cos(0.0235f / 2.0f)) {
			Sun = saturate(Radiance + transmittance * (1.5f / (PI * (0.0235f / 2.0f) * (0.0235f / 2.0f))));
		}
		// float3 direct;
		// float3 transmittance2 = Clouds(SunDir, ray, direct);
		if (all(SkyBoxCol > 0 || SkyBoxCol < 0 || SkyBoxCol == 0)) {
			if (CurBounce == 0) {//Seperated into direct and indirect channels
				Color.Direct = Color.throughput * ((SkyBoxCol)+Sun);// * transmittance2 + direct;
				// CurrentReservoirGI[TempUv.x + TempUv.y * screen_width].LuminanceIncomming += luminance((SkyBoxCol) + Sun);

			}
			else if (CurBounce == 1) {
				Color.Direct += Color.throughput * (SkyBoxCol)+Sun;
				CurrentReservoirGI[TempUv.x + TempUv.y * screen_width].SecondaryHitPosition = ray.origin + ray.direction * 12.0f;

				CurrentReservoirGI[TempUv.x + TempUv.y * screen_width].LuminanceIncomming += luminance((SkyBoxCol) + Sun);
			}
			else {
				// Color.Indirect += Color.throughput * (SkyBoxCol)+Sun;
				// CurrentReservoirGI[TempUv.x + TempUv.y * screen_width].LuminanceIncomming += luminance(Color.throughput * (SkyBoxCol) + Sun);


			}
		}
#endif
		// float3 col = 0.051f;//float3(0.972549, 0.9568627, 0.9294118);
		//         if(CurBounce == 0) {//Seperated into direct and indirect channels
		//             RenderMaskTex[TempUv] = 0;
		//             Color.Direct = col;
		//         } else if(CurBounce == 1) {
		//             Color.Direct += Color.throughput * col;
		//             CurrentReservoirGI[TempUv.x + TempUv.y * screen_width].SecondaryHitPosition = ray.origin + ray.direction * 12.0f;
		//         } else {
		//             SHData ThisSH = SH[TempUv.x + TempUv.y * screen_width];
		//             accumulate_SH(ThisSH, irradiance_to_SH((Color.throughput * 0.051f) * 1024, ray.direction), 1.0f);
		//             SH[TempUv.x + TempUv.y * screen_width] = ThisSH;
		//             Color.Indirect += Color.throughput * col;
		//         }
		if (CurBounce == 0) {
			TempAlbedoTex[TempUv] = float4(1, 1, 1,0);
		}
		GlobalColors[PixIndex] = Color;
		return;
	}


	float2 BaseUv = AggTris[bestHit.triangle_id].tex0 * (1.0f - bestHit.u - bestHit.v) + AggTris[bestHit.triangle_id].texedge1 * bestHit.u + AggTris[bestHit.triangle_id].texedge2 * bestHit.v;
	int MatOffset = 0;
	bool HitTerrain = false;
	if (TerrainExists && (GlobalRays1[index].HitVoxel == 2)) {
		BaseUv = float2(bestHit.u, bestHit.v);
		float4 Mats = TerrainAlphaMap.SampleLevel(sampler_TerrainAlphaMap, float2(bestHit.u, bestHit.v) * (Terrains[bestHit.triangle_id].AlphaMap.xy - Terrains[bestHit.triangle_id].AlphaMap.zw) + Terrains[bestHit.triangle_id].AlphaMap.zw, 0);

		MatOffset = Mats.y + Mats.z * 2 + Mats.a * 3;
		HitTerrain = true;
	}

	int MaterialIndex = (HitTerrain) ? (MaterialCount + MatOffset + Terrains[bestHit.triangle_id].MatOffset) : (GlobalRays1[index].HitVoxel == 1) ? (_MeshData[bestHit.mesh_id].MaterialOffset + (-(bestHit.triangle_id + 2))) : (_MeshData[bestHit.mesh_id].MaterialOffset + AggTris[bestHit.triangle_id].MatDat);
	MaterialData TempMat = _Materials[MaterialIndex];
	if (HitTerrain) BaseUv = BaseUv * TempMat.BaseColor.xy + TempMat.transmittanceColor.xy;
	else if(TempMat.MatType != VideoIndex) BaseUv = BaseUv * TempMat.TextureScale + TempMat.TextureOffset;

	float2 Uv = fmod(BaseUv + 100.0f, float2(1.0f, 1.0f)) * (_Materials[MaterialIndex].AlbedoTex.xy - _Materials[MaterialIndex].AlbedoTex.zw) + _Materials[MaterialIndex].AlbedoTex.zw;
	float2 NormalUV = (_Materials[MaterialIndex].HasNormalTex == 1) ? fmod(BaseUv + 100.0f, float2(1.0f, 1.0f)) * (_Materials[MaterialIndex].NormalTex.xy - _Materials[MaterialIndex].NormalTex.zw) + _Materials[MaterialIndex].NormalTex.zw : float2(-1, -1);
	HitMat hitmat = CreateHitMat();//Transfer Material properties
	float4 BaseCol = (TempMat.MatType == VideoIndex) ? VideoTex.SampleLevel(sampler_VideoTex, BaseUv, 0) : (TempMat.HasAlbedoTex > 0) ? (_TextureAtlas.SampleLevel(my_point_clamp_sampler, Uv, 0) * ((!HitTerrain) ? float4(TempMat.BaseColor, 1.0f) : 1)) : float4(TempMat.BaseColor, 1.0f);
	hitmat.surfaceColor = BaseCol.xyz * BaseCol.w;
	hitmat.emmis = TempMat.emmissive;
	TempMat.roughness = max(TempMat.roughness, 0.00001f) + max((CurBounce != 0) ? CurBounce / (float)MaxBounce : 0, 0);
	hitmat.roughness = max(TempMat.roughness, 0.00001f);
	hitmat.MatType = TempMat.MatType;
	hitmat.transmittanceColor = TempMat.transmittanceColor;
	hitmat.metallic = TempMat.metallic;
	hitmat.ior = TempMat.ior;
	hitmat.specTrans = TempMat.specTrans;
	hitmat.specularTint = TempMat.specularTint;
	hitmat.clearcoat = TempMat.clearcoat;
	hitmat.clearcoatGloss = TempMat.clearcoatGloss;
	hitmat.diffTrans = TempMat.diffTrans;
	hitmat.sheen = TempMat.sheen;
	hitmat.sheenTint = TempMat.sheenTint;
	hitmat.anisotropic = TempMat.anisotropic;
	hitmat.flatness = TempMat.flatness;
	hitmat.transmittanceColor = TempMat.transmittanceColor;
	hitmat.phaseFunction = 0;
	hitmat.extinction = 0;
	hitmat.relativeIOR = TempMat.ior;
	hitmat.Thin = TempMat.Thin;
	hitmat.scatterDistance = 0.5f;//bestHit.t;
	hitmat.Specular = TempMat.Specular;//bestHit.t;



	if (TempMat.HasMetallicTex > 0 && hitmat.specTrans != 1) {
		float2 MetallicUV = fmod(BaseUv + 100.0f, float2(1.0f, 1.0f)) * (_Materials[MaterialIndex].MetallicTex.xy - _Materials[MaterialIndex].MetallicTex.zw) + _Materials[MaterialIndex].MetallicTex.zw;
		float MetallicCol = MetallicTex.SampleLevel(sampler_clamp_point, MetallicUV, 0);
		hitmat.metallic = MetallicCol.r;
	}
	if (TempMat.HasRoughnessTex > 0) {
		float2 RoughnessUV = fmod(BaseUv + 100.0f, float2(1.0f, 1.0f)) * (_Materials[MaterialIndex].RoughnessTex.xy - _Materials[MaterialIndex].RoughnessTex.zw) + _Materials[MaterialIndex].RoughnessTex.zw;
		float RoughnessCol = RoughnessTex.SampleLevel(sampler_clamp_point, RoughnessUV, 0);
		hitmat.roughness = saturate(RoughnessCol.r);
		TempMat.roughness = saturate(RoughnessCol.r);
	}
	bool IsEmissiveTex = false;
	if (TempMat.HasEmissiveTex > 0) {
		float2 EmissionUV = fmod(BaseUv + 100.0f, float2(1.0f, 1.0f)) * (_Materials[MaterialIndex].EmissiveTex.xy - _Materials[MaterialIndex].EmissiveTex.zw) + _Materials[MaterialIndex].EmissiveTex.zw;
		float3 EmissCol = _Materials[MaterialIndex].EmissionColor;
		bool IsMask = !(EmissCol.x == 0 && EmissCol.y == 0 && EmissCol.z == 0);
		float4 EmissTexture = _EmissiveAtlas.SampleLevel(sampler_EmissiveAtlas, EmissionUV, 0);
		if (!IsMask) EmissCol = EmissTexture.xyz * EmissTexture.w;
		else EmissCol *= EmissTexture.xyz * EmissTexture.w;
		if (dot(EmissCol, EmissCol) > 0.001f) {
			IsEmissiveTex = true;
			hitmat.surfaceColor = EmissCol * (IsMask ? hitmat.surfaceColor : hitmat.surfaceColor);
		}
		else {
			hitmat.emmis = 0;
		}
	}
	else if (_Materials[MaterialIndex].EmissionColor.x != 0 || _Materials[MaterialIndex].EmissionColor.y != 0 || _Materials[MaterialIndex].EmissionColor.z != 0) {
		hitmat.surfaceColor += _Materials[MaterialIndex].EmissionColor * hitmat.surfaceColor;
	}
	if(UseReSTIRGI && CurBounce == 0) {
		CurrentReservoirGI[PixIndex].MaterialIndex = MaterialIndex;
	}
	calcFinalColor(ray, Color, hitmat, bestHit, TempUv, NormalUV, GlobalRays1[index].HitVoxel == 1, IsEmissiveTex || (TempMat.MatType == VideoIndex), GlobalRays1[index], TempMat, GlobalRays1[index].PrevIndex, GlobalRays1[index].HitVoxel == 2, pixel_index, PixIndex);
	GlobalColors[PixIndex] = Color;
}



#pragma kernel kernel_finalize


SamplerState my_linear_clamp_sampler;
RWTexture2D<float> PrevDepthTex;
bool UseAtrous;
bool DiffRes;
float IndirectBoost;
[numthreads(16, 16, 1)]
void kernel_finalize(uint3 id : SV_DispatchThreadID) {//Moved final accumulation into its own kernel, improves performance

	if (id.x >= screen_width || id.y >= screen_height) return;
	int final_pixel_index = id.y * screen_width + id.x;

	if (UseReSTIRGI) PrevDepthTex[id.xy] = ScreenSpaceInfo[final_pixel_index].t;

	if(UseReSTIRGI && UsePermutatedSamples && ReSTIRGIUpdateRate != 0 && CurrentReservoirGI[final_pixel_index].HistoricFrame == -1) {
		for(int i = -1; i <= 1; i++) {
			for(int j = -1; j <= 1; j++) {
				int2 Index = int2(id.x + i,id.y + j);
				CurrentReservoirGI[Index.x + Index.y * screen_width].M = min(1,CurrentReservoirGI[Index.x + Index.y * screen_width].M);
			}	
		}
	}
	float3 res = (GlobalColors[final_pixel_index].Direct + GlobalColors[final_pixel_index].Indirect * IndirectBoost) * ((DiffRes || UseAtrous) ? 1.0f : AlbedoTex[id.xy].xyz) + unpackRGBE(GlobalColors[final_pixel_index].PrimaryNEERay) / (((DiffRes || UseAtrous) && AlbedoTex[id.xy].xyz != 0) ? AlbedoTex[id.xy].xyz : 1.0f);
	if (!all(res < 100000)) res = 0;
	Result[id.xy] = float4(res, 1.0f);
}






float4x4 viewprojection;
float4x4 prevviewprojection;


float3 camPos;
bool DoIndirectClamping;

#pragma kernel kernel_GI_Reserviour

void UpdateReservoir(inout GIReservoir A, GIReservoir B, float w, float rndnum, inout float wsum, inout ColData Col1, const ColData Col2) {
	A.M += B.M + 1;
	wsum += w;
	if (rndnum < (w / wsum)) {
		Col1 = Col2;
		A.SecondaryHitPosition = B.SecondaryHitPosition;
		A.HistoricID = B.HistoricID;
		A.HistoricFrame = B.HistoricFrame;
		A.ThisCase = B.ThisCase;
		A.BaseColor = B.BaseColor;
		A.NEEPosition = B.NEEPosition;
		A.LuminanceIncomming = B.LuminanceIncomming;
	}

}

bool UseReSTIRGISpatial;
bool UseReSTIRGITemporal;
int ReSTIRGISpatialCount;
bool DoReSTIRGIConnectionValidation;
bool AbandonSamples;
int ReSTIRGITemporalMCap;
bool SpatialStabalizer;
float3 PrevCamPos;
float3 CamPos;
float3 cameraForward;

float EvalPHat(const ColData TargetCol, float3 bsdfVal, float3 NEEbsdfVal, float bsdfpdf, float NEEbsdfpdf) {
    return luminance((TargetCol.Direct + TargetCol.Indirect) * ((UseAlteredPipeline) ? 1 : bsdfVal)) * step(0.0f, bsdfpdf) + luminance(unpackRGBE(TargetCol.PrimaryNEERay) * ((UseAlteredPipeline) ? 1 : NEEbsdfVal)) * step(0, NEEbsdfpdf);
}
float EvalPHatIndirect(const ColData TargetCol, float3 bsdfVal, float bsdfpdf) {
    return luminance((TargetCol.Indirect) * ((UseAlteredPipeline) ? 1 : bsdfVal) * step(0, bsdfpdf));
}


const static int2 offsets[4] = {
	int2(-1, -1),
	int2(1, 1),
	int2(-1, 1),
	int2(1, -1),
};
const static uint2 xor_seq[4] = {
	uint2(3, 3),
	uint2(2, 1),
	uint2(1, 2),
	uint2(3, 3),
};

int2 get_rpx_offset(uint sample_i, uint frame_index) {

	const int2 reservoir_px_offset_base =
		offsets[frame_index & 3]
		+ offsets[(sample_i + (frame_index ^ 1)) & 3];

	return
		sample_i == 0
		? 0
		: int2(reservoir_px_offset_base)
		;
}
bool UpdateReservoir2(inout GIReservoir A, GIReservoir B, float w, float rndnum, inout float wsum, inout ColData Col1, const ColData Col2) {
	A.M += B.M;
	wsum += w;
	if (rndnum < (w / wsum)) {
		Col1 = Col2;
		A.SecondaryHitPosition = B.SecondaryHitPosition;
		A.HistoricID = B.HistoricID;
		A.HistoricFrame = B.HistoricFrame;
		A.ThisCase = B.ThisCase;
		A.BaseColor = B.BaseColor;
		A.NEEPosition = B.NEEPosition;
		A.LuminanceIncomming = B.LuminanceIncomming;
		return true;
	}
	return false;

}

Texture2D<float4> AlbedoTexRead;
float MinSpatialSize;


[numthreads(12, 12, 1)]
void kernel_GI_Reserviour(uint3 id : SV_DispatchThreadID, uint3 id2 : SV_GroupThreadID, uint3 id3 : SV_GroupID, uint id4 : SV_GroupIndex) {
	if (id.x >= screen_width || id.x < 0 || id.y >= screen_height || id.x < 0) return;
	int index = id.x + id.y * screen_width;
	uint pixel_index = index;
	GIReservoir CurrentRes = CurrentReservoirGI[index];
	ColData CurrentCol = GlobalColors[id.x + id.y * screen_width];
	ColData PrevCol = GlobalColors[id.x + id.y * screen_width];
	Ray ray = CreateCameraRay(id.xy / float2(screen_width, screen_height) * 2.0f - 1.0f, pixel_index);

	GIReservoir prevReservoir = { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};

	MaterialData TempMat = _Materials[(int)CurrentRes.MaterialIndex.x];
	const ScreenSpaceData MatModifier = ScreenSpaceInfo[index];
	float3 PrimaryHitPosition = MatModifier.Position;
	HitMat hitmat;
	hitmat.surfaceColor = MatModifier.Albedo;
	hitmat.emmis = TempMat.emmissive;
	hitmat.roughness = MatModifier.Roughness;
	hitmat.MatType = TempMat.MatType;
	hitmat.metallic = MatModifier.Metallic;
	hitmat.ior = MatModifier.ior;
	hitmat.specTrans = TempMat.specTrans;
	hitmat.specularTint = TempMat.specularTint;
	hitmat.clearcoat = MatModifier.Clearcoat;
	hitmat.clearcoatGloss = MatModifier.ClearCoatGloss;
	hitmat.diffTrans = TempMat.diffTrans;
	hitmat.sheen = TempMat.sheen;
	hitmat.sheenTint = TempMat.sheenTint;
	hitmat.anisotropic = TempMat.anisotropic;
	hitmat.flatness = TempMat.flatness;
	hitmat.transmittanceColor = TempMat.transmittanceColor;
	hitmat.phaseFunction = 0;
	hitmat.extinction = 0;
	hitmat.relativeIOR = TempMat.ior;
	hitmat.Thin = TempMat.Thin;
	hitmat.scatterDistance = 0;
	hitmat.Specular = MatModifier.Specular;

	bool ActuallyRender = (AlbedoTexRead[id.xy].w == 1);
	float2 UV = id.xy / float2(screen_width, screen_height);
	const float3 Norm = unpackUnormArb(MatModifier.NormNormal);
	const float3x3 NormTangentSpace = GetTangentSpace2(Norm);
	const float3 GeomNorm = unpackUnormArb(CurrentRes.PrimaryNormal);
	bool SuccessfullyReprojected = false;
	#ifdef HDRP
		float2 MotionVector = MotionVectors[int3(UV * float2(TargetWidth, TargetHeight),0)].xy;
	#else
		float2 MotionVector = MotionVectors.SampleLevel(my_linear_clamp_sampler, UV, 0).xy;
	#endif


	uint2 prevIndex;
	#ifdef UseReflectionReproject 
		if (CurrentRes.ThisCase.x == 0 && hitmat.roughness < 0.15f) {
			float4 curprojectedrefl = mul(viewprojection, float4(CamPos + normalize(PrimaryHitPosition - CamPos) * (MatModifier.ReflectedT + length(PrimaryHitPosition - CamPos)), 1));
			float4 prevprojectedrefl = mul(prevviewprojection, float4(CamPos + normalize(PrimaryHitPosition - CamPos) * (MatModifier.ReflectedT + length(PrimaryHitPosition - CamPos)), 1));
			float2 reflprojection = ((curprojectedrefl.xy / curprojectedrefl.w) - (prevprojectedrefl.xy / prevprojectedrefl.w)) * 0.5f;
			MotionVector = reflprojection;
		}
	#endif
	int2 ID = id.xy;
	prevIndex = int2(floor(((float2(ID.xy) + 0.5) * float2(rcp(screen_width), rcp(screen_height)) - MotionVector) * float2(screen_width, screen_height)));
	if (prevIndex.x >= 0 && prevIndex.x < screen_width && prevIndex.y >= 0 && prevIndex.y < screen_height) {
		prevReservoir = PreviousReservoirGI[prevIndex.y * screen_width + prevIndex.x];
		PrevCol = GlobalColors2[prevIndex.y * screen_width + prevIndex.x];
	}
	bool SkipTemporal = false;
	float wsumIndirect = 0;

	PrimaryHitPosition += GeomNorm * 0.001f;
	if (ActuallyRender && !AbandonSamples) {
		GlobalColors[id.x + id.y * screen_width].Direct = 0;
		GlobalColors[id.x + id.y * screen_width].Indirect = 0;
		GlobalColors[id.x + id.y * screen_width].PrimaryNEERay = 0;
		float fpdf3;
		float3 bsdf_value;
		const float3 RayDir = normalize(PrimaryHitPosition - CamPos);
		float CurDist = MatModifier.t;
		float PrevDist = PrevDepthTex[prevIndex].x;
		bool SkipSpatial = false;
		if(RandomNums[id.xy].z == 1 && ReSTIRGIUpdateRate != 0) {
			if(abs(prevReservoir.LuminanceIncomming - CurrentRes.LuminanceIncomming) > 0.1f * max(CurrentRes.LuminanceIncomming, prevReservoir.LuminanceIncomming)) {
				CurrentCol.PrimaryNEERay = 0;
				CurrentCol.Direct = 0;
				CurrentCol.Indirect = 0;
				CurrentRes.M = prevReservoir.M;
				CurrentRes.M = 1;
				CurrentRes.HistoricFrame = -1;
			} else {
				SkipSpatial = true;
				CurrentRes = prevReservoir;
				CurrentCol = PrevCol;
				// CurrentRes.M += 1;
			}
			SkipTemporal = true;
		}
		if(ReSTIRGIUpdateRate != 0) {
			CurrentCol.Direct *= rcp(ReSTIRGIUpdateRate / (ReSTIRGIUpdateRate - 1));
			CurrentCol.Indirect *= rcp(ReSTIRGIUpdateRate / (ReSTIRGIUpdateRate - 1));
			CurrentCol.PrimaryNEERay = packRGBE(unpackRGBE(CurrentCol.PrimaryNEERay) * rcp(ReSTIRGIUpdateRate / (ReSTIRGIUpdateRate - 1)));
		}
		float p_q;
		float fpdf;
		float wsum = 0;
		bool Valid = ReconstructBsdf(hitmat, RayDir, normalize(CurrentRes.SecondaryHitPosition - PrimaryHitPosition), Norm, fpdf, bsdf_value, CurrentRes.ThisCase.x, NormTangentSpace, pixel_index);
		float3 bsdf_value2;
		float fpdf2;
		CurrentCol.PrimaryNEERay *= EvaluateBsdf(hitmat, RayDir, normalize(CurrentRes.NEEPosition - PrimaryHitPosition), Norm, fpdf3, bsdf_value2, pixel_index);
		p_q = EvalPHat(CurrentCol, bsdf_value, bsdf_value2, fpdf, fpdf3);
		wsum = p_q;
		wsumIndirect = EvalPHatIndirect(CurrentCol, bsdf_value, fpdf);
		// if (!Valid) wsum = 0;
		if(SkipTemporal) SuccessfullyReprojected = true;
		if(!SkipTemporal) if (!UsePermutatedSamples) {
				float DistDiff = ((abs(CurDist - PrevDist) - length(CamPos - PrevCamPos))) / CurDist;

				bool DoTemporal = DistDiff < 0.1f && (dot(unpackUnormArb(CurrentRes.PrimaryNormal), unpackUnormArb(prevReservoir.PrimaryNormal)) > 0.9f);
				if (DoTemporal && UseReSTIRGITemporal) {
					SuccessfullyReprojected = true;

					if (ReSTIRGITemporalMCap != 0) prevReservoir.M = min(prevReservoir.M, ReSTIRGITemporalMCap);
					float M = prevReservoir.M;
					if(CurrentRes.ThisCase == 0) {
						float antilag = length(MotionVector * float2(screen_width, screen_height)) * 0.004f;
						float antilag_alpha_spec = clamp(lerp(0.0, antilag, 0.75), 0, 1);
						M = min(M * pow(1.0 - antilag_alpha_spec, 10) + 1, 256.0);
					}
					prevReservoir.M = max(floor(M),1);
					// if(length(MotionVector) > 0.01f && prevReservoir.ThisCase == 0) prevReservoir.M = min(prevReservoir.M, 10);
					Valid = ReconstructBsdf(hitmat, RayDir, normalize(prevReservoir.SecondaryHitPosition - PrimaryHitPosition), Norm, fpdf, bsdf_value, prevReservoir.ThisCase.x, NormTangentSpace, pixel_index);
					PrevCol.PrimaryNEERay *= EvaluateBsdf(hitmat, RayDir, normalize(prevReservoir.NEEPosition - PrimaryHitPosition), Norm, fpdf3, bsdf_value2, pixel_index);



					Valid = Valid && all(bsdf_value < 0 || bsdf_value > 0 || bsdf_value == 0) && luminance(bsdf_value) < 100000.0f;// && (abs(hitmat.roughness - MatModifiersPrev[prevIndex.x + prevIndex.y * screen_width].Roughness) < 0.1f);
					// frames_accumulated++;
					float Prev_p_q = EvalPHat(PrevCol, bsdf_value, bsdf_value2, fpdf, fpdf3);
					if (Valid)UpdateReservoir(CurrentRes, prevReservoir, max(Prev_p_q * prevReservoir.M * prevReservoir.W * Valid, 0), random(23, pixel_index).x, wsum, CurrentCol, PrevCol);
					if(Valid) wsumIndirect += EvalPHatIndirect(CurrentCol, bsdf_value, fpdf) * prevReservoir.M * prevReservoir.W;
				}
				else {
					CurrentRes.M++;
				}


				Valid = ReconstructBsdf(hitmat, RayDir, normalize(CurrentRes.SecondaryHitPosition - PrimaryHitPosition), Norm, fpdf, bsdf_value, CurrentRes.ThisCase.x, NormTangentSpace, pixel_index);
				CurrentCol.PrimaryNEERay *= EvaluateBsdf(hitmat, RayDir, normalize(CurrentRes.NEEPosition - PrimaryHitPosition), Norm, fpdf3, bsdf_value2, pixel_index);
				Valid = Valid && all(bsdf_value < 0 || bsdf_value > 0 || bsdf_value == 0) && luminance(bsdf_value) < 100000.0f;

				// if (!Valid) return;

				p_q = EvalPHat(CurrentCol, bsdf_value, bsdf_value2, fpdf, fpdf3);
				CurrentRes.W = wsum / max((CurrentRes.M * p_q), 0.00001f);
		}
		else {
			for (int i = 0; i < 5; i++) {
				int2 rpx_offset = get_rpx_offset(i, frames_accumulated);
				const static uint2 xor_seq[4] = {
					uint2(3, 3),
					uint2(2, 1),
					uint2(1, 2),
					uint2(3, 3),
				};
				const uint2 permutation_xor_val =
					xor_seq[frames_accumulated & 3];
				const float2 reproj_rand_offset = 0.0;
				const int2 permuted_reproj_px = floor(
					(i == 0
						? id.xy
						: ((id.xy + rpx_offset) ^ permutation_xor_val))
					- float2(screen_width, screen_height) * MotionVector.xy + reproj_rand_offset + 0.5);
				const int2 rpx = permuted_reproj_px + rpx_offset;
				if (rpx.x >= 0 && rpx.x < (int)screen_width && rpx.y >= 0 && rpx.y < (int)screen_height) {
					prevReservoir = PreviousReservoirGI[rpx.y * screen_width + rpx.x];
					PrevCol = GlobalColors2[rpx.y * screen_width + rpx.x];
				}
				float PrevDist = PrevDepthTex[rpx].x;
				float DistDiff = ((abs(CurDist - PrevDist) - length(CamPos - PrevCamPos))) / min(CurDist, PrevDist);

				bool DoTemporal = DistDiff < 0.1f && (dot(unpackUnormArb(prevReservoir.PrimaryNormal), unpackUnormArb(CurrentRes.PrimaryNormal)) > 0.9f);// && (prevReservoir.M > 2 || ReSTIRGIUpdateRate == 0 || i == 0);
				if (DoTemporal && UseReSTIRGITemporal) {
					if (ReSTIRGITemporalMCap != 0) prevReservoir.M = min(prevReservoir.M, ReSTIRGITemporalMCap);
					float M = prevReservoir.M;
					if(CurrentRes.ThisCase == 0) {
						float antilag = length(MotionVector * float2(screen_width, screen_height)) * 0.004f;
						float antilag_alpha_spec = clamp(lerp(0.0, antilag, 1.0f), 0, 1);
						M = min(M * pow(1.0 - antilag_alpha_spec, 10) + 1, 256.0);
					}
					prevReservoir.M = max(floor(M),1);
					// if(length(MotionVector) > 0.01f && prevReservoir.ThisCase == 0) prevReservoir.M = min(prevReservoir.M, 2);
					Valid = ReconstructBsdf(hitmat, RayDir, normalize(prevReservoir.SecondaryHitPosition - PrimaryHitPosition), Norm, fpdf, bsdf_value, prevReservoir.ThisCase.x, NormTangentSpace, pixel_index);
					CurrentCol.PrimaryNEERay *= EvaluateBsdf(hitmat, RayDir, normalize(prevReservoir.NEEPosition - PrimaryHitPosition), Norm, fpdf3, bsdf_value2, pixel_index);
					SuccessfullyReprojected = true;



					float Prev_p_q = EvalPHat(PrevCol, bsdf_value, bsdf_value2, fpdf, fpdf3);
					Valid = Valid && all(bsdf_value < 0 || bsdf_value > 0 || bsdf_value == 0) && luminance(bsdf_value) < 100000.0f && (abs(hitmat.roughness - MatModifiersPrev[rpx.x + rpx.y * screen_width].Roughness) <= 0.1f) && RandomNums[rpx + float2(screen_width, screen_height) * MotionVector.xy].z != 1;
					if(Valid) if (UpdateReservoir2(CurrentRes, prevReservoir, max(Prev_p_q * prevReservoir.M * prevReservoir.W * Valid, 0), random(23 + i, pixel_index).x, wsum, CurrentCol, PrevCol)) prevIndex = rpx;
					if(Valid) wsumIndirect += EvalPHatIndirect(CurrentCol, bsdf_value, fpdf) * prevReservoir.M * prevReservoir.W;
					
				}
				if (CurrentRes.M > ReSTIRGITemporalMCap * 1.25) break;
			}
			CurrentRes.M++;


			Valid = ReconstructBsdf(hitmat, RayDir, normalize(CurrentRes.SecondaryHitPosition - PrimaryHitPosition), Norm, fpdf, bsdf_value, CurrentRes.ThisCase.x, NormTangentSpace, pixel_index);
			CurrentCol.PrimaryNEERay *= EvaluateBsdf(hitmat, RayDir, normalize(CurrentRes.NEEPosition - PrimaryHitPosition), Norm, fpdf3, bsdf_value2, pixel_index);
			Valid = Valid && all(bsdf_value < 0 || bsdf_value > 0 || bsdf_value == 0) && luminance(bsdf_value) < 100000.0f;

			if (!Valid) return;

			p_q = EvalPHat(CurrentCol, bsdf_value, bsdf_value2, fpdf, fpdf3);
			CurrentRes.W = wsum / max((CurrentRes.M * p_q), 0.00001f);
#ifdef ExtraSampleValidation
			if (DoReSTIRGIConnectionValidation) {
				float Distance = length(PrimaryHitPosition - (CurrentRes.SecondaryHitPosition)) - 0.001f;
				Ray ray = CreateRay(PrimaryHitPosition + GeomNorm * 0.0001f, normalize(((CurrentRes.SecondaryHitPosition) - PrimaryHitPosition)));

				bool ConnectedlyVisable = VisabilityCheck(ray, Distance);
				if (!ConnectedlyVisable) { CurrentCol.Direct = 0; CurrentCol.Indirect = 0; }
				if (all(CurrentCol.PrimaryNEERay != 0)) {
					Distance = length(PrimaryHitPosition - (CurrentRes.NEEPosition)) - 0.001f;
					ray = CreateRay(PrimaryHitPosition + GeomNorm * 0.0001f, normalize(((CurrentRes.NEEPosition) - PrimaryHitPosition)));

					ConnectedlyVisable = VisabilityCheck(ray, Distance);
					if (!ConnectedlyVisable) { CurrentCol.PrimaryNEERay = 0; }
				}
			}
#endif
		}

		int PrevM = CurrentRes.M;
		bool DoReset = wsumIndirect != 0 && (((wsumIndirect) / max((CurrentRes.M * EvalPHatIndirect(CurrentCol, bsdf_value, fpdf)), 0.00001f)) * CurrentRes.M / (wsumIndirect) < 0.01f) && CurrentRes.W < 0.1f;// && lerp(fpdf, fpdf3, clamp(luminance(CurrentRes.NEERay) / luminance(CurrentRes.RadianceDirect + CurrentRes.RadianceIndirect),0,1)) < 0.01f;// && length(PrimaryHitPosition - (CurrentRes.NEEPosition)) > luminance(CurrentRes.NEERay);
		float PrevW = CurrentRes.W;
		if (DoReset && DoIndirectClamping || CurrentRes.W > 10) {
			CurrentRes.W = 0;

		}
		GlobalColors3[id.x + id.y * screen_width] = CurrentCol;
		CurrentReservoirGI[index] = CurrentRes;
		if (!SkipSpatial && UseReSTIRGISpatial) {
			uint2 CenterIndex = prevIndex;
			uint2 neighborOffset;
			uint2 neighborIndex;
			int TempSpatialCount = ReSTIRGISpatialCount;
			if(TempSpatialCount == 0) if(CurrentRes.M < ReSTIRGITemporalMCap / 2) {TempSpatialCount = 9; }else {TempSpatialCount = 3;}
			if(!SuccessfullyReprojected) {TempSpatialCount = 21; CenterIndex = id.xy;}
			float radius = 60;
			for (int i = 0; i < TempSpatialCount; i++) {
				radius = max(max(radius * 0.5f, MinSpatialSize* ((SuccessfullyReprojected) ? 1 : 2))*random(i, pixel_index).x,2);
				float angle = 2.0f * PI * random(i, pixel_index).y;
				int2 neighborIndex = round(CenterIndex + radius * float2(cos(angle), sin(angle)));
				if (neighborIndex.x < 0 || neighborIndex.x >= (int)screen_width || neighborIndex.y < 0 || neighborIndex.y >= (int)screen_height) continue;
				prevReservoir = PreviousReservoirGI[neighborIndex.y * uint(screen_width)+neighborIndex.x];
				PrevCol = GlobalColors2[neighborIndex.y * uint(screen_width)+neighborIndex.x];
				float PrevDist = PrevDepthTex[neighborIndex].x;
				float DistDiff = (abs(CurDist - PrevDist)) / CurDist;
				if (
					(SuccessfullyReprojected && (DistDiff >= 0.1f || prevReservoir.ThisCase != CurrentRes.ThisCase)) ||
					dot(unpackUnormArb(prevReservoir.PrimaryNormal), unpackUnormArb(CurrentRes.PrimaryNormal)) < 0.99 || RandomNums[round(id.xy + radius * float2(cos(angle), sin(angle)))].z == 1
					) {
					continue;
				}
				// frames_accumulated++;
				Valid = ReconstructBsdf(hitmat, RayDir, normalize(prevReservoir.SecondaryHitPosition - PrimaryHitPosition), Norm, fpdf, bsdf_value, prevReservoir.ThisCase.x, NormTangentSpace, pixel_index);
				Valid = Valid && all(bsdf_value < 0 || bsdf_value > 0 || bsdf_value == 0) && luminance(bsdf_value) < 100000.0f;// && fpdf > 0.25f;
				PrevCol.PrimaryNEERay *= EvaluateBsdf(hitmat, RayDir, normalize(prevReservoir.NEEPosition - PrimaryHitPosition), Norm, fpdf3, bsdf_value2, pixel_index);
				if (!Valid) continue;
				CurrentRes.M--;


				p_q = EvalPHat(PrevCol, bsdf_value, bsdf_value2, fpdf, fpdf3);
				UpdateReservoir(CurrentRes, prevReservoir, max(p_q * prevReservoir.M * prevReservoir.W, 0), random(i + 16, pixel_index).x, wsum, CurrentCol, PrevCol);
				wsumIndirect += EvalPHatIndirect(CurrentCol, bsdf_value, fpdf) * prevReservoir.M * prevReservoir.W;
			}

			Valid = ReconstructBsdf(hitmat, RayDir, normalize(CurrentRes.SecondaryHitPosition - PrimaryHitPosition), Norm, fpdf, bsdf_value, CurrentRes.ThisCase.x, NormTangentSpace, pixel_index);
			Valid = Valid && all(bsdf_value < 0 || bsdf_value > 0 || bsdf_value == 0) && luminance(bsdf_value) < 100000.0f;
			CurrentCol.PrimaryNEERay *= EvaluateBsdf(hitmat, RayDir, normalize(CurrentRes.NEEPosition - PrimaryHitPosition), Norm, fpdf3, bsdf_value2, pixel_index);
			// if (!Valid) return;

			p_q = EvalPHat(CurrentCol, bsdf_value, bsdf_value2, fpdf, fpdf3);
			CurrentRes.W = wsum / max((CurrentRes.M * p_q), 0.00001f);
		}

		if ((p_q == 0 || CurrentRes.M == 0) || CurrentRes.W > 10) {
			CurrentRes.W = 0;
		}

		if (DoReSTIRGIConnectionValidation) {
			float Distance = length(PrimaryHitPosition - (CurrentRes.SecondaryHitPosition)) - 0.001f;
			Ray ray = CreateRay(PrimaryHitPosition + GeomNorm * 0.0001f, normalize(((CurrentRes.SecondaryHitPosition) - PrimaryHitPosition)));

			bool ConnectedlyVisable = VisabilityCheck(ray, Distance);
			if (!ConnectedlyVisable) {CurrentCol.Direct = 0; CurrentCol.Indirect = 0; }
			#ifdef ExtraSampleValidation
				if (all(CurrentCol.PrimaryNEERay != 0)) {
					Distance = length(PrimaryHitPosition - (CurrentRes.NEEPosition)) - 0.001f;
					Ray ray = CreateRay(PrimaryHitPosition + GeomNorm * 0.0001f, normalize(((CurrentRes.NEEPosition) - PrimaryHitPosition)));

					ConnectedlyVisable = VisabilityCheck(ray, Distance);
				if (!ConnectedlyVisable) {CurrentCol.PrimaryNEERay = 0; }
				}
			#endif
		}


		DoReset = wsumIndirect != 0 && (((wsumIndirect) / max((CurrentRes.M * EvalPHatIndirect(CurrentCol, bsdf_value, fpdf)), 0.00001f)) * CurrentRes.M / (wsumIndirect) < 0.01f) && CurrentRes.W < 0.1f;
		if (DoReset && DoIndirectClamping) {
			CurrentRes.W = 0;
			return;
		}
		if (SpatialStabalizer && !SuccessfullyReprojected) {
			CurrentRes.M = 1;
			CurrentReservoirGI[index] = CurrentRes;
			GlobalColors3[index] = CurrentCol;
		}
		// CurrentRes.W = clamp(CurrentRes.W, 0, 1);
			if(DiffRes) hitmat.surfaceColor = 1;
			CurrentCol.PrimaryNEERay *= EvaluateBsdf(hitmat, RayDir, normalize(CurrentRes.NEEPosition - PrimaryHitPosition), Norm, fpdf3, bsdf_value2, pixel_index);
			Valid = ReconstructBsdf(hitmat, RayDir, normalize(CurrentRes.SecondaryHitPosition - PrimaryHitPosition), Norm, fpdf, bsdf_value, CurrentRes.ThisCase.x, NormTangentSpace, pixel_index);
			Valid = Valid && all(bsdf_value < 0 || bsdf_value > 0 || bsdf_value == 0) && luminance(bsdf_value) < 100000.0f;
			if(!Valid) return;
			if (!UseAlteredPipeline) TempAlbedoTex[id.xy] = float4(abs(bsdf_value), 1);
			if(!DiffRes) bsdf_value = 1;
			float3 Col =(unpackRGBE(CurrentCol.PrimaryNEERay) * CurrentRes.W * bsdf_value2);
			GlobalColors[id.x + id.y * screen_width].Direct = CurrentCol.Direct * CurrentRes.W * bsdf_value;
			GlobalColors[id.x + id.y * screen_width].Indirect = CurrentCol.Indirect * CurrentRes.W * bsdf_value;
			GlobalColors[id.x + id.y * screen_width].PrimaryNEERay = (UseAlteredPipeline) ? packRGBE(unpackRGBE(CurrentCol.PrimaryNEERay) * CurrentRes.W * max(hitmat.surfaceColor, 0.0000001f)) : packRGBE(Col);
			GlobalColors[id.x + id.y * screen_width].IsSpecular = (CurrentRes.ThisCase.x == 0 && MatModifier.Roughness < 0.18f) ? 1 : 0;
	}
	else {
		CurrentReservoirGI[index] = CurrentRes;
	}




}

#pragma kernel GIReTraceKernel


[numthreads(12, 12, 1)]
void GIReTraceKernel(uint3 id : SV_DispatchThreadID, uint3 id2 : SV_GroupThreadID, uint3 id3 : SV_GroupID, uint id4 : SV_GroupIndex) {

    if (id.x >= screen_width || id.y >= screen_height) return;
    const uint pixel_index = id.y * screen_width + id.x;

	float2 uv = float2((id.xy) / float2(screen_width, screen_height) * 2.0f - 1.0f);
    Ray ray = CreateCameraRay(uv, pixel_index);

    RandomNumsWrite[id.xy] = float4(curframe, pixel_index, 0, 0);
    if(curframe % ReSTIRGIUpdateRate == pixel_index % ReSTIRGIUpdateRate) {
		#ifdef HDRP
			float2 MotionVector = MotionVectors[int3(id.xy,0)].xy;
		#else
			float2 MotionVector = MotionVectors.SampleLevel(my_linear_clamp_sampler, (id.xy) / float2(screen_width, screen_height) , 0).xy;
		#endif
		uint2 prevIndex = int2(floor(((float2(id.xy) + 0.5) * float2(rcp(screen_width), rcp(screen_height)) - MotionVector) * float2(screen_width, screen_height)));
		if (prevIndex.x >= 0 && prevIndex.x < screen_width && prevIndex.y >= 0 && prevIndex.y < screen_height) {
	    	RandomNumsWrite[id.xy] = float4(CurrentReservoirGI[prevIndex.x + prevIndex.y * screen_width].HistoricFrame, CurrentReservoirGI[prevIndex.x + prevIndex.y * screen_width].HistoricID, 1, 1);
	    }
    }
    Rays[pixel_index].origin = ray.origin;
    Rays[pixel_index].direction = ray.direction;


}


#pragma kernel TransferKernel


[numthreads(1, 1, 1)]
void TransferKernel(uint3 id : SV_DispatchThreadID) {

	BufferData[0] = uint3(ceil(BufferSizes[CurBounce].tracerays / 64.0f), 1, 1);

}

#pragma kernel DepthCopyKernel

inline Ray CreateCameraRay(float2 uv) {
	// Transform the camera origin to world space
	float3 origin = mul(unity_CameraToWorld, float4(0.0f, 0.0f, 0.0f, 1.0f)).xyz;

	// Invert the perspective projection of the view-space position
	float3 direction = mul(_CameraInverseProjection, float4(uv, 0.0f, 1.0f)).xyz;
	// Transform the direction from camera to world space and normalize
	direction = mul(unity_CameraToWorld, float4(direction, 0.0f)).xyz;
	direction = normalize(direction);

	return CreateRay(origin, direction);
}

[numthreads(32, 32, 1)]
void DepthCopyKernel(uint3 id : SV_DispatchThreadID) {
	if(id.x > screen_width || id.y > screen_height) return;
	float2 Uv = id.xy / float2(screen_width, screen_height);
	Ray ray = CreateCameraRay(Uv * 2.0f - 1.0f);
	#ifdef HDRP
		CorrectedDepthTex[id.xy] = length(ray.direction / dot(ray.direction, Forward) * LinearEyeDepth(Depth[int3(id.xy,0)].x));
	#else
		CorrectedDepthTex[id.xy] = length(ray.direction / dot(ray.direction, Forward) * LinearEyeDepth(Depth.SampleLevel(my_linear_clamp_sampler, Uv, 0).x));	
	#endif
}