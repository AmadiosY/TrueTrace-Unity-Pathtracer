#pragma use_dxc
#include "CommonData.cginc"
#include "Materials.cginc"

#pragma kernel kernel_shade

Texture2D<float4> _SkyboxTexture;
SamplerState sampler_SkyboxTexture;

Texture2D<float4> _TextureAtlas;
SamplerState my_point_clamp_sampler;

Texture2D<float2> _NormalAtlas;
SamplerState sampler_NormalAtlas;

Texture2D<float4> _EmissiveAtlas;
SamplerState sampler_EmissiveAtlas;

//These are here purely for the Atrous




HitMat CreateHitMat() {
	HitMat hit;
	hit.surfaceColor = float3(0.0f, 0.0f, 0.0f);
	hit.emmis = 0.0f;
	hit.roughness = 0.0f;
	hit.MatType = 0;
	hit.DoesPassThrough = false;
	hit.relativeIOR = 0;
	hit.ior = 0;
	hit.anisotropic = 0;
	hit.clearcoatGloss = 0;
	hit.flatness = 0;
	hit.clearcoat = 0;
	hit.transmittanceColor = 0;
	hit.scatterDistance = 0;
	hit.phaseFunction = 0;
	hit.extinction = 0;
	hit.diffTrans = 0;
	hit.sheen = 0;

	hit.sheenTint = 0;


	return hit;
}

float2 sample_disc(float u1, float u2) {
	float a = 2.0f * u1 - 1.0f;
	float b = 2.0f * u2 - 1.0f;
	if (a == 0.0f) a = 0.00001;
	if (b == 0.0f) b = 0.00001;

	float phi, r;
	if (a * a > b * b) {
		r = a;
		phi = (0.25f * PI) * (b / a);
	}
	else {
		r = b;
		phi = (0.25f * PI) * (a / b) + (0.5f * PI);
	}

	float sin_phi, cos_phi;
	sincos(phi, sin_phi, cos_phi);

	return float2(r * cos_phi, r * sin_phi);
}

float3 sample_cosine_weighted_direction(float u1, float u2) {
	float2 d = sample_disc(u1, u2);
	return float3(d.x, d.y, sqrt(abs(1.0f - dot(d, d))));
}

float3 sample(inout float pdf, uint pixel_index) {//Diffuse
	float2 rando = random(5, pixel_index);
	float3 omega_o = sample_cosine_weighted_direction(rando.x, rando.y);
	pdf = omega_o.z * ONE_OVER_PI;
	return omega_o;
}

float3 sample(inout float pdf, int rand, uint pixel_index) {//Diffuse
	float2 rando = random(rand, pixel_index);
	float3 omega_o = sample_cosine_weighted_direction(rando.x, rando.y);
	pdf = omega_o.z * ONE_OVER_PI;
	return omega_o;
}

float3x3 GetTangentSpace(float3 normal) {
	// Choose a helper floattor for the cross product
	float3 helper = float3(1, 0, 0);
	if (abs(normal.x) > 0.99f)
		helper = float3(0, 0, 1);

	// Generate floattors
	float3 tangent = normalize(cross(normal, helper));
	float3 binormal = cross(normal, tangent);

	return float3x3(tangent, binormal, normal);
}
float3x3 GetTangentSpace2(float3 normal) {
	// Choose a helper floattor for the cross product
	float3 helper = float3(1, 0, 0);
	if (abs(normal.x) > 0.99f)
		helper = float3(0, 0, 1);

	// Generate floattors
	float3 tangent = normalize(cross(normal, helper));
	float3 binormal = cross(normal, tangent);

	return float3x3(tangent, normal, binormal);
}


inline float3 local_to_world(const float3 Dir, const float3 tangent, const float3 binormal, const float3 normal) {
	return float3(
		tangent.x * Dir.x + binormal.x * Dir.y + normal.x * Dir.z,
		tangent.y * Dir.x + binormal.y * Dir.y + normal.y * Dir.z,
		tangent.z * Dir.x + binormal.z * Dir.y + normal.z * Dir.z
		);
}

float3 sample_henyey_greenstein(const float3 omega, float g, float u1, float u2) {
	float cos_theta;
	if (abs(g) < 1e-3f) {
		// Isotropic case
		cos_theta = 1.0f - 2.0f * u1;
	}
	else {
		float sqr_term = (1.0f - g * g) / (1.0f + g - 2.0f * g * u1);
		cos_theta = -(1.0f + g * g - sqr_term * sqr_term) / (2.0f * g);
	}
	float sin_theta = sqrt(max(1.0f - cos_theta * cos_theta, 0.0f));

	float phi = (PI * 2.0f) * u2;
	float sin_phi, cos_phi;
	sincos(phi, sin_phi, cos_phi);

	float3 direction = float3(
		sin_theta * cos_phi,
		sin_theta * sin_phi,
		cos_theta
		);

	float3 v1, v2;
	orthonormal_basis(omega, v1, v2);

	return local_to_world(direction, v1, v2, omega);
}

bool VolumetricScatter(inout float3 throughput, RayHit hit, inout Ray ray, inout float3 Pos, HitMat hitDat, uint pixel_index) {
	float3 SigmaS = hitDat.surfaceColor;
	float3 SigmaA = hitDat.transmittanceColor;

	bool medium_can_scatter = (SigmaS.x + SigmaS.y + SigmaS.z) > 0.0f;

	if (medium_can_scatter) {
		float2 rand_scatter = random(3, pixel_index);
		float2 rand_phase = random(5, pixel_index);

		float3 sigma_t = SigmaA + SigmaS;

		float throughput_sum = throughput.x + throughput.y + throughput.z;
		float3 wavelength_pdf = throughput / throughput_sum;

		float sigma_t_used_for_sampling;
		if (rand_scatter.x * throughput_sum < throughput.x) {
			sigma_t_used_for_sampling = sigma_t.x;
		}
		else if (rand_scatter.x * throughput_sum < throughput.x + throughput.y) {
			sigma_t_used_for_sampling = sigma_t.y;
		}
		else {
			sigma_t_used_for_sampling = sigma_t.z;
		}

		float scatter_distance = -log(rand_scatter.y) / sigma_t_used_for_sampling;
		float dist = min(scatter_distance, hit.t);
		float3 transmittance = float3(
			exp(-sigma_t.x * dist),
			exp(-sigma_t.y * dist),
			exp(-sigma_t.z * dist)
			);

		if (scatter_distance < hit.t) {
			float3 pdf = wavelength_pdf * sigma_t * transmittance;
			throughput *= SigmaS * transmittance / (pdf.x + pdf.y + pdf.z);

			float3 direction_out = sample_henyey_greenstein(-ray.direction, hitDat.roughness, rand_phase.x, rand_phase.y);

			float3 ray_origin = ray.origin;
			ray.origin = ray_origin + scatter_distance * ray.direction;
			Pos = ray.origin;
			ray.direction = direction_out;
			return true;
		}
		else {
			float3 pdf = wavelength_pdf * transmittance;
			throughput *= transmittance / (pdf.x + pdf.y + pdf.z);
			return false;
		}
	}
	return false;
}

float3 SunDir;





inline float power_heuristic(float pdf_f, float pdf_g) {
	return (pdf_f * pdf_f) / (pdf_f * pdf_f + pdf_g * pdf_g); // Power of 2 hardcoded, best empirical results according to Veach
}

inline float luminance(const float r, const float g, const float b) {
	return 0.299f * r + 0.587f * g + 0.114f * b;
}


void sampleEquiAngular(float u, float maxDistance, float3 rOrigin, float3 rDirection, float3 lightPos, inout float dist, inout float pdf)
{
	// get coord of closest point to light along (infinite) ray
	float delta = clamp(dot(lightPos - rOrigin, rDirection), 0.0, 1.0);

	// get distance this point is from light
	float D = distance(rOrigin + delta * rDirection, lightPos);

	// get angle of endpoints
	float thetaA = atan((0.0 - delta) / D);
	float thetaB = atan((maxDistance - delta) / D);

	// take sample
	float t = D * tan(lerp(thetaA, thetaB, u));
	dist = delta + t;
	pdf = D / ((thetaB - thetaA) * (D * D + t * t));
}


float AreaOfTriangle(float3 pt1, float3 pt2, float3 pt3) {
	float a = distance(pt1, pt2);
	float b = distance(pt2, pt3);
	float c = distance(pt3, pt1);
	float s = (a + b + c) / 2.0f;
	return sqrt(s * (s - a) * (s - b) * (s - c));
}


static const float sigma_s = 0.09, sigma_a = 0.06, sigma_t = sigma_s + sigma_a;

inline float3 sampleHG(float g, float e1, float e2) {
	//double s=2.0*e1-1.0, f = (1.0-g*g)/(1.0+g*s), cost = 0.5*(1.0/g)*(1.0+g*g-f*f), sint = sqrt(1.0-cost*cost);
	float s = 1.0 - 2.0 * e1, cost = (s + 2.0 * g * g * g * (-1.0 + e1) * e1 + g * g * s + 2.0 * g * (1.0 - e1 + e1 * e1)) / ((1.0 + g * s) * (1.0 + g * s)), sint = sqrt(1.0 - cost * cost);
	return float3(cos(2.0 * PI * e2) * sint, sin(2.0 * PI * e2) * sint, cost);
}

inline float sampleSegment(float epsilon, float sigma, float smax) {
	return -log(1.0 - epsilon * (1.0 - exp(-sigma * smax))) / sigma;
}


inline void generateOrthoBasis(inout float3 u, inout float3 v, float3 w) {
	float3 coVec = w;
	if (abs(w.x) <= abs(w.y)) {
		if (abs(w.x) <= abs(w.z)) coVec = float3(0, -w.z, w.y);
		else coVec = float3(-w.y, w.x, 0);
	}
	else if (abs(w.y) <= abs(w.z)) {
		coVec = float3(-w.z, 0, w.x);
	}
	else coVec = float3(-w.y, w.x, 0);
	coVec *= 1 / sqrt(dot(coVec, coVec));
	u = w % coVec,
		v = w % u;
}

inline float scatter(const Ray r, inout float3 dir, inout float dist, float tin, float tout, float3x3 TanNorm, uint pixel_index) {
	dist = sampleSegment(random(23, pixel_index).x, sigma_s, tout - tin);
	//Vec dir = sampleSphere(XORShift::frand(), XORShift::frand()); //Sample a direction ~ uniform phase function
	dir = sampleHG(-0.5, random(95, pixel_index).x, random(95, pixel_index).y); //Sample a direction ~ Henyey-Greenstein's phase function
	float3 u, v = 0;
	// GetTangentSpace
	// generateOrthoBasis(u, v, r.direction);
	dir = ToWorld(TanNorm, dir);
	return (1.0 - exp(-sigma_s * (tout - tin)));
}


inline bool EvaluateBsdf(const HitMat hitDat, float3 DirectionIn, float3 DirectionOut, float3 Normal, out float PDF, out float3 bsdf_value, uint pixel_index) {
	float throwaway = 0;
	bool validbsdf = false;
	float cos_theta_hit = dot(DirectionOut, Normal);
	[branch] switch (hitDat.MatType) {//Switch between different materials
		default:
			validbsdf = evaldiffuse(DirectionOut, cos_theta_hit, bsdf_value, PDF);
			bsdf_value *= hitDat.surfaceColor;
		break;
		case DisneyIndex:
			bsdf_value = EvaluateDisney(hitDat, -DirectionIn, DirectionOut, hitDat.Thin == 1, PDF, throwaway, GetTangentSpace2(Normal), pixel_index);// DisneyEval(mat, -PrevDirection, norm, to_light, bsdf_pdf, hitDat);
			validbsdf = PDF > 0;
		break;
		case CutoutIndex:
			bsdf_value = EvaluateDisney(hitDat, -DirectionIn, DirectionOut, hitDat.Thin == 1, PDF, throwaway, GetTangentSpace2(Normal), pixel_index);// DisneyEval(mat, -PrevDirection, norm, to_light, bsdf_pdf, hitDat);
			validbsdf = PDF > 0;
		break;
		case VolumetricIndex:
			validbsdf = true;
		break;
	}
	return validbsdf;
}
inline bool ReconstructBsdf(const HitMat hitDat, float3 DirectionIn, float3 DirectionOut, float3 Normal, out float PDF, out float3 bsdf_value, int Case, const float3x3 TangentSpaceNorm, uint pixel_index) {
	float throwaway = 0;
	bool validbsdf = false;
	float cos_theta_hit = dot(DirectionOut, Normal);
	bsdf_value = 0;
	PDF = 0;
	[branch] switch (hitDat.MatType) {//Switch between different materials
		default:
			validbsdf = evaldiffuse(DirectionOut, cos_theta_hit, bsdf_value, PDF);
			bsdf_value = hitDat.surfaceColor;
		break;
		case DisneyIndex:
			bsdf_value = ReconstructDisney(hitDat, -DirectionIn, DirectionOut, false, PDF, TangentSpaceNorm, Case, Normal, validbsdf, pixel_index);
		break;
		case CutoutIndex:
			bsdf_value = ReconstructDisney(hitDat, -DirectionIn, DirectionOut, false, PDF, TangentSpaceNorm, Case, Normal, validbsdf, pixel_index);
		break;
		case VolumetricIndex:
			validbsdf = true;
		break;
	}
	return validbsdf;
}


Texture2D<float4> VideoTex;
SamplerState sampler_VideoTex;
float A;
bool ChangedExposure;
int RISCount;

int SelectUnityLight(int pixel_index, out float lightWeight, float3 Norm, float3 Position, float3 RayDir, HitMat hitmat) {
	lightWeight = 1;
	if (unitylightcount == 1) return 0;
	float2 Rand = random(0, pixel_index);
	if(RISCount == 0)	return clamp((Rand.y * unitylightcount), 0, unitylightcount - 1);
	int MinIndex = 0;
	float wsum = 0;
	int M = 0;
	float MinP_Hat = 0;
	for(int i = 0; i < RISCount; i++) {
		Rand = random(i, pixel_index);
		int Index = clamp((Rand.x * unitylightcount), 0, unitylightcount - 1);
		LightData light = _UnityLights[Index];
		float3 Pos = light.Type == 1 ? (light.Direction * 120000.0f + Position) : light.Position;
		float3 to_light = Pos - Position;
		float LengthSquared = dot(to_light, to_light);
		to_light /= sqrt(LengthSquared);
		float3 bsdf_value;
		float bsdf_pdf;
		bool A = EvaluateBsdf(hitmat, RayDir, to_light, Norm, bsdf_pdf, bsdf_value, pixel_index);
		// bool A = evaldiffuse(to_light, dot(to_light, Norm), bsdf_value, bsdf_pdf);
		float p_hat = luminance(bsdf_value * light.Radiance) / ((light.Type == 1) ? 1 : LengthSquared) * ((light.Type == 2) ? saturate(saturate(dot(to_light, -light.Direction)) * light.SpotAngle.x + light.SpotAngle.y) : 1);
		wsum += p_hat;
		M++;
		if(Rand.y < p_hat / wsum) {
			MinIndex = Index;
			MinP_Hat = p_hat;
		}

	}
	lightWeight = wsum / max((M + 1) *MinP_Hat, 0.000001f);
	return MinIndex;
	// float e = _UnityLights[unitylightcount - 1].CDF * rand_light.x + _UnityLights[0].CDF;
	// int low = 0;
	// int high = unitylightcount - 1;
	// if (e > _UnityLights[high - 1].pdf + _UnityLights[high - 1].CDF) return high;
	// int mid = -1;
	// while (low < high) {
	// 	int mid = (low + high) >> 1;
	// 	LightData thislight = _UnityLights[mid];
	// 	if (e < thislight.CDF)
	// 		high = mid;
	// 	else if (e > thislight.CDF + thislight.pdf)
	// 		low = mid + 1;
	// 	else
	// 		return mid;
	// }
	// return mid;
	// // Failed to find a light using importance sampling, pick a random one from the array
	// // NOTE: this is a failsafe, we should never get here!
	// return clamp((rand_light.y * unitylightcount), 0, unitylightcount - 1);
}

void calcFinalColor(inout Ray ray, inout ColData Color, HitMat hitDat, RayHit hit, uint2 Uv, float2 NormalUV, bool HitVoxel, bool IsEmissiveTex, RayData RayDat, MaterialData mat, int prevIndex, bool HitHeightmap, const uint pixel_index, int PixIndex) {//main function
bool cb = (int(Uv.x)/2 + int(Uv.y)/2 + frames_accumulated)%2==0;
	float3 pos = ray.direction * hit.t + ray.origin;
	float3 PrevDirection = ray.direction;
	float3 PrevOrigin = ray.origin;
	const uint index = hit.triangle_id;
	const int Index = Uv.x + Uv.y * screen_width;
	float3 Geomnorm;
	[branch] if (TerrainExists && HitHeightmap) {
		Geomnorm.x = (GetHeight(pos + float3(0.01f, 0, 0), Terrains[hit.triangle_id]) - GetHeight(pos - float3(0.01f, 0, 0), Terrains[hit.triangle_id]));
		Geomnorm.y = (GetHeight(pos + float3(0, 0.01f, 0), Terrains[hit.triangle_id]) - GetHeight(pos - float3(0, 0.01f, 0), Terrains[hit.triangle_id]));
		Geomnorm.z = (GetHeight(pos + float3(0, 0, 0.01f), Terrains[hit.triangle_id]) - GetHeight(pos - float3(0, 0, 0.01f), Terrains[hit.triangle_id]));
		Geomnorm = normalize(Geomnorm);
	}
	else {
		Geomnorm = (DoVoxels || !HitVoxel) ? normalize(mul(_MeshData[hit.mesh_id].Inverse, float4(AggTris[index].norm0 + hit.u * AggTris[index].normedge1 + hit.v * AggTris[index].normedge2, 0.0f)).xyz) : float3(0, 0, 0);
	}
	const float3 PrevThroughput = Color.throughput;
	if (DoVoxels && HitVoxel) {
		Geomnorm = float3(1, 0, 0);
		float3 VoxPos = floor(mul(_MeshData[hit.mesh_id].Transform, float4(ray.origin + ray.direction * hit.t, 1)).xyz) + 0.5f;
		float3 initdiff = mul(_MeshData[hit.mesh_id].Transform, float4(pos, 1)).xyz - VoxPos;
		float Greatest = max(max(abs(initdiff.x), abs(initdiff.y)), abs(initdiff.z));
		if (Greatest == abs(initdiff.y)) Geomnorm = float3(0, 1, 0);
		if (Greatest == abs(initdiff.z)) Geomnorm = float3(0, 0, 1);
		Geomnorm = normalize(mul(_MeshData[hit.mesh_id].Inverse, float4(Geomnorm, 0)).xyz);
	}

	// _DebugTex[Uv] = float4(hit.u, hit.v, 0, 1);
	bool GotFlipped = false;
	[branch] if (dot(ray.direction, Geomnorm) >= 0.0f) {
		Geomnorm *= -1;
		GotFlipped = true;
	}
	float3 norm = Geomnorm;
	[branch] if (NormalUV.x != -1) {//Handle Normal Maps
		float3 LocalTan = normalize(mul(_MeshData[hit.mesh_id].Inverse, float4(AggTris[index].tan0 + hit.u * AggTris[index].tanedge1 + hit.v * AggTris[index].tanedge2, 0.0f)).xyz);
		float3 LocalBinorm = normalize(cross(Geomnorm, LocalTan));
		float2 Norm = _NormalAtlas.SampleLevel(sampler_NormalAtlas, NormalUV, 0);
		float2 InputNormal;
		InputNormal = Norm.rg;

		float3 LocalNormIN = float3((2.0f * InputNormal.xy - 1.0f), 0.0f);
		LocalNormIN.z = 1.0 - 0.5 * dot(LocalNormIN, LocalNormIN);
		norm = normalize(mul(normalize(LocalNormIN), float3x3(LocalTan, LocalBinorm, Geomnorm)).xyz);
		norm = clamp(norm, -1, 1);
		if (abs(norm.x) == abs(norm.y) == abs(norm.z)) norm = Geomnorm;
	}
#ifdef UseReflectionReproject 
	if (CurBounce == 1) {
		 ScreenSpaceInfo[PixIndex].t += hit.t;
	}
#endif
	[branch] if (UseReSTIRGI && CurBounce == 0) {//Initialize Buffer
		CurrentReservoirGI[Index].M = 0;
		CurrentReservoirGI[Index].LuminanceIncomming = 0;
		CurrentReservoirGI[Index].HistoricFrame = curframe;
		CurrentReservoirGI[Index].HistoricID = (Uv.x + Uv.y * screen_width);
		CurrentReservoirGI[Index].NEERay = 0;
	}

	[branch] if (hitDat.emmis > 0.0f) {//if we hit a light, this ray is done
		if (!UseNEE || IsEmissiveTex) {
			if (CurBounce == 0) {
				Color.Direct = hitDat.emmis;

				TempAlbedoTex[Uv] = float4(hitDat.surfaceColor, 0);
			}
			else if (CurBounce == 1) {
				Color.Direct += hitDat.surfaceColor * (hitDat.emmis);

				CurrentReservoirGI[Index].SecondaryHitPosition = pos;
			}
			else {
				Color.Indirect += Color.throughput * hitDat.emmis * hitDat.surfaceColor;
			}
		}
		else if (CurBounce != 1 || !UseRestir) {
			float3 a0 = mul(_MeshData[hit.mesh_id].Inverse, float4(AggTris[index].pos0, 1)).xyz;
			float3 a1 = mul(_MeshData[hit.mesh_id].Inverse, float4(AggTris[index].pos0 + AggTris[index].posedge1, 1)).xyz;
			float3 a2 = mul(_MeshData[hit.mesh_id].Inverse, float4(AggTris[index].pos0 + AggTris[index].posedge2, 1)).xyz;

			float a = AreaOfTriangle(a0, a1, a2);
			float SA = abs(dot(norm, ray.direction)) * a / (hit.t * hit.t);
			float light_pdf = 1.0f / (SA * LightMeshCount) * ((_LightMeshes[LightMeshCount - 1].CDF / (_UnityLights[unitylightcount - 1].CDF + _LightMeshes[LightMeshCount - 1].CDF))) * (a / _MeshData[hit.mesh_id].LightPDF);
			float w = power_heuristic(max(RayDat.last_pdf,0), light_pdf);
			if (CurBounce == 0) {
				Color.Direct = hitDat.emmis * hitDat.surfaceColor;
				TempAlbedoTex[Uv] = float4(hitDat.surfaceColor, 0);
			}
			else if (CurBounce == 1) {
				Color.Direct += (hitDat.surfaceColor * hitDat.emmis) * w;
				CurrentReservoirGI[Index].SecondaryHitPosition = pos;
			}
			else {
				Color.Indirect += Color.throughput * hitDat.surfaceColor * hitDat.emmis * w;
			}
		}
		return;
	}
	float3 throughput = Color.throughput;

	float3 tempraydir = float3(0.0f, 0.0f, 0.0f);
	bool valid = true;
	float pdf = 0.0f;

	float3 omega_i = mul(GetTangentSpace(norm), -ray.direction);

	int Case = 0;
		BsdfSample Thissample = initbsdf();
		bool2 tempvalid;
		if(RandomNums[Uv].z == 1 && !UseASVGF && ReSTIRGIUpdateRate != 0 && CurBounce == 0) {
			float RayDir = ray.direction;
			float3 bsdf_value;
			float fpdf;
			valid = ReconstructBsdf(hitDat, RayDir, normalize(PreviousReservoirGI[prevIndex].SecondaryHitPosition - (pos + Geomnorm * 0.001f)), norm, fpdf, bsdf_value, PreviousReservoirGI[prevIndex].ThisCase.x, GetTangentSpace2(norm), pixel_index);
			pdf = fpdf;
			ray.direction = normalize(PreviousReservoirGI[prevIndex].SecondaryHitPosition - (pos + Geomnorm * 0.001f));
			throughput *= max(bsdf_value, 0.000001f);
			if(CurBounce == 0) CurrentReservoirGI[Index].ThisCase = PreviousReservoirGI[prevIndex].ThisCase;

			} else {
		[branch] switch (hitDat.MatType) {//Switch between different materials
			case DisneyIndex://Disney BSDF
				if (!GotFlipped) {
					hitDat.relativeIOR = rcp(hitDat.ior);
				}
				tempvalid = SampleDisney(hitDat, -ray.direction, hitDat.Thin == 1, Thissample, GetTangentSpace2(norm), Case, pixel_index);
				valid = tempvalid.x;
				ray.direction = Thissample.wi;
				pdf = Thissample.forwardPdfW;
				throughput *= max(Thissample.reflectance, 0.000001f);
				if (CurBounce == 0 && Case == 0) Color.IsSpecular = 1;
				if (CurBounce == 0) {
					uint A = hitDat.metallic * 0xFFFF;
					uint B = hitDat.roughness * 0xFFFF;
					uint ABPacked = (A << 16) | (B & 0xFFFF);
					Color.pad = asfloat(ABPacked);
				}
				if(CurBounce == 0) CurrentReservoirGI[Index].ThisCase = Case;
				// valid = valid && all(Thissample.reflectance < 0 || Thissample.reflectance > 0 || Thissample.reflectance == 0) && all(Thissample.forwardPdfW <= 1);

				if (tempvalid.y) {
					Geomnorm *= -1; norm *= -1;
				}
			break;
			case CutoutIndex://mask material
				Thissample = initbsdf();
				if (!GotFlipped) {
					hitDat.relativeIOR = rcp(hitDat.ior);
				}
				tempvalid = SampleDisney(hitDat, -ray.direction, hitDat.Thin == 1, Thissample, GetTangentSpace2(norm), Case, pixel_index);
				valid = tempvalid.x;
				ray.direction = Thissample.wi;
				pdf = Thissample.forwardPdfW;
				throughput *= max(Thissample.reflectance, 0.000001f);
				if (CurBounce == 0 && Case == 0) Color.IsSpecular = 1;
				if (CurBounce == 0) {
					uint A = hitDat.metallic * 0xFFFF;
					uint B = hitDat.roughness * 0xFFFF;
					uint ABPacked = (A << 16) | (B & 0xFFFF);
					Color.pad = asfloat(ABPacked);
				}
				if(CurBounce == 0) CurrentReservoirGI[Index].ThisCase = Case;
				// valid = valid && all(Thissample.reflectance < 0 || Thissample.reflectance > 0 || Thissample.reflectance == 0) && all(Thissample.forwardPdfW <= 1);

				if (tempvalid.y) {
					Geomnorm *= -1; norm *= -1;
				}
			break;
			case VolumetricIndex://"Volumetric" material
				if (GotFlipped) {
					if (VolumetricScatter(throughput, hit, ray, pos, hitDat, pixel_index)) {
						norm = -norm;
						Geomnorm = -Geomnorm;
					}
				}
				else {
					ray.direction = ray.direction;
					norm = -norm;
					Geomnorm = -Geomnorm;
				}
			break;
			case VideoIndex:
				ray.direction = normalize(mul(sample(pdf, pixel_index), GetTangentSpace(norm)));
				valid = pdf > 0;
				throughput *= hitDat.surfaceColor;
			break;
			default:
				ray.direction = normalize(mul(sample(pdf, pixel_index), GetTangentSpace(norm)));
				valid = pdf > 0;
				throughput *= hitDat.surfaceColor;
			break;
		}
	}
		if (!valid) return;//If the ray failed, we have no choice but to terminate this path


	ray.origin = Geomnorm * 0.001f + pos;//Offset the ray origin so we dont self intersect with the triangle we just bounced off of

	[branch] if (UseReSTIRGI && CurBounce == 1) {
		CurrentReservoirGI[Index].SecondaryHitPosition = pos;
	}
	if(UseAlteredPipeline) {
		[branch] if (CurBounce == 0 || TempAlbedoTex[Uv].w == -1) {//Setting textures for denosier to use
			CurrentReservoirGI[PixIndex].PrimaryNormal = packUnormArb(Geomnorm);
			ScreenSpaceData TempMatModifier = { hitDat.Specular, hitDat.roughness, hitDat.clearcoat, hitDat.clearcoatGloss, hitDat.metallic, max(hitDat.surfaceColor, 0.00001f), hitDat.ior, packUnormArb(Geomnorm), pos, hit.t, ray.direction, packUnormArb(norm)};
			ScreenSpaceInfo[PixIndex] = TempMatModifier;
			TempAlbedoTex[Uv] = float4(max(hitDat.surfaceColor, 0.00001f), 1);
			if (CurBounce == 0) CurrentReservoirGI[Index].BaseColor = packRGBE(max(hitDat.surfaceColor, 0.00001f));
			throughput = 1;//max(hitDat.surfaceColor,0.00001f);
		}
	} else {
		[branch] if (CurBounce == 0 || TempAlbedoTex[Uv].w == -1) {//Setting textures for denosier to use
			CurrentReservoirGI[PixIndex].PrimaryNormal = packUnormArb(Geomnorm);
			ScreenSpaceData TempMatModifier = { hitDat.Specular, hitDat.roughness, hitDat.clearcoat, hitDat.clearcoatGloss, hitDat.metallic, max(hitDat.surfaceColor, 0.00001f), hitDat.ior, packUnormArb(Geomnorm), pos, hit.t, ray.direction, packUnormArb(norm)};
			ScreenSpaceInfo[PixIndex] = TempMatModifier;
			TempAlbedoTex[Uv] = float4(max(throughput, 0.00001f), 1);
			if (CurBounce == 0) CurrentReservoirGI[Index].BaseColor = packRGBE(max(throughput, 0.00001f));
			throughput = 1;
		}	
	}
	[branch] if ((UseNEE) && CurBounce < MaxBounce && !hitDat.DoesPassThrough) {//Next event estimation
		float3 pos2;
		float3 LightNorm;
		int triindex;
		bool IsAboveHorizon = true;
		bool IsDirectional = false;
		float LightPDF = 0.0f;
		bool UseUnityLight;
		int TriCount = 0;
		int MeshIndex = 0;
		Reservoir CurRes = CurrentReservoir[Index];
		float2 CurUv = 0;
		float Attenuation = 1.0f;
		bool IsSpecialized = false;
			float LightWeight = 1;
		[branch] if (UseRestir && CurBounce == 0 && CurRes.y != -1) {
			UseUnityLight = CurRes.MeshIndex < 0;//(unitylightcount != 0) ? (LightMeshCount != 0) ? (random(11, pixel_index).x <= (_UnityLights[unitylightcount - 1].CDF / (_UnityLights[unitylightcount - 1].CDF + _LightMeshes[LightMeshCount - 1].CDF))) : true : false;//Choose whether to sample unity lights or mesh lights based off which is more powerful
			if (UseUnityLight) {
				triindex = CurRes.y;
				[branch] switch (_UnityLights[triindex].Type) {
				default:
					pos2 = CurRes.Position;
					LightNorm = CurRes.Norm;
					break;
				case 1:
					pos2 = ray.origin + _UnityLights[triindex].Direction;
					LightNorm = -_UnityLights[triindex].Direction;
					IsAboveHorizon = (LightNorm.y <= 0.0f);
					IsDirectional = true;
					break;
				case 2:
					pos2 = CurRes.Position;
					LightNorm = CurRes.Norm;
					IsAboveHorizon = false;
					break;
				}
			}
			else {
				triindex = CurRes.y;
				pos2 = CurRes.Position;
				LightNorm = CurRes.Norm;
				LightPDF = CurRes.wsum;
				MeshIndex = CurRes.MeshIndex;
				TriCount = (_LightMeshes[CurRes.MeshIndex].IndexEnd - _LightMeshes[CurRes.MeshIndex].StartIndex);

			}
		}
		else {
			UseUnityLight = (unitylightcount != 0) ? (LightMeshCount != 0) ? (random(11, pixel_index).x <= (_UnityLights[unitylightcount - 1].CDF / (_UnityLights[unitylightcount - 1].CDF + _LightMeshes[LightMeshCount - 1].CDF))) : true : false;//Choose whether to sample unity lights or mesh lights based off which is more powerful
			if (UseUnityLight) {
				triindex = SelectUnityLight(pixel_index, LightWeight, norm, pos, PrevDirection, hitDat);
				LightData Light = _UnityLights[triindex];
				[branch] switch (Light.Type) {
				default:
					pos2 = Light.Position;
					LightNorm = normalize(ray.origin - pos2);
					break;
				case 1:
					pos2 = ray.origin + Light.Direction;
					LightNorm = -Light.Direction;
					IsAboveHorizon = (LightNorm.y <= 0.0f);
					IsDirectional = true;
					break;
				case 2:
					pos2 = Light.Position;
					LightNorm = Light.Direction;
					IsAboveHorizon = false;
					IsSpecialized = true;
					break;
				case 3:
					IsSpecialized = true;
					float3 randVector = (float3(random(43, pixel_index).x * Light.SpotAngle.x, random(43, pixel_index).y * Light.SpotAngle.y, 0)) - float3(Light.SpotAngle.x, Light.SpotAngle.y, 0) / 2;
					float3 oldRand = randVector;
					Light.ZAxisRotation *= PI / 180.0f;
					randVector = float3(oldRand.x * cos(Light.ZAxisRotation) - oldRand.y * sin(Light.ZAxisRotation), oldRand.y * cos(Light.ZAxisRotation) + oldRand.x * sin(Light.ZAxisRotation), 0);
					float3 tangent0 = cross(Light.Direction, float3(0, 1, 0));
					if (dot(tangent0, tangent0) < 0.001f) tangent0 = cross(Light.Direction, float3(1, 0, 0));
					tangent0 = normalize(tangent0);
					float3 tangent1 = normalize(cross(Light.Direction, tangent0));
					float3x3 rotationmatrix = { tangent0, tangent1, Light.Direction };
					float3 Length = length(randVector);
					pos2 = Light.Position + mul(normalize(randVector), rotationmatrix) * Length;// - float3(Light.SpotAngle.x, 0, Light.SpotAngle.y) / 2;
					LightNorm = Light.Direction;
					break;
				}
			}
			else {
				MeshIndex = SelectLightMesh(pixel_index);
				triindex = SelectLight(MeshIndex, false, pixel_index);
				TrianglePos CurTri = triangle_get_positions2(triindex);
				float2 rand_triangle = random(24, pixel_index);
				CurUv = sample_triangle(rand_triangle.x, rand_triangle.y);
				pos2 = mul(_LightMeshes[MeshIndex].Inverse, float4(CurTri.pos0 + CurUv.x * CurTri.posedge1 + CurUv.y * CurTri.posedge2, 1.0f)).xyz;
				LightNorm = normalize(mul(_LightMeshes[MeshIndex].Inverse, float4(LightTriangles[triindex].Norm, 0.0f)).xyz);
				TriCount = (_LightMeshes[MeshIndex].IndexEnd - _LightMeshes[MeshIndex].StartIndex);
			}
		}
		float3 to_light = pos2 - ray.origin;

		float distance_to_light_squared = dot(to_light, to_light);
		float distance_to_light = sqrt(max(distance_to_light_squared, 0.0f));

		to_light = to_light / distance_to_light;
		if (IsDirectional) {
			float diskRadius = 2 * sin(0.5f * PI / 180.0f);
			float2 rand = random(23, pixel_index);
			float3 DirectionAdjustment = float3(diskRadius * cos(rand.x * 2 * PI), diskRadius * sin(rand.y * 2 * PI), 0);
			float3 DirectionNormal = float3(0, 0, 1);
			float3 z = normalize(cross(DirectionNormal, to_light));
			float3 y = normalize(cross(z, DirectionNormal));
			float3x3 rotationmatrix = float3x3(
				DirectionNormal.x, y.x, z.x,
				DirectionNormal.y, y.y, z.y,
				DirectionNormal.z, y.z, z.z
				);
			to_light = normalize(to_light + (mul(DirectionAdjustment, rotationmatrix)));
		}
		Attenuation = (IsSpecialized) ? saturate(dot(to_light, -LightNorm)) : 1;
		if (!IsDirectional && !IsAboveHorizon) {
			Attenuation = saturate(Attenuation * _UnityLights[triindex].SpotAngle.x + _UnityLights[triindex].SpotAngle.y);
			IsAboveHorizon = true;
		}

		bool validbsdf = false;
		float3 bsdf_value = 0.0f;
		float bsdf_pdf = 0.0f;
		float throwaway = 0;

		float cos_theta_light = abs(dot(to_light, LightNorm));
		float cos_theta_hit = dot(to_light, norm);
		[branch] switch (hitDat.MatType) {//Switch between different materials
			default:
				validbsdf = evaldiffuse(to_light, cos_theta_hit, bsdf_value, bsdf_pdf);
				bsdf_value *= hitDat.surfaceColor;
			break;
			case DisneyIndex:
				bsdf_value = EvaluateDisney(hitDat, -PrevDirection, to_light, hitDat.Thin == 1, bsdf_pdf, throwaway, GetTangentSpace2(norm), pixel_index);// DisneyEval(mat, -PrevDirection, norm, to_light, bsdf_pdf, hitDat);
				validbsdf = bsdf_pdf > 0;
			break;
			case CutoutIndex:
				bsdf_value = EvaluateDisney(hitDat, -PrevDirection, to_light, hitDat.Thin == 1, bsdf_pdf, throwaway, GetTangentSpace2(norm), pixel_index);// DisneyEval(mat, -PrevDirection, norm, to_light, bsdf_pdf, hitDat);
				validbsdf = bsdf_pdf > 0;
			break;
			case VolumetricIndex:
				validbsdf = true;
			break;
		}

		float LightCos = abs(dot(to_light, LightNorm));
		float SurfaceCos = dot(to_light, norm);
		if (SurfaceCos > 0 && LightWeight < 10000.0f) {
			float3 Radiance;
			float NEE_pdf;
			float3 Illum;
			float RadianceIncomming;
			if (UseUnityLight) {
				float3 transmittance = 1;
				if (IsDirectional) {
					float3 Radiance = GetSkyRadiance(ray.origin, to_light, 0, SunDir, transmittance);
				}
				RadianceIncomming = luminance(_UnityLights[triindex].Radiance);
				Radiance = _UnityLights[triindex].Radiance * transmittance;
				NEE_pdf = distance_to_light_squared * LightCos / (unitylightcount) * (_UnityLights[unitylightcount - 1].CDF / (_UnityLights[unitylightcount - 1].CDF + _LightMeshes[LightMeshCount - 1].CDF));
				Illum = PrevThroughput * (Radiance * bsdf_value) / NEE_pdf * Attenuation * ((UseRestir && CurBounce == 0 && (CurRes.W > 0 || CurRes.W < 0 || CurRes.W == 0)) ? CurRes.W : 1) * LightWeight;// / max(hitDat.surfaceColor, 0.0000001f);
			}
			else {
				float SA = LightCos * LightTriangles[triindex].area / distance_to_light_squared;
				NEE_pdf = (1.0f / (LightMeshCount * SA)) * (LightTriangles[triindex].pdf / _LightMeshes[MeshIndex].pdf) * (_LightMeshes[LightMeshCount - 1].CDF / (_UnityLights[unitylightcount - 1].CDF + _LightMeshes[LightMeshCount - 1].CDF));
				Radiance = LightTriangles[triindex].radiance;
				int MaterialIndex = LightTriangles[triindex].MatIndex + _LightMeshes[MeshIndex].MatOffset;
				if (_Materials[MaterialIndex].MatType == VideoIndex || _Materials[MaterialIndex].HasEmissiveTex > 0) {
					float2 BaseUv = LightTriangles[triindex].UV1 * (1.0f - CurUv.x - CurUv.y) + LightTriangles[triindex].UV2 * CurUv.x + LightTriangles[triindex].UV3 * CurUv.y;
					if (_Materials[MaterialIndex].MatType == VideoIndex) {
						Radiance *= VideoTex.SampleLevel(sampler_VideoTex, BaseUv, 0).xyz;
					}
					else {
						float2 EmissionUV = fmod(BaseUv + 100.0f, float2(1.0f, 1.0f)) * (_Materials[MaterialIndex].EmissiveTex.xy - _Materials[MaterialIndex].EmissiveTex.zw) + _Materials[MaterialIndex].EmissiveTex.zw;
						Radiance *= _EmissiveAtlas.SampleLevel(sampler_EmissiveAtlas, EmissionUV, 0).xyz * _EmissiveAtlas.SampleLevel(sampler_EmissiveAtlas, EmissionUV, 0).w;
					}
				}
				RadianceIncomming = luminance(Radiance);
				float NEEMISWeight = power_heuristic(NEE_pdf, bsdf_pdf);
				Illum = PrevThroughput * (Radiance * bsdf_value) / NEE_pdf * Attenuation * ((UseRestir && CurBounce == 0 && (CurRes.W > 0 || CurRes.W < 0 || CurRes.W == 0)) ? CurRes.W : NEEMISWeight);// / max(hitDat.surfaceColor, 0.0000001f);
			}
			if (CurBounce == 0) CurrentReservoirGI[Index].NEEPosition = (IsDirectional) ? (ray.origin + to_light * 10000.0f) : pos2;

			bool DoNEERR = (CurBounce == 0 && UseRestir) || !UseRussianRoulette;
			float maxillum = max(max(Illum.x, Illum.y), Illum.z) * A;
			if ((DoNEERR || maxillum > random(9, pixel_index).y) && (CurRes.W != 0 || !UseRestir || CurBounce != 0)) {//NEE russian roulette, massively improves performance while giivng the same result
				uint index3;//Congrats we shoot a shadow ray for NEE

				InterlockedAdd(BufferSizes[CurBounce].shadow_rays, 1, index3);
				ShadowRaysBuffer[index3].origin = ray.origin;
				ShadowRaysBuffer[index3].direction = to_light;
				ShadowRaysBuffer[index3].t = (IsDirectional) ? 10000.0f : distance_to_light - 0.00001f;//2.0f * EPSILON;
				ShadowRaysBuffer[index3].illumination = Illum * ((DoNEERR) ? 1 : rcp(saturate(maxillum)));// / (CurBounce == 0 && TempAlbedoTex[Uv].xyz != 0.00001f ? TempAlbedoTex[Uv].xyz : 1);// * max(hitDat.surfaceColor,0.0000001f);
				ShadowRaysBuffer[index3].RadianceIncomming = Illum * ((DoNEERR) ? 1 : rcp(saturate(maxillum))) * ((!UseAlteredPipeline) ? (((bsdf_value == 0) ? 1 : rcp(bsdf_value))) : (((hitDat.surfaceColor == 0) ? 1 : rcp(hitDat.surfaceColor))));
				ShadowRaysBuffer[index3].PixelIndex = Uv.y * screen_width + Uv.x;
				ShadowRaysBuffer[index3].LuminanceIncomming = luminance(Radiance);
				ShadowRaysBuffer[index3].PrimaryNEERay = (CurBounce != 0);
			}
			else if (UseRestir && CurBounce == 0) {
				CurrentReservoir[Uv.y * screen_width + Uv.x].W = 0;
				CurrentReservoir[Uv.y * screen_width + Uv.x].wsum = 0;
			}
		}
		else if (UseRestir && CurBounce == 0) {
			CurrentReservoir[Uv.y * screen_width + Uv.x].W = 0;
			CurrentReservoir[Uv.y * screen_width + Uv.x].wsum = 0;
		}
	}
	if (UseRussianRoulette) {
		float3 AdjustedCol = throughput * ((RandomNums[Uv].z == 1 && !UseASVGF && ReSTIRGIUpdateRate != 0) ? unpackRGBE(PreviousReservoirGI[prevIndex].BaseColor) : TempAlbedoTex[Uv].xyz);
		float p = saturate(max(AdjustedCol.x, max(AdjustedCol.y, AdjustedCol.z)));
		if (random(2, pixel_index).x > p && CurBounce > 0)//Simple Russian Roulette
			return;
		if (CurBounce > 0)
			throughput *= rcp(p);//rcp is a slightly faster but less accurate version of 1 / p, I decided the inaccuracy was worth the performance bump
	}
	if (any(throughput > 10000.0f)) return;
	Color.throughput = throughput * ((cb && CurBounce == 0 && DoCheckerboarding || (DoCheckerboarding && UseASVGF && RandomNums[Uv].w == 1 && ReSTIRGIUpdateRate == 0)) ? 2.0f : 1);

	if (cb || !DoCheckerboarding || (UseASVGF && RandomNums[Uv].w == 1 && ReSTIRGIUpdateRate == 0) || (RandomNums[Uv].z == 1 && !UseASVGF && ReSTIRGIUpdateRate != 0)) {
		uint index2;//Congrats, the ray will continue its path
		InterlockedAdd(BufferSizes[CurBounce + 1].tracerays, 1, index2);
		GlobalRays1[index2].origin = ray.origin;
		GlobalRays1[index2].direction = ray.direction;
		GlobalRays1[index2].PixelIndex = Uv.x + Uv.y * screen_width;
		GlobalRays1[index2].PrevIndex = prevIndex;
		GlobalRays1[index2].last_pdf = pdf;
		set(index2, hit);
	}
}

Texture2D<float4> TerrainAlphaMap;
SamplerState sampler_TerrainAlphaMap;
int MaterialCount;

[numthreads(8, 8, 1)]
void kernel_shade() {

	int index;
	InterlockedAdd(BufferSizes[CurBounce].shade_rays, 1, index);
	if (index >= BufferSizes[CurBounce].tracerays) return;
	int PixIndex = GlobalRays1[index].PixelIndex;
	uint2 TempUv = uint2(PixIndex % screen_width, PixIndex / screen_width);
	const uint pixel_index = PixIndex;//TempUv is the origional screen coordinates of the ray

	Ray ray;
	RayHit bestHit = get(index);
	ray.origin = GlobalRays1[index].origin;
	ray.direction = GlobalRays1[index].direction;
	ray.direction_inv = float3(0.0f, 0.0f, 0.0f);//We dont need to calculate this, but we do need to give it some value or Unity complains

	ColData Color = GlobalColors[PixIndex];
	if (bestHit.t == FarPlane) {//if ray goes into the void, sample skybox
		float3 SkyColAcc;
#ifdef UseSkyBox
		float theta = acos(ray.direction.y) / -PI;
		float phi = atan2(ray.direction.x, -ray.direction.z) / -PI * 0.5f;
		float3 sky = _SkyboxTexture.SampleLevel(sampler_SkyboxTexture, float2(phi, theta), CurBounce == 0 ? 0 : 4).xyz;
		if (CurBounce == 0) {//Seperated into direct and indirect channels
			Color.Direct = sky;
		}
		else if (CurBounce == 1) {
			Color.Direct += sky;
		}
		else {
			Color.Indirect += Color.throughput * sky;
		}
		SkyColAcc = Color.throughput * sky;
#else
float3 Direct = 1;
		float3 transmittance = 0;
		float3 Radiance = GetSkyRadiance(ray.origin, ray.direction, 0, SunDir, transmittance);
	// float3 trans2 = Clouds(SunDir, ray, Direct, luminance(Radiance));
		Radiance = float3(1, 1, 1) - exp(-Radiance / 1 * 10.0f);
		float3 SkyBoxCol = saturate(Radiance);// * Direct + trans2;
		float3 Sun = 0;//(saturate(max(min(exp(-acos(max(dot(-SunDir, -ray.direction), 0.0f))* 60.0f),12.0f),0) * transmittance));
		if (dot(ray.direction, SunDir) > cos(0.0235f / 2.0f)) {
			Sun = saturate(Radiance + transmittance * (1.5f / (PI * (0.0235f / 2.0f) * (0.0235f / 2.0f))));
		}
		// float3 direct;
		// float3 transmittance2 = Clouds(SunDir, ray, direct);
		if (all(SkyBoxCol > 0 || SkyBoxCol < 0 || SkyBoxCol == 0)) {
			if (CurBounce == 0) {//Seperated into direct and indirect channels
				Color.Direct = Color.throughput * ((SkyBoxCol)+Sun);// * transmittance2 + direct;
				// CurrentReservoirGI[TempUv.x + TempUv.y * screen_width].LuminanceIncomming += luminance((SkyBoxCol) + Sun);

			}
			else if (CurBounce == 1) {
				Color.Direct += Color.throughput * (SkyBoxCol)+Sun;
				CurrentReservoirGI[TempUv.x + TempUv.y * screen_width].SecondaryHitPosition = ray.origin + ray.direction * 12.0f;

				CurrentReservoirGI[TempUv.x + TempUv.y * screen_width].RadianceDirect += Color.throughput * (SkyBoxCol) + Sun;
				CurrentReservoirGI[TempUv.x + TempUv.y * screen_width].LuminanceIncomming += luminance((SkyBoxCol) + Sun);
			}
			else {
				Color.Indirect += Color.throughput * (SkyBoxCol)+Sun;
				CurrentReservoirGI[TempUv.x + TempUv.y * screen_width].RadianceIndirect += Color.throughput * (SkyBoxCol) + Sun;
				// CurrentReservoirGI[TempUv.x + TempUv.y * screen_width].LuminanceIncomming += luminance(Color.throughput * (SkyBoxCol) + Sun);


			}
		}
#endif
		// float3 col = 0.051f;//float3(0.972549, 0.9568627, 0.9294118);
		//         if(CurBounce == 0) {//Seperated into direct and indirect channels
		//             RenderMaskTex[TempUv] = 0;
		//             Color.Direct = col;
		//         } else if(CurBounce == 1) {
		//             Color.Direct += Color.throughput * col;
		//             CurrentReservoirGI[TempUv.x + TempUv.y * screen_width].SecondaryHitPosition = ray.origin + ray.direction * 12.0f;
		//         } else {
		//             SHData ThisSH = SH[TempUv.x + TempUv.y * screen_width];
		//             accumulate_SH(ThisSH, irradiance_to_SH((Color.throughput * 0.051f) * 1024, ray.direction), 1.0f);
		//             SH[TempUv.x + TempUv.y * screen_width] = ThisSH;
		//             Color.Indirect += Color.throughput * col;
		//         }
		if (CurBounce == 0) {
			TempAlbedoTex[TempUv] = float4(1, 1, 1,0);
		}
		GlobalColors[PixIndex] = Color;
		return;
	}


	float2 BaseUv = AggTris[bestHit.triangle_id].tex0 * (1.0f - bestHit.u - bestHit.v) + AggTris[bestHit.triangle_id].texedge1 * bestHit.u + AggTris[bestHit.triangle_id].texedge2 * bestHit.v;
	int MatOffset = 0;
	bool HitTerrain = false;
	if (TerrainExists && (GlobalRays1[index].HitVoxel == 2)) {
		BaseUv = float2(bestHit.u, bestHit.v);
		float4 Mats = TerrainAlphaMap.SampleLevel(sampler_TerrainAlphaMap, float2(bestHit.u, bestHit.v) * (Terrains[bestHit.triangle_id].AlphaMap.xy - Terrains[bestHit.triangle_id].AlphaMap.zw) + Terrains[bestHit.triangle_id].AlphaMap.zw, 0);

		MatOffset = Mats.y + Mats.z * 2 + Mats.a * 3;
		HitTerrain = true;
	}

	int MaterialIndex = (HitTerrain) ? (MaterialCount + MatOffset + Terrains[bestHit.triangle_id].MatOffset) : (GlobalRays1[index].HitVoxel == 1) ? (_MeshData[bestHit.mesh_id].MaterialOffset + (-(bestHit.triangle_id + 2))) : (_MeshData[bestHit.mesh_id].MaterialOffset + AggTris[bestHit.triangle_id].MatDat);
	MaterialData TempMat = _Materials[MaterialIndex];
	if (HitTerrain) BaseUv = BaseUv * TempMat.BaseColor.xy + TempMat.transmittanceColor.xy;

	float2 Uv = fmod(BaseUv + 100.0f, float2(1.0f, 1.0f)) * (_Materials[MaterialIndex].AlbedoTex.xy - _Materials[MaterialIndex].AlbedoTex.zw) + _Materials[MaterialIndex].AlbedoTex.zw;
	float2 NormalUV = (_Materials[MaterialIndex].HasNormalTex == 1) ? fmod(BaseUv + 100.0f, float2(1.0f, 1.0f)) * (_Materials[MaterialIndex].NormalTex.xy - _Materials[MaterialIndex].NormalTex.zw) + _Materials[MaterialIndex].NormalTex.zw : float2(-1, -1);
	HitMat hitmat = CreateHitMat();//Transfer Material properties
	float4 BaseCol = (TempMat.MatType == VideoIndex) ? VideoTex.SampleLevel(sampler_VideoTex, BaseUv, 0) : (TempMat.HasAlbedoTex > 0) ? (_TextureAtlas.SampleLevel(my_point_clamp_sampler, Uv, 0) * ((!HitTerrain) ? float4(TempMat.BaseColor, 1.0f) : 1)) : float4(TempMat.BaseColor, 1.0f);
	hitmat.surfaceColor = BaseCol.xyz * BaseCol.w;
	hitmat.emmis = TempMat.emmissive;
	TempMat.roughness = max(TempMat.roughness, 0.00001f) + max((CurBounce != 0) ? CurBounce / (float)MaxBounce : 0, 0);
	hitmat.roughness = max(TempMat.roughness, 0.00001f);
	hitmat.MatType = TempMat.MatType;
	hitmat.transmittanceColor = TempMat.transmittanceColor;
	hitmat.metallic = TempMat.metallic;
	hitmat.ior = TempMat.ior;
	hitmat.specTrans = TempMat.specTrans;
	hitmat.specularTint = TempMat.specularTint;
	hitmat.clearcoat = TempMat.clearcoat;
	hitmat.clearcoatGloss = TempMat.clearcoatGloss;
	hitmat.diffTrans = TempMat.diffTrans;
	hitmat.sheen = TempMat.sheen;
	hitmat.sheenTint = TempMat.sheenTint;
	hitmat.anisotropic = TempMat.anisotropic;
	hitmat.flatness = TempMat.flatness;
	hitmat.transmittanceColor = TempMat.transmittanceColor;
	hitmat.phaseFunction = 0;
	hitmat.extinction = 0;
	hitmat.relativeIOR = TempMat.ior;
	hitmat.Thin = TempMat.Thin;
	hitmat.scatterDistance = 0.5f;//bestHit.t;
	hitmat.Specular = TempMat.Specular;//bestHit.t;



	if (TempMat.HasMetallicTex > 0 && hitmat.specTrans != 1) {
		float2 MetallicUV = fmod(BaseUv + 100.0f, float2(1.0f, 1.0f)) * (_Materials[MaterialIndex].MetallicTex.xy - _Materials[MaterialIndex].MetallicTex.zw) + _Materials[MaterialIndex].MetallicTex.zw;
		float MetallicCol = MetallicTex.SampleLevel(sampler_clamp_point, MetallicUV, 0);
		hitmat.metallic = MetallicCol.r;
	}
	if (TempMat.HasRoughnessTex > 0) {
		float2 RoughnessUV = fmod(BaseUv + 100.0f, float2(1.0f, 1.0f)) * (_Materials[MaterialIndex].RoughnessTex.xy - _Materials[MaterialIndex].RoughnessTex.zw) + _Materials[MaterialIndex].RoughnessTex.zw;
		float RoughnessCol = RoughnessTex.SampleLevel(sampler_clamp_point, RoughnessUV, 0);
		hitmat.roughness = saturate(RoughnessCol.r);
		TempMat.roughness = saturate(RoughnessCol.r);
	}
	bool IsEmissiveTex = false;
	if (TempMat.HasEmissiveTex > 0) {
		float2 EmissionUV = fmod(BaseUv + 100.0f, float2(1.0f, 1.0f)) * (_Materials[MaterialIndex].EmissiveTex.xy - _Materials[MaterialIndex].EmissiveTex.zw) + _Materials[MaterialIndex].EmissiveTex.zw;
		float3 EmissCol = _Materials[MaterialIndex].EmissionColor;
		bool IsMask = !(EmissCol.x == 0 && EmissCol.y == 0 && EmissCol.z == 0);
		float4 EmissTexture = _EmissiveAtlas.SampleLevel(sampler_EmissiveAtlas, EmissionUV, 0);
		if (!IsMask) EmissCol = EmissTexture.xyz * EmissTexture.w;
		else EmissCol *= EmissTexture.xyz * EmissTexture.w;
		if (dot(EmissCol, EmissCol) > 0.001f) {
			IsEmissiveTex = true;
			hitmat.surfaceColor = EmissCol * (IsMask ? hitmat.surfaceColor : hitmat.surfaceColor);
		}
		else {
			hitmat.emmis = 0;
		}
	}
	else if (_Materials[MaterialIndex].EmissionColor.x != 0 || _Materials[MaterialIndex].EmissionColor.y != 0 || _Materials[MaterialIndex].EmissionColor.z != 0) {
		hitmat.surfaceColor += _Materials[MaterialIndex].EmissionColor * hitmat.surfaceColor;
	}
	if(UseReSTIRGI && CurBounce == 0) {
		CurrentReservoirGI[PixIndex].MaterialIndex = MaterialIndex;
	}
	calcFinalColor(ray, Color, hitmat, bestHit, TempUv, NormalUV, GlobalRays1[index].HitVoxel == 1, IsEmissiveTex || (TempMat.MatType == VideoIndex), GlobalRays1[index], TempMat, GlobalRays1[index].PrevIndex, GlobalRays1[index].HitVoxel == 2, pixel_index, PixIndex);
	GlobalColors[PixIndex] = Color;
}



#pragma kernel kernel_finalize


SamplerState my_linear_clamp_sampler;
RWTexture2D<float> PrevDepthTex;
bool UseAtrous;
bool DiffRes;
Texture2D<int> PrevNormalTex;
RWTexture2D<int> PrevNormalTexWrite;
RWTexture2D<float> VarianceMap;
[numthreads(16, 16, 1)]
void kernel_finalize(uint3 id : SV_DispatchThreadID) {//Moved final accumulation into its own kernel, improves performance

	if (id.x >= screen_width || id.y >= screen_height) return;
	int final_pixel_index = id.y * screen_width + id.x;
	float2 Uv = id.xy / float2(screen_width, screen_height);
	Ray ray = CreateCameraRay(Uv * 2.0f - 1.0f, final_pixel_index);
	#ifdef HDRP
		if (UseReSTIRGI) PrevDepthTex[id.xy] = length(ray.direction / dot(ray.direction, Forward) * Linear01Depth(Depth[int3(Uv * float2(TargetWidth, TargetHeight),0)].x) * FarPlane);
		if (UseReSTIRGI) PrevNormalTexWrite[id.xy] = packUnormArb(NormalTex[int3(Uv * float2(TargetWidth, TargetHeight),0)].xyz * 2.0f - 1.0f);
	#else
		if (UseReSTIRGI) PrevDepthTex[id.xy] = ScreenSpaceInfo[final_pixel_index].t;// length(ray.direction / dot(ray.direction, Forward) * Linear01Depth(Depth.SampleLevel(my_linear_clamp_sampler, Uv, 0).x) * FarPlane);
		if (UseReSTIRGI) PrevNormalTexWrite[id.xy] = CurrentReservoirGI[final_pixel_index].PrimaryNormal;// packUnormArb(NormalTex.SampleLevel(sampler_NormalTex, Uv, 0).xyz * 2.0f - 1.0f);
	#endif
	float3 res = (GlobalColors[final_pixel_index].Direct + GlobalColors[final_pixel_index].Indirect) * ((DiffRes || UseAtrous) ? 1.0f : AlbedoTex[id.xy].xyz) + unpackRGBE(GlobalColors[final_pixel_index].PrimaryNEERay) / (((DiffRes || UseAtrous) && AlbedoTex[id.xy].xyz != 0) ? AlbedoTex[id.xy].xyz : 1.0f);
	RenderMaskTex[id.xy] = AlbedoTex[id.xy].w;
	if (!all(res < 100000)) res = 0;
	Result[id.xy] = float4(res, 1.0f);
}




#pragma kernel kernel_reservoir
bool UseRestirPrecomputedSamples;


float4x4 viewprojection;
float4x4 prevviewprojection;

void UpdateReservoir(inout Reservoir r, float x, float w, float rndnum, float m, float3 Pos, float3 Norm)
{
	r.wsum += w;
	r.M += 1;
	if (rndnum < (w / r.wsum)) {
		r.y = x;
		r.MeshIndex = m;
		r.Position = Pos;
		r.Norm = Norm;
	}

}


void UpdateReservoir(inout Reservoir r, float x, float w, float rndnum, float m, float3 Pos, float3 Norm, Reservoir V)
{
	r.wsum += w;
	r.M += 1;
	if (rndnum < (w / r.wsum)) {
		r.y = x;
		r.MeshIndex = m;
		r.Position = Pos;
		r.Norm = Norm;
		r.PrevWorld = V.PrevWorld;
		r.PrevNorm = V.PrevNorm;
		r.W = V.W;
	}

}

float RadicalInverse_VdC(uint bits)
{
	bits = (bits << 16u) | (bits >> 16u);
	bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);
	bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);
	bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);
	bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);
	return float(bits) * 2.3283064365386963e-10; // / 0x100000000
}

//function to generate a hammersly low discrepency sequence for importance sampling
float2 Hammersley(uint i, uint N)
{
	return float2(float(i) / float(N), RadicalInverse_VdC(i));
}

struct LightBlockData {
	float3 Pos;
	float3 Norm;
	float3 Misc;
	float3 Rad;
	float2 PDFArea;
};


StructuredBuffer<LightBlockData> Blocks;

float3 camPos;

int lightsamplecount;
int spatialsamplecount;

static const float MultiplyData = (1.0 / 4294967296.0);
bool UseRestirTemporal;

groupshared LightBlockData tileBlock[512];

uniform bool UseSpatial;

int SpatialMCap;

float3 CreateCameraDirection(float2 uv) {
	// Invert the perspective projection of the view-space position
	float3 direction = mul(_CameraInverseProjection, float4(uv, 0.0f, 1.0f)).xyz;
	// Transform the direction from camera to world space and normalize
	direction = mul(unity_CameraToWorld, float4(direction, 0.0f)).xyz;
	return normalize(direction);
}

[numthreads(8, 8, 1)]
void kernel_reservoir(uint3 id : SV_DispatchThreadID, uint3 id2 : SV_GroupThreadID, uint3 id3 : SV_GroupID) {//Moved final accumulation into its own kernel, improves performance


	int i = 0;
	uint pixel_index =(id3.x + id3.y * screen_width / 8);
	if (UseRestirPrecomputedSamples) {
		const uint BlockIndex = floor(min(random(12, pixel_index).x * 128, 127)) * 512;
		const int Index = (id2.x + id2.y * 8) * 8;
		[unroll] for (int i = 0; i < 8; i++) {
			tileBlock[Index + i] = Blocks[BlockIndex + Index + i];
		}
	}
	GroupMemoryBarrierWithGroupSync();
	if (id.x >= screen_width || id.y >= screen_height) return;
	pixel_index = id.y * screen_width + id.x;
	const float2 UV = id.xy / float2(screen_width, screen_height);


	const float3 RayDir = CreateCameraDirection(UV * 2.0f - 1.0f);
	#ifdef HDRP
		float CurDist = length(RayDir / dot(RayDir, Forward) * Linear01Depth(Depth[int3(UV * float2(screen_width, screen_height),0)].x) * FarPlane);
	#else
		float CurDist = length(RayDir / dot(RayDir, Forward) * Linear01Depth(Depth.SampleLevel(my_linear_clamp_sampler, UV, 0).x) * FarPlane);
	#endif
	const float3 WorldPosition = camPos + RayDir * CurDist;
	
	const float LightPDFAddtion = (_UnityLights[unitylightcount - 1].CDF / (_UnityLights[unitylightcount - 1].CDF + _LightMeshes[LightMeshCount - 1].CDF));
	const float LightTriPDFAddtion = (_LightMeshes[LightMeshCount - 1].CDF / (_UnityLights[unitylightcount - 1].CDF + _LightMeshes[LightMeshCount - 1].CDF));

	Reservoir prevReservoir = { -1,0,0,0,0,0,0,0,0,0,0,0,0,-1,0,0,0,0,0,0,0,0,0 };
	#ifdef HDRP
		uint2 prevIndex = int2(floor(((float2(id.xy) + 0.5) * float2(rcp(screen_width), rcp(screen_height)) - MotionVectors[int3(UV * float2(screen_width, screen_height),0)].xy) * float2(screen_width, screen_height)));
	#else
		uint2 prevIndex = int2(floor(((float2(id.xy) + 0.5) * float2(rcp(screen_width), rcp(screen_height)) - MotionVectors.SampleLevel(sampler_MotionVectors, UV, 0).xy) * float2(screen_width, screen_height)));
	#endif
	if (prevIndex.x >= 0 && prevIndex.x < screen_width && prevIndex.y >= 0 && prevIndex.y < screen_height)
	{
		prevReservoir = PreviousReservoir[prevIndex.y * screen_width + prevIndex.x];
		if (prevReservoir.W == 0) prevReservoir.wsum = 0;
	}
	Reservoir reservoir = { -1,0,0,0,0,0,0,0,0,0,0,0,0,-1,0,0,0,0,0,0,0,0,0 };

	const ScreenSpaceData MatModifier = MatModifiersPrev[prevIndex.y * screen_width + prevIndex.x];
	HitMat hitmat;
	hitmat.surfaceColor = MatModifier.Albedo;
	hitmat.emmis = 0;
	hitmat.roughness = MatModifier.Roughness;
	hitmat.MatType = 1;
	hitmat.metallic = MatModifier.Metallic;
	hitmat.ior = MatModifier.ior;
	hitmat.specTrans = 0;
	hitmat.specularTint = 0;
	hitmat.clearcoat = MatModifier.Clearcoat;
	hitmat.clearcoatGloss = MatModifier.ClearCoatGloss;
	hitmat.diffTrans = 0;
	hitmat.sheen = 0;
	hitmat.sheenTint = 0;
	hitmat.anisotropic = 0;
	hitmat.flatness = 0;
	hitmat.transmittanceColor = 0;
	hitmat.phaseFunction = 0;
	hitmat.extinction = 0;
	hitmat.relativeIOR = 0;
	hitmat.Thin = 0;
	hitmat.scatterDistance = 0;
	hitmat.Specular = MatModifier.Specular;
	#ifdef HDRP
		const float3 Norm = normalize(NormalTex.SampleLevel(sampler_NormalTex, float3(UV, 0), 0).xyz * 2.0f - 1.0f);
	#else 
		const float3 Norm = normalize(NormalTex.SampleLevel(sampler_NormalTex, UV, 0).xyz * 2.0f - 1.0f);
	#endif
	const float3x3 NormTangentSpace = GetTangentSpace2(Norm);

		float3 LightPos;
		for (i = 0; i < lightsamplecount; i++) {
			const float Rand = floor(min(random(34 + i, pixel_index).y * 512, 511));
			LightPos = ((tileBlock[Rand].Misc.z == 1) ? (WorldPosition - tileBlock[Rand].Norm) : tileBlock[Rand].Pos);
			float3 L = (LightPos - WorldPosition);
			const float Dist = dot(L, L);
			L /= sqrt(Dist);
			float3 LightNorm = ((tileBlock[Rand].Misc.x < 0) ? ((tileBlock[Rand].Misc.z == 2) ? -tileBlock[Rand].Norm : -L) : tileBlock[Rand].Norm);
			float LightCos = abs(dot(L, LightNorm));
			float w;
			int LightMeshIndex = 0;
			[branch] if (tileBlock[Rand].Misc.z == -1) {
				float SA = LightCos * tileBlock[Rand].PDFArea.y / Dist;
				float NEE_pdf = (1.0f / (LightMeshCount * SA)) * tileBlock[Rand].PDFArea.x * LightTriPDFAddtion;
				float fpdf3, fpdf2;
				float3 bsdf_value2 = EvaluateDisney(hitmat, -RayDir, L, hitmat.Thin == 1, fpdf3, fpdf2, NormTangentSpace, pixel_index);
				w = (luminance(tileBlock[Rand].Rad * bsdf_value2)) / NEE_pdf;
				LightMeshIndex = tileBlock[Rand].Misc.x;
			}
			else {
				float NEE_pdf = Dist * LightCos / (tileBlock[Rand].PDFArea.x) * LightPDFAddtion;//PI is cuz of area
				float Attenuation = 1.0f;
				if (tileBlock[Rand].Misc.z == 2) {
					Attenuation = saturate(dot(L, -LightNorm) * _UnityLights[tileBlock[Rand].Misc.y].SpotAngle.x + _UnityLights[tileBlock[Rand].Misc.y].SpotAngle.y);
				}
				float fpdf3, fpdf2;
				float3 bsdf_value2 = EvaluateDisney(hitmat, -RayDir, L, hitmat.Thin == 1, fpdf3, fpdf2, NormTangentSpace, pixel_index);
				w = (luminance(tileBlock[Rand].Rad * bsdf_value2)) / NEE_pdf * Attenuation;
				LightMeshIndex = -tileBlock[Rand].Misc.z - 1;
			}
			UpdateReservoir(reservoir, tileBlock[Rand].Misc.y, w, random(34 + i, pixel_index).x, LightMeshIndex, LightPos, LightNorm);
		}


	float p_hat;
	if (reservoir.MeshIndex >= 0) {
		float3 lightPos = reservoir.Position;
		float3 L = lightPos - WorldPosition;
		float Dist = dot(L, L);
		L /= sqrt(Dist);
		float LightCos = abs(dot(L, reservoir.Norm));
		float SA = LightCos * LightTriangles[reservoir.y].area / Dist;
		float NEE_pdf = (1.0f / (LightMeshCount * SA)) * (LightTriangles[reservoir.y].pdf / _LightMeshes[reservoir.MeshIndex].pdf);
		float fpdf3, fpdf2;
		float3 bsdf_value2 = EvaluateDisney(hitmat, -RayDir, L, hitmat.Thin == 1, fpdf3, fpdf2, NormTangentSpace, pixel_index);
		p_hat = (luminance(LightTriangles[reservoir.y].radiance * bsdf_value2)) / NEE_pdf;
	}
	else {
		LightData light = _UnityLights[reservoir.y];
		float3 lightPos = reservoir.Position;
		float3 L = lightPos - WorldPosition;
		float Dist = dot(L, L);
		L /= sqrt(Dist);
		float LightCos = abs(dot(L, reservoir.Norm));
		float NEE_pdf = Dist * LightCos / (unitylightcount) * (_UnityLights[unitylightcount - 1].CDF / (_UnityLights[unitylightcount - 1].CDF + _LightMeshes[LightMeshCount - 1].CDF));
		float fpdf3, fpdf2;
		float3 bsdf_value2 = EvaluateDisney(hitmat, -RayDir, L, hitmat.Thin == 1, fpdf3, fpdf2, NormTangentSpace, pixel_index);
		float Attenuation = 1;
		if (_UnityLights[reservoir.y].Type == 2) {
			Attenuation = saturate(dot(L, -reservoir.Norm) * _UnityLights[reservoir.y].SpotAngle.x + _UnityLights[reservoir.y].SpotAngle.y);
		}
		p_hat = (luminance(light.Radiance * bsdf_value2)) / NEE_pdf * Attenuation;
	}
	reservoir.W = reservoir.wsum / max(p_hat * reservoir.M, 0.00001f);//(1.0f / max(p_hat, 0.00001f)) * (reservoir.wsum / max(reservoir.M, 0.0000001f));


if (UseRestirTemporal) {
		float Dist1 = CurDist;
		float Dist2 = length(prevReservoir.PrevWorld - camPos);
		if (abs(Dist1 - Dist2) / abs(Dist1) < 0.1f) {
			float normalDot = dot(Norm, prevReservoir.PrevNorm);
			if (normalDot > 0.5f) {
				float3 lightPos;
				float p_hat;
				if (prevReservoir.MeshIndex >= 0) {
					lightPos = prevReservoir.Position;
					float3 L = lightPos - WorldPosition;
					float Dist = dot(L, L);
					L /= sqrt(Dist);
					float LightCos = abs(dot(L, prevReservoir.Norm));
					float SA = LightCos * LightTriangles[prevReservoir.y].area / Dist;
					float NEE_pdf = (1.0f / (LightMeshCount * SA)) * (LightTriangles[prevReservoir.y].pdf / _LightMeshes[prevReservoir.MeshIndex].pdf);
					float fpdf3, fpdf2;
					float3 bsdf_value2 = EvaluateDisney(hitmat, -RayDir, L, hitmat.Thin == 1, fpdf3, fpdf2, NormTangentSpace, pixel_index);
					p_hat = (luminance(LightTriangles[prevReservoir.y].radiance * bsdf_value2)) / NEE_pdf;
				}
				else {
					LightData light = _UnityLights[prevReservoir.y];
					lightPos = prevReservoir.Position;
					float3 L = lightPos - WorldPosition;
					float Dist = dot(L, L);
					L /= sqrt(Dist);
					float LightCos = abs(dot(L, prevReservoir.Norm));
					float NEE_pdf = Dist * LightCos / (unitylightcount) * (_UnityLights[unitylightcount - 1].CDF / (_UnityLights[unitylightcount - 1].CDF + _LightMeshes[LightMeshCount - 1].CDF));
					float Attenuation = 1;
					if (light.Type == 2) {
						Attenuation = saturate(dot(L, -light.Direction) * light.SpotAngle.x + light.SpotAngle.y);
					}
					float fpdf3, fpdf2;
					float3 bsdf_value2 = EvaluateDisney(hitmat, -RayDir, L, hitmat.Thin == 1, fpdf3, fpdf2, NormTangentSpace, pixel_index);
					p_hat = (luminance(light.Radiance * bsdf_value2)) / NEE_pdf * Attenuation;
				}
				prevReservoir.M = min(prevReservoir.M, 320);
				UpdateReservoir(reservoir, prevReservoir.y, p_hat * prevReservoir.W * prevReservoir.M, random(43, pixel_index).x, prevReservoir.MeshIndex, prevReservoir.Position, prevReservoir.Norm, prevReservoir);

				reservoir.M = prevReservoir.M + reservoir.M - 1;

				if (reservoir.MeshIndex >= 0) {
					lightPos = reservoir.Position;
					float3 L = lightPos - WorldPosition;
					float Dist = dot(L, L);
					L /= sqrt(Dist);
					float LightCos = abs(dot(L, reservoir.Norm));
					float SA = LightCos * LightTriangles[reservoir.y].area / Dist;
					float NEE_pdf = (1.0f / (LightMeshCount * SA)) * (LightTriangles[reservoir.y].pdf / _LightMeshes[reservoir.MeshIndex].pdf);
					float fpdf3, fpdf2;
					float3 bsdf_value2 = EvaluateDisney(hitmat, -RayDir, L, hitmat.Thin == 1, fpdf3, fpdf2, NormTangentSpace, pixel_index);
					p_hat = (luminance(LightTriangles[reservoir.y].radiance * bsdf_value2)) / NEE_pdf;
				}
				else {
					LightData light = _UnityLights[reservoir.y];
					lightPos = reservoir.Position;
					float3 L = lightPos - WorldPosition;
					float Dist = dot(L, L);
					L /= sqrt(Dist);
					float LightCos = abs(dot(L, reservoir.Norm));
					float NEE_pdf = Dist * LightCos / (unitylightcount) * (_UnityLights[unitylightcount - 1].CDF / (_UnityLights[unitylightcount - 1].CDF + _LightMeshes[LightMeshCount - 1].CDF));
					float Attenuation = 1;
					if (light.Type == 2) {
						Attenuation = saturate(dot(L, -light.Direction) * light.SpotAngle.x + light.SpotAngle.y);
					}
					float fpdf3, fpdf2;
					float3 bsdf_value2 = EvaluateDisney(hitmat, -RayDir, L, hitmat.Thin == 1, fpdf3, fpdf2, NormTangentSpace, pixel_index);
					p_hat = (luminance(light.Radiance * bsdf_value2)) / NEE_pdf * Attenuation;
				}
				reservoir.W = (1.0f / max(reservoir.M, 0.0001f)) * reservoir.wsum / max(p_hat, 0.00001f); //reservoir.wsum / (p_hat * reservoir.M);
			}
		}
	}



	if (UseSpatial) {
		int2 CenterIndex = prevIndex;

		uint2 neighborOffset;
		uint2 neighborIndex;
		float WorldDepth = CurDist;
		for (int i = 0; i < spatialsamplecount; i++) {
			float radius = 30 * random(i, pixel_index).x;
			float angle = 2.0f * PI * random(i, pixel_index).y;

			int2 neighborIndex = round(CenterIndex + radius * float2(cos(angle), sin(angle)));

			if (neighborIndex.x < 0 || neighborIndex.x >= (int)screen_width || neighborIndex.y < 0 || neighborIndex.y >= (int)screen_height)
			{
				continue;
			}
			Reservoir neighborRes = PreviousReservoir[neighborIndex.y * uint(screen_width)+neighborIndex.x];
			float Depth = length(neighborRes.PrevWorld - camPos);
			if (
				abs(Depth - WorldDepth) / abs(Depth) >= 0.1f ||
				dot(neighborRes.PrevNorm, Norm) < 0.5f
				) {
				continue;
			}
			neighborRes.M = min(neighborRes.M, SpatialMCap);
			float p_hat;
			if (neighborRes.MeshIndex >= 0) {
				float3 lightPos = neighborRes.Position;
				float3 L = lightPos - WorldPosition;
				float Dist = dot(L, L);
				L /= sqrt(Dist);
				float LightCos = abs(dot(L, neighborRes.Norm));
				float SA = LightCos * LightTriangles[neighborRes.y].area / Dist;
				float NEE_pdf = (1.0f / (LightMeshCount * SA)) * (LightTriangles[neighborRes.y].pdf / _LightMeshes[neighborRes.MeshIndex].pdf);
				float fpdf3, fpdf2;
				float3 bsdf_value2 = EvaluateDisney(hitmat, -RayDir, L, hitmat.Thin == 1, fpdf3, fpdf2, NormTangentSpace, pixel_index);
				p_hat = (luminance(LightTriangles[neighborRes.y].radiance * bsdf_value2)) / NEE_pdf;
			}
			else {
				LightData light = _UnityLights[neighborRes.y];
				float3 L = neighborRes.Position - WorldPosition;
				float Dist = dot(L, L);
				L /= sqrt(Dist);
				float LightCos = abs(dot(L, neighborRes.Norm));
				float NEE_pdf = Dist * LightCos / (unitylightcount) * (_UnityLights[unitylightcount - 1].CDF / (_UnityLights[unitylightcount - 1].CDF + _LightMeshes[LightMeshCount - 1].CDF));
				float Attenuation = 1;
				if (light.Type == 2) {
					Attenuation = saturate(dot(L, -light.Direction) * light.SpotAngle.x + light.SpotAngle.y);
				}
				float fpdf3, fpdf2;
				float3 bsdf_value2 = EvaluateDisney(hitmat, -RayDir, L, hitmat.Thin == 1, fpdf3, fpdf2, NormTangentSpace, pixel_index);
				p_hat = (luminance(light.Radiance * bsdf_value2)) / NEE_pdf * Attenuation;
			}
			UpdateReservoir(reservoir, neighborRes.y, p_hat * neighborRes.M * neighborRes.W, random(i + 16, pixel_index).x, neighborRes.MeshIndex, neighborRes.Position, neighborRes.Norm, neighborRes);
			reservoir.M = reservoir.M + neighborRes.M - 1;

		}

		float p_hat;

		float3 lightPos;
		if (reservoir.MeshIndex >= 0) {
			lightPos = reservoir.Position;
			float3 L = lightPos - WorldPosition;
			float Dist = dot(L, L);
			L /= sqrt(Dist);
			float LightCos = abs(dot(L, reservoir.Norm));
			float SA = LightCos * LightTriangles[reservoir.y].area / Dist;
			float NEE_pdf = (1.0f / (LightMeshCount * SA)) * (LightTriangles[reservoir.y].pdf / _LightMeshes[reservoir.MeshIndex].pdf);
			float fpdf3, fpdf2;
			float3 bsdf_value2 = EvaluateDisney(hitmat, -RayDir, L, hitmat.Thin == 1, fpdf3, fpdf2, NormTangentSpace, pixel_index);
			p_hat = (luminance(LightTriangles[reservoir.y].radiance * bsdf_value2)) / NEE_pdf;
		}
		else {
			LightData light = _UnityLights[reservoir.y];
			lightPos = reservoir.Position;
			float3 L = lightPos - WorldPosition;
			float Dist = dot(L, L);
			L /= sqrt(Dist);
			float LightCos = abs(dot(L, reservoir.Norm));
			float NEE_pdf = Dist * LightCos / (unitylightcount) * (_UnityLights[unitylightcount - 1].CDF / (_UnityLights[unitylightcount - 1].CDF + _LightMeshes[LightMeshCount - 1].CDF));
			float Attenuation = 1;
			if (light.Type == 2) {
				Attenuation = saturate(dot(L, -light.Direction) * light.SpotAngle.x + light.SpotAngle.y);
			}
			float fpdf3, fpdf2;
			float3 bsdf_value2 = EvaluateDisney(hitmat, -RayDir, L, hitmat.Thin == 1, fpdf3, fpdf2, NormTangentSpace, pixel_index);
			p_hat = (luminance(light.Radiance * bsdf_value2)) / NEE_pdf * Attenuation;
		}
		reservoir.W = (1.0f / max(reservoir.M, 0.00001f)) * reservoir.wsum / p_hat; //reservoir.wsum / (p_hat * reservoir.M);
	}



	if (reservoir.y == -1 || !(reservoir.W > 0 || reservoir.W < 0 || reservoir.W == 0)) {
		reservoir.y = -1;
		reservoir.W = 0;
		reservoir.wsum = 0;
		reservoir.M = 0;
	}


	reservoir.PrevWorld = WorldPosition;
	reservoir.PrevNorm = Norm;
	CurrentReservoir[id.y * screen_width + id.x] = reservoir;


}

RWStructuredBuffer<LightBlockData> WriteBlocks;


#pragma kernel kernel_reservoir_precompute

bool DoIndirectClamping;

[numthreads(64, 1, 1)]
void kernel_reservoir_precompute(uint3 id : SV_DispatchThreadID, uint3 id2 : SV_GroupThreadID, uint3 id3 : SV_GroupID) {//Moved final accumulation into its own kernel, improves performance
	uint pixel_index = (id.x + id.y * screen_width);
	for (int i = 0; i < 8; i++) {
		bool UseUnityLight = (unitylightcount != 0) ? (LightMeshCount != 0) ? (random(i, pixel_index).x <= (_UnityLights[unitylightcount - 1].CDF / (_UnityLights[unitylightcount - 1].CDF + _LightMeshes[LightMeshCount - 1].CDF))) : true : false;//Choose whether to sample unity lights or mesh lights based off which is more powerful
		int lighttosample;
		float w;
		int LightMesh = 0;
		float3 LightNorm;
		float3 lightPos;
		int LightMeshIndex;
		float3 Radiance;
		int LightType = -1;
		float PDF;
		float Area = 0;
		if (UseUnityLight) {
			lighttosample = floor(min(random(i, pixel_index).y * unitylightcount, unitylightcount - 1));
			LightData light = _UnityLights[lighttosample];
			lightPos = light.Position;
			LightNorm = -light.Direction;
			Radiance = light.Radiance;
			LightMeshIndex = -1;
			LightType = light.Type;
			PDF = (_UnityLights[lighttosample].CDF / (_UnityLights[unitylightcount - 1].CDF) * unitylightcount);
		}
		else {
			LightMeshIndex = floor(min(random(i + 16, pixel_index).x * LightMeshCount, LightMeshCount - 1));
			const LightMeshData LightMesh = _LightMeshes[LightMeshIndex];
			lighttosample = SelectLight(LightMeshIndex, random(i + 36, pixel_index));// clamp((random(i + 16, pixel_index).y * (IndexEnd - StartIndex)) + StartIndex, StartIndex, IndexEnd - 1);
			const LightTriangleData Light = LightTriangles[lighttosample];
			float2 CurUv = sample_triangle(random(i + 32, pixel_index).x, random(i + 32, pixel_index).y);
			lightPos = mul(LightMesh.Inverse, float4(Light.pos0 + CurUv.x * Light.posedge1 + CurUv.y * Light.posedge2, 1)).xyz;
			LightNorm = normalize(mul(LightMesh.Inverse, float4(Light.Norm, 0.0f)).xyz);
			Radiance = Light.radiance;
			Area = Light.area;
			PDF = (LightTriangles[lighttosample].pdf / _LightMeshes[LightMeshIndex].pdf);
		}
		WriteBlocks[id2.x * 8 + i + id3.x * 512].Pos = lightPos;
		WriteBlocks[id2.x * 8 + i + id3.x * 512].Norm = LightNorm;
		WriteBlocks[id2.x * 8 + i + id3.x * 512].Rad = Radiance;
		WriteBlocks[id2.x * 8 + i + id3.x * 512].Misc = float3(LightMeshIndex, lighttosample, LightType);
		WriteBlocks[id2.x * 8 + i + id3.x * 512].PDFArea = float2(PDF, Area);
	}
}


#pragma kernel kernel_GI_Reserviour

void UpdateReservoir(inout GIReservoir A, GIReservoir B, float w, float rndnum, inout float wsum) {
	A.M += B.M + 1;
	wsum += w;
	if (rndnum < (w / wsum)) {
		A.SecondaryHitPosition = B.SecondaryHitPosition;
		A.HistoricID = B.HistoricID;
		A.HistoricFrame = B.HistoricFrame;
		A.RadianceDirect = B.RadianceDirect;
		A.RadianceIndirect = B.RadianceIndirect;
		A.NEERay = B.NEERay;
		A.ThisCase = B.ThisCase;
		A.BaseColor = B.BaseColor;
		A.NEEPosition = B.NEEPosition;
		A.LuminanceIncomming = B.LuminanceIncomming;
	}

}

bool UseReSTIRGISpatial;
bool UseReSTIRGITemporal;
int ReSTIRGISpatialCount;
bool DoReSTIRGIConnectionValidation;
bool AbandonSamples;
int ReSTIRGITemporalMCap;
bool SpatialStabalizer;
float3 PrevCamPos;
float3 CamPos;
float3 cameraForward;
float4x4 inverseview;
float4x4 prevviewmatrix;

float3 proj_point_in_plane(float3 p, float3 v0, float3 n, out float d) {
	d = dot(n, p - v0);
	return p - (n * d);
}

float3 find_reflection_incident_point(float3 p0, float3 p1, float3 v0, float3 n) {
	float d0 = 0;
	float d1 = 0;
	float3 proj_p0 = proj_point_in_plane(p0, v0, n, d0);
	float3 proj_p1 = proj_point_in_plane(p1, v0, n, d1);

	if (d1 < d0)
		return (proj_p0 - proj_p1) * d1 / (d0 + d1) + proj_p1;
	else
		return (proj_p1 - proj_p0) * d0 / (d0 + d1) + proj_p0;
}
float3 InvProjectPosition(float3 coord, float4x4 mat) {
	// coord.y = (1 - coord.y);
	// coord.xy = 2 * coord.xy - 1;
	float4 projected = mul(mat, float4(coord, 1));
	projected.xyz /= projected.w;
	return projected.xyz;
}

Texture2D<float4> PrevPosTex;

float2 find_previous_reflection_position(
	float2 ss_pos, float2 ss_ray,
	float2 surface_motion_vector, float2 reflection_motion_vector,
	float3 world_normal, float camlength) {
	float3 ss_p0 = 0;
	ss_p0.xy = ss_pos.xy - surface_motion_vector;
	ss_p0.z = PrevPosTex[ss_p0.xy * float2(screen_width, screen_height)].w;

	float3 ss_p1 = 0;
	ss_p1.xy = ss_ray.xy - reflection_motion_vector;
	ss_p1.z = PrevPosTex[ss_p1.xy * float2(screen_width, screen_height)].w;

	float3 view_n = world_normal;//normalize(mul(prevviewmatrix, float4(world_normal, 0)));
	float3 view_p0 = float3(0, 0, 0);
	float3 view_v0 = InvProjectPosition(ss_p0, _CameraInverseProjection);// mul(_CameraInverseProjection, float4(ss_p0, 1)).xyz / mul(_CameraInverseProjection, float4(ss_p0, 1)).w;
	float3 view_p1 = InvProjectPosition(ss_p1, _CameraInverseProjection);//mul(_CameraInverseProjection, float4(ss_p1, 1)).xyz / mul(_CameraInverseProjection, float4(ss_p1, 1)).w;

	float3 view_intersection =
		find_reflection_incident_point(view_p0, view_p1, view_v0, view_n);
	float4 ss_intersection = mul(float4(view_intersection, 1), _CameraInverseProjection);//view_to_ss(view_intersection, 1);

	return ss_intersection.xy / ss_intersection.w;
}
float EvalPHat(const GIReservoir TargetRes, float3 bsdfVal, float3 NEEbsdfVal, float bsdfpdf, float NEEbsdfpdf) {
    return luminance((TargetRes.RadianceDirect + TargetRes.RadianceIndirect) * ((UseAlteredPipeline) ? 1 : bsdfVal) * step(0, bsdfpdf) + TargetRes.NEERay * ((UseAlteredPipeline) ? 1 : NEEbsdfVal)* step(0, NEEbsdfpdf));
}
float EvalPHatIndirect(const GIReservoir TargetRes, float3 bsdfVal, float bsdfpdf) {
    return luminance((TargetRes.RadianceIndirect) * ((UseAlteredPipeline) ? 1 : bsdfVal) * step(0, bsdfpdf));
}


const static int2 offsets[4] = {
	int2(-1, -1),
	int2(1, 1),
	int2(-1, 1),
	int2(1, -1),
};
const static uint2 xor_seq[4] = {
	uint2(3, 3),
	uint2(2, 1),
	uint2(1, 2),
	uint2(3, 3),
};

int2 get_rpx_offset(uint sample_i, uint frame_index) {

	const int2 reservoir_px_offset_base =
		offsets[frame_index & 3]
		+ offsets[(sample_i + (frame_index ^ 1)) & 3];

	return
		sample_i == 0
		? 0
		: int2(reservoir_px_offset_base)
		;
}
bool UpdateReservoir2(inout GIReservoir A, GIReservoir B, float w, float rndnum, inout float wsum) {
	A.M += B.M;
	wsum += w;
	if (rndnum < (w / wsum)) {
		A.SecondaryHitPosition = B.SecondaryHitPosition;
		A.HistoricID = B.HistoricID;
		A.HistoricFrame = B.HistoricFrame;
		A.RadianceDirect = B.RadianceDirect;
		A.RadianceIndirect = B.RadianceIndirect;
		A.NEERay = B.NEERay;
		A.ThisCase = B.ThisCase;
		A.BaseColor = B.BaseColor;
		A.NEEPosition = B.NEEPosition;
		A.LuminanceIncomming = B.LuminanceIncomming;
		return true;
	}
	return false;

}

Texture2D<float4> AlbedoTexRead;
float MinSpatialSize;


[numthreads(12, 12, 1)]
void kernel_GI_Reserviour(uint3 id : SV_DispatchThreadID, uint3 id2 : SV_GroupThreadID, uint3 id3 : SV_GroupID, uint id4 : SV_GroupIndex) {
	if (id.x >= screen_width || id.x < 0 || id.y >= screen_height || id.x < 0) return;
	int index = id.x + id.y * screen_width;
	uint pixel_index = index;
	GIReservoir CurrentRes = CurrentReservoirGI[index];
	Ray ray = CreateCameraRay(id.xy / float2(screen_width, screen_height) * 2.0f - 1.0f, pixel_index);

	CurrentRes.RadianceDirect = GlobalColors[id.x + id.y * screen_width].Direct;
	CurrentRes.RadianceIndirect = GlobalColors[id.x + id.y * screen_width].Indirect;
	GIReservoir prevReservoir = { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};

	MaterialData TempMat = _Materials[(int)CurrentRes.MaterialIndex.x];
	const ScreenSpaceData MatModifier = ScreenSpaceInfo[index];
	float3 PrimaryHitPosition = MatModifier.Position;
	HitMat hitmat;
	hitmat.surfaceColor = MatModifier.Albedo;
	hitmat.emmis = TempMat.emmissive;
	hitmat.roughness = MatModifier.Roughness;
	hitmat.MatType = TempMat.MatType;
	hitmat.metallic = MatModifier.Metallic;
	hitmat.ior = MatModifier.ior;
	hitmat.specTrans = TempMat.specTrans;
	hitmat.specularTint = TempMat.specularTint;
	hitmat.clearcoat = MatModifier.Clearcoat;
	hitmat.clearcoatGloss = MatModifier.ClearCoatGloss;
	hitmat.diffTrans = TempMat.diffTrans;
	hitmat.sheen = TempMat.sheen;
	hitmat.sheenTint = TempMat.sheenTint;
	hitmat.anisotropic = TempMat.anisotropic;
	hitmat.flatness = TempMat.flatness;
	hitmat.transmittanceColor = TempMat.transmittanceColor;
	hitmat.phaseFunction = 0;
	hitmat.extinction = 0;
	hitmat.relativeIOR = TempMat.ior;
	hitmat.Thin = TempMat.Thin;
	hitmat.scatterDistance = 0;
	hitmat.Specular = MatModifier.Specular;

	bool ActuallyRender = (AlbedoTexRead[id.xy].w == 1);
	float2 UV = id.xy / float2(screen_width, screen_height);
	const float3 Norm = unpackUnormArb(MatModifier.NormNormal);
	const float3x3 NormTangentSpace = GetTangentSpace2(Norm);
	const float3 GeomNorm = unpackUnormArb(CurrentRes.PrimaryNormal);
	bool SuccessfullyReprojected = false;
	#ifdef HDRP
		float2 MotionVector = MotionVectors[int3(UV * float2(TargetWidth, TargetHeight),0)].xy;
	#else
		float2 MotionVector = MotionVectors.SampleLevel(my_linear_clamp_sampler, UV, 0).xy;
	#endif


	uint2 prevIndex;
#ifdef UseReflectionReproject 
	if (CurrentRes.ThisCase.x == 0 && hitmat.roughness < 0.15f) {
		float4 curprojectedrefl = mul(viewprojection, float4(CamPos + normalize(PrimaryHitPosition - CamPos) * (MatModifier.t + length(PrimaryHitPosition - CamPos)), 1));
		float4 prevprojectedrefl = mul(prevviewprojection, float4(CamPos + normalize(PrimaryHitPosition - CamPos) * (MatModifier.t + length(PrimaryHitPosition - CamPos)), 1));
		float2 reflprojection = ((curprojectedrefl.xy / curprojectedrefl.w) - (prevprojectedrefl.xy / prevprojectedrefl.w)) * 0.5f;
		MotionVector = reflprojection;
	}
#endif
	int2 ID = id.xy;
	prevIndex = int2(floor(((float2(ID.xy) + 0.5) * float2(rcp(screen_width), rcp(screen_height)) - MotionVector) * float2(screen_width, screen_height)));
	if (prevIndex.x >= 0 && prevIndex.x < screen_width && prevIndex.y >= 0 && prevIndex.y < screen_height) {
		prevReservoir = PreviousReservoirGI[prevIndex.y * screen_width + prevIndex.x];
		// SuccessfullyReprojected = true;
	}
	bool SkipTemporal = false;
	float wsumIndirect = 0;

	PrimaryHitPosition += GeomNorm * 0.001f;
	if (ActuallyRender && !AbandonSamples) {
	GlobalColors[id.x + id.y * screen_width].Direct = 0;
	GlobalColors[id.x + id.y * screen_width].Indirect = 0;
		// if(UseASVGF && ReSTIRGIUpdateRate == 0) CurrentRes.NEERay = unpackRGBE(GlobalColors[id.x + id.y * screen_width].PrimaryNEERay);
		// if(UseASVGF && RandomNums[id.xy].w == 1 && ReSTIRGIUpdateRate == 0) {
		// 	SpatialReservoirGI[index] = CurrentRes;
		// 	if(MatModifier.Roughness > 0.18f && CurrentRes.ThisCase == 0) {
		// 		SpatialReservoirGI[index].ThisCase = 2;
		// 	}
		// 	return;
		// }
		float fpdf3;
		float3 bsdf_value;
		const float3 RayDir = normalize(PrimaryHitPosition - CamPos);
		float CurDist = MatModifier.t;// length(RayDir / dot(RayDir, Forward) * Linear01Depth(Depth.SampleLevel(my_linear_clamp_sampler, UV, 0).x) * FarPlane);
		float PrevDist = PrevDepthTex[prevIndex].x;
		// if(((abs(CurDist - PrevDist))) / CurDist > 0.1f) SuccessfullyReprojected = false; 
		if(RandomNums[id.xy].z == 1 && !UseASVGF && ReSTIRGIUpdateRate != 0) {
			// if(DoTemporal) {
				if(abs(prevReservoir.LuminanceIncomming - CurrentRes.LuminanceIncomming) > 0.1f * min(CurrentRes.LuminanceIncomming, prevReservoir.LuminanceIncomming)) {
					CurrentRes.NEERay = 0;
					CurrentRes.RadianceDirect = 0;
					CurrentRes.RadianceIndirect = 0;
					CurrentRes.M = prevReservoir.M;
					if(!UsePermutatedSamples) CurrentRes.M = 1;
				} else {
					CurrentRes = prevReservoir;
					// CurrentRes.M += 1;
				}
				SkipTemporal = true;
			// }
		}
			if(ReSTIRGIUpdateRate != 0) {
				CurrentRes.RadianceDirect *= rcp(ReSTIRGIUpdateRate / (ReSTIRGIUpdateRate - 1));
				CurrentRes.RadianceIndirect *= rcp(ReSTIRGIUpdateRate / (ReSTIRGIUpdateRate - 1));
				CurrentRes.NEERay *= rcp(ReSTIRGIUpdateRate / (ReSTIRGIUpdateRate - 1));
			}
		float p_q;
		float fpdf;
		float wsum = 0;
		bool Valid = ReconstructBsdf(hitmat, RayDir, normalize(CurrentRes.SecondaryHitPosition - PrimaryHitPosition), Norm, fpdf, bsdf_value, CurrentRes.ThisCase.x, NormTangentSpace, pixel_index);
		float3 bsdf_value2;
		float fpdf2;
		CurrentRes.NEERay *= EvaluateBsdf(hitmat, RayDir, normalize(CurrentRes.NEEPosition - PrimaryHitPosition), Norm, fpdf3, bsdf_value2, pixel_index);
		p_q = EvalPHat(CurrentRes, bsdf_value, bsdf_value2, fpdf, fpdf3);
		wsum = p_q;
		wsumIndirect = EvalPHatIndirect(CurrentRes, bsdf_value, fpdf);
		// if (!Valid) wsum = 0;
		if(SkipTemporal) SuccessfullyReprojected = true;
		if(!SkipTemporal) if (!UsePermutatedSamples) {
				float DistDiff = ((abs(CurDist - PrevDist) - length(CamPos - PrevCamPos))) / CurDist;

				bool DoTemporal = DistDiff < 0.1f && (dot(unpackUnormArb(CurrentRes.PrimaryNormal), unpackUnormArb(prevReservoir.PrimaryNormal)) > 0.9f);
				if (DoTemporal && UseReSTIRGITemporal) {
					SuccessfullyReprojected = true;

					if (ReSTIRGITemporalMCap != 0) prevReservoir.M = min(prevReservoir.M, ReSTIRGITemporalMCap);
					Valid = ReconstructBsdf(hitmat, RayDir, normalize(prevReservoir.SecondaryHitPosition - PrimaryHitPosition), Norm, fpdf, bsdf_value, prevReservoir.ThisCase.x, NormTangentSpace, pixel_index);
					prevReservoir.NEERay *= EvaluateBsdf(hitmat, RayDir, normalize(prevReservoir.NEEPosition - PrimaryHitPosition), Norm, fpdf3, bsdf_value2, pixel_index);



					Valid = Valid && all(bsdf_value < 0 || bsdf_value > 0 || bsdf_value == 0) && luminance(bsdf_value) < 100000.0f;// && (abs(hitmat.roughness - MatModifiersPrev[prevIndex.x + prevIndex.y * screen_width].Roughness) < 0.1f);
					// frames_accumulated++;
					float Prev_p_q = EvalPHat(prevReservoir, bsdf_value, bsdf_value2, fpdf, fpdf3);
					if (Valid)UpdateReservoir(CurrentRes, prevReservoir, max(Prev_p_q * prevReservoir.M * prevReservoir.W * Valid, 0), random(23, pixel_index).x, wsum);
					if(Valid) wsumIndirect += EvalPHatIndirect(CurrentRes, bsdf_value, fpdf) * prevReservoir.M * prevReservoir.W;
				}
				else {
					CurrentRes.M++;
				}


				Valid = ReconstructBsdf(hitmat, RayDir, normalize(CurrentRes.SecondaryHitPosition - PrimaryHitPosition), Norm, fpdf, bsdf_value, CurrentRes.ThisCase.x, NormTangentSpace, pixel_index);
				CurrentRes.NEERay *= EvaluateBsdf(hitmat, RayDir, normalize(CurrentRes.NEEPosition - PrimaryHitPosition), Norm, fpdf3, bsdf_value2, pixel_index);
				Valid = Valid && all(bsdf_value < 0 || bsdf_value > 0 || bsdf_value == 0) && luminance(bsdf_value) < 100000.0f;

				if (!Valid) return;

				p_q = EvalPHat(CurrentRes, bsdf_value, bsdf_value2, fpdf, fpdf3);
				CurrentRes.W = wsum / max((CurrentRes.M * p_q), 0.00001f);
		}
		else {
			const uint2 permutation_xor_val =
				xor_seq[frames_accumulated & 3];
			ID = (ID + get_rpx_offset(0, frames_accumulated)) ^ permutation_xor_val;
			ID += get_rpx_offset(0, frames_accumulated);
			prevIndex = int2(floor(((float2(ID.xy) + 0.5) * float2(rcp(screen_width), rcp(screen_height)) - MotionVector) * float2(screen_width, screen_height)));
			for (int i = 0; i < 5; i++) {
				int2 rpx_offset = get_rpx_offset(i, frames_accumulated);


				const static uint2 xor_seq[4] = {
					uint2(3, 3),
					uint2(2, 1),
					uint2(1, 2),
					uint2(3, 3),
				};
				const uint2 permutation_xor_val =
					xor_seq[frames_accumulated & 3];
				const float2 reproj_rand_offset = 0.0;
				const int2 permuted_reproj_px = floor(
					(i == 0
						? id.xy
						: ((id.xy + rpx_offset) ^ permutation_xor_val))
					- float2(screen_width, screen_height) * MotionVector.xy + reproj_rand_offset + 0.5);
				const int2 rpx = permuted_reproj_px + rpx_offset;
				if(UseASVGF && RandomNums[rpx].w == 1) continue;
				if (rpx.x >= 0 && rpx.x < (int)screen_width && rpx.y >= 0 && rpx.y < (int)screen_height) {
					prevReservoir = PreviousReservoirGI[rpx.y * screen_width + rpx.x];
					// SuccessfullyReprojected = true;
				}
				float PrevDist = PrevDepthTex[rpx].x;
				float DistDiff = ((abs(CurDist - PrevDist) - length(CamPos - PrevCamPos))) / CurDist;

				bool DoTemporal = DistDiff < 0.1f && (dot(unpackUnormArb(prevReservoir.PrimaryNormal), unpackUnormArb(CurrentRes.PrimaryNormal)) > 0.9f);
				if (DoTemporal && UseReSTIRGITemporal) {
					if (ReSTIRGITemporalMCap != 0) prevReservoir.M = min(prevReservoir.M, ReSTIRGITemporalMCap);
					Valid = ReconstructBsdf(hitmat, RayDir, normalize(prevReservoir.SecondaryHitPosition - PrimaryHitPosition), Norm, fpdf, bsdf_value, prevReservoir.ThisCase.x, NormTangentSpace, pixel_index);
					prevReservoir.NEERay *= EvaluateBsdf(hitmat, RayDir, normalize(prevReservoir.NEEPosition - PrimaryHitPosition), Norm, fpdf3, bsdf_value2, pixel_index);
		SuccessfullyReprojected = true;



					float Prev_p_q = EvalPHat(prevReservoir, bsdf_value, bsdf_value2, fpdf, fpdf3);
					Valid = Valid && all(bsdf_value < 0 || bsdf_value > 0 || bsdf_value == 0) && luminance(bsdf_value) < 100000.0f && (abs(hitmat.roughness - MatModifiersPrev[rpx.x + rpx.y * screen_width].Roughness) <= 0.1f) && RandomNums[rpx + float2(screen_width, screen_height) * MotionVector.xy].z != 1;
					if(Valid) if (UpdateReservoir2(CurrentRes, prevReservoir, max(Prev_p_q * prevReservoir.M * prevReservoir.W * Valid, 0), random(23 + i, pixel_index).x, wsum)) prevIndex = rpx;
					if(Valid) wsumIndirect += EvalPHatIndirect(CurrentRes, bsdf_value, fpdf) * prevReservoir.M * prevReservoir.W;
					
				}
				if (CurrentRes.M > 20 * 1.25f) break;
			}
			CurrentRes.M++;


			Valid = ReconstructBsdf(hitmat, RayDir, normalize(CurrentRes.SecondaryHitPosition - PrimaryHitPosition), Norm, fpdf, bsdf_value, CurrentRes.ThisCase.x, NormTangentSpace, pixel_index);
			CurrentRes.NEERay *= EvaluateBsdf(hitmat, RayDir, normalize(CurrentRes.NEEPosition - PrimaryHitPosition), Norm, fpdf3, bsdf_value2, pixel_index);
			Valid = Valid && all(bsdf_value < 0 || bsdf_value > 0 || bsdf_value == 0) && luminance(bsdf_value) < 100000.0f;

			if (!Valid) return;

			p_q = EvalPHat(CurrentRes, bsdf_value, bsdf_value2, fpdf, fpdf3);
			CurrentRes.W = wsum / max((CurrentRes.M * p_q), 0.00001f);
#ifdef ExtraSampleValidation
			if (DoReSTIRGIConnectionValidation) {
				float Distance = length(PrimaryHitPosition - (CurrentRes.SecondaryHitPosition)) - 0.001f;
				Ray ray = CreateRay(PrimaryHitPosition + GeomNorm * 0.0001f, normalize(((CurrentRes.SecondaryHitPosition) - PrimaryHitPosition)));

				bool ConnectedlyVisable = VisabilityCheck(ray, Distance);
				if (!ConnectedlyVisable) { CurrentRes.RadianceDirect = 0; CurrentRes.RadianceIndirect = 0; }
				if (all(CurrentRes.NEERay != 0)) {
					Distance = length(PrimaryHitPosition - (CurrentRes.NEEPosition)) - 0.001f;
					ray = CreateRay(PrimaryHitPosition + GeomNorm * 0.0001f, normalize(((CurrentRes.NEEPosition) - PrimaryHitPosition)));

					ConnectedlyVisable = VisabilityCheck(ray, Distance);
					if (!ConnectedlyVisable) { CurrentRes.NEERay = 0; }
				}
			}
#endif
		}

		int PrevM = CurrentRes.M;
		bool DoReset = wsumIndirect != 0 && (((wsumIndirect) / max((CurrentRes.M * EvalPHatIndirect(CurrentRes, bsdf_value, fpdf)), 0.00001f)) * CurrentRes.M / (wsumIndirect) < 0.01f) && CurrentRes.W < 0.1f;// && lerp(fpdf, fpdf3, clamp(luminance(CurrentRes.NEERay) / luminance(CurrentRes.RadianceDirect + CurrentRes.RadianceIndirect),0,1)) < 0.01f;// && length(PrimaryHitPosition - (CurrentRes.NEEPosition)) > luminance(CurrentRes.NEERay);
		float PrevW = CurrentRes.W;
		if (DoReset && DoIndirectClamping || CurrentRes.W > 10) {
			CurrentRes.W = 0;

		}
		CurrentReservoirGI[index] = CurrentRes;
		GIReservoir neighborRes;
		if (!SkipTemporal && UseReSTIRGISpatial) {
			uint2 CenterIndex = prevIndex;
			uint2 neighborOffset;
			uint2 neighborIndex;
			int TempSpatialCount = ReSTIRGISpatialCount;
			if(!SuccessfullyReprojected) {TempSpatialCount = 21; CenterIndex = id.xy;}
			float radius = 60;
			for (int i = 0; i < TempSpatialCount; i++) {
				radius = max(max(radius * 0.5f, MinSpatialSize)*random(i, pixel_index).x,2);
				float angle = 2.0f * PI * random(i, pixel_index).y;
				int2 neighborIndex = round(CenterIndex + radius * float2(cos(angle), sin(angle)));
				if (neighborIndex.x < 0 || neighborIndex.x >= (int)screen_width || neighborIndex.y < 0 || neighborIndex.y >= (int)screen_height) continue;
				neighborRes = PreviousReservoirGI[neighborIndex.y * uint(screen_width)+neighborIndex.x];
				float PrevDist = PrevDepthTex[neighborIndex].x;
				float DistDiff = (abs(CurDist - PrevDist)) / CurDist;
				if (
					(SuccessfullyReprojected && (DistDiff >= 0.1f || neighborRes.ThisCase != CurrentRes.ThisCase)) ||
					dot(unpackUnormArb(neighborRes.PrimaryNormal), unpackUnormArb(CurrentRes.PrimaryNormal)) < 0.99// || RandomNums[round(id.xy + radius * float2(cos(angle), sin(angle)))].z == 1
					) {
					continue;
				}
				// frames_accumulated++;
				Valid = ReconstructBsdf(hitmat, RayDir, normalize(neighborRes.SecondaryHitPosition - PrimaryHitPosition), Norm, fpdf, bsdf_value, neighborRes.ThisCase.x, NormTangentSpace, pixel_index);
				Valid = Valid && all(bsdf_value < 0 || bsdf_value > 0 || bsdf_value == 0) && luminance(bsdf_value) < 100000.0f;// && fpdf > 0.25f;
				neighborRes.NEERay *= EvaluateBsdf(hitmat, RayDir, normalize(neighborRes.NEEPosition - PrimaryHitPosition), Norm, fpdf3, bsdf_value2, pixel_index);
				if (!Valid) continue;
				// if (SpatialStabalizer) { neighborRes.M = min(neighborRes.M, 12); }
				CurrentRes.M--;


				p_q = EvalPHat(neighborRes, bsdf_value, bsdf_value2, fpdf, fpdf3);
				UpdateReservoir(CurrentRes, neighborRes, max(p_q * neighborRes.M * neighborRes.W, 0), random(i + 16, pixel_index).x, wsum);
				wsumIndirect += EvalPHatIndirect(CurrentRes, bsdf_value, fpdf) * neighborRes.M * neighborRes.W;
			}

			Valid = ReconstructBsdf(hitmat, RayDir, normalize(CurrentRes.SecondaryHitPosition - PrimaryHitPosition), Norm, fpdf, bsdf_value, CurrentRes.ThisCase.x, NormTangentSpace, pixel_index);
			Valid = Valid && all(bsdf_value < 0 || bsdf_value > 0 || bsdf_value == 0) && luminance(bsdf_value) < 100000.0f;
			CurrentRes.NEERay *= EvaluateBsdf(hitmat, RayDir, normalize(CurrentRes.NEEPosition - PrimaryHitPosition), Norm, fpdf3, bsdf_value2, pixel_index);
			// if (!Valid) return;

			p_q = EvalPHat(CurrentRes, bsdf_value, bsdf_value2, fpdf, fpdf3);
			CurrentRes.W = wsum / max((CurrentRes.M * p_q), 0.00001f);
		}

		if ((p_q == 0 || CurrentRes.M == 0) || CurrentRes.W > 10) {
			CurrentRes.W = 0;
		}

		if (DoReSTIRGIConnectionValidation) {
			float Distance = length(PrimaryHitPosition - (CurrentRes.SecondaryHitPosition)) - 0.001f;
			Ray ray = CreateRay(PrimaryHitPosition + GeomNorm * 0.0001f, normalize(((CurrentRes.SecondaryHitPosition) - PrimaryHitPosition)));

			bool ConnectedlyVisable = VisabilityCheck(ray, Distance);
			if (!ConnectedlyVisable) { CurrentRes.RadianceDirect = 0; CurrentRes.RadianceIndirect = 0; }
#ifdef ExtraSampleValidation
			if (all(CurrentRes.NEERay != 0)) {
				Distance = length(PrimaryHitPosition - (CurrentRes.NEEPosition)) - 0.001f;
				Ray ray = CreateRay(PrimaryHitPosition + GeomNorm * 0.0001f, normalize(((CurrentRes.NEEPosition) - PrimaryHitPosition)));

				ConnectedlyVisable = VisabilityCheck(ray, Distance);
			if (!ConnectedlyVisable) { CurrentRes.NEERay = 0; }
			}
#endif
		}

		DoReset = wsumIndirect != 0 && (((wsumIndirect) / max((CurrentRes.M * EvalPHatIndirect(CurrentRes, bsdf_value, fpdf)), 0.00001f)) * CurrentRes.M / (wsumIndirect) < 0.01f) && CurrentRes.W < 0.1f;
		if (DoReset && DoIndirectClamping) {
			CurrentRes.W = 0;
			return;
		}
		if (SpatialStabalizer && !SuccessfullyReprojected) {
			CurrentRes.M = 1;
			CurrentReservoirGI[index] = CurrentRes;
		}
		// CurrentRes.W = clamp(CurrentRes.W, 0, 1);
			if(DiffRes) hitmat.surfaceColor = 1;
			CurrentRes.NEERay *= EvaluateBsdf(hitmat, RayDir, normalize(CurrentRes.NEEPosition - PrimaryHitPosition), Norm, fpdf3, bsdf_value2, pixel_index);
			Valid = ReconstructBsdf(hitmat, RayDir, normalize(CurrentRes.SecondaryHitPosition - PrimaryHitPosition), Norm, fpdf, bsdf_value, CurrentRes.ThisCase.x, NormTangentSpace, pixel_index);
			Valid = Valid && all(bsdf_value < 0 || bsdf_value > 0 || bsdf_value == 0) && luminance(bsdf_value) < 100000.0f;
			if(!Valid) return;
			if (!UseAlteredPipeline && Valid) TempAlbedoTex[id.xy] = float4(abs(bsdf_value), 1);
			if(!DiffRes) bsdf_value = 1;
			float3 Col =(CurrentRes.NEERay * CurrentRes.W * bsdf_value2);
			GlobalColors[id.x + id.y * screen_width].Direct = CurrentRes.RadianceDirect * CurrentRes.W * bsdf_value;
			GlobalColors[id.x + id.y * screen_width].Indirect = CurrentRes.RadianceIndirect * CurrentRes.W * bsdf_value;
			GlobalColors[id.x + id.y * screen_width].PrimaryNEERay = (UseAlteredPipeline) ? packRGBE(CurrentRes.NEERay * CurrentRes.W * max(hitmat.surfaceColor, 0.0000001f)) : packRGBE((all(CurrentRes.NEERay * CurrentRes.W * bsdf_value2 < 1000000) ? Col : 1));
			GlobalColors[id.x + id.y * screen_width].IsSpecular = (CurrentRes.ThisCase.x == 0 && MatModifier.Roughness < 0.18f) ? 1 : 0;
	}
	else {
		CurrentReservoirGI[index] = CurrentRes;
		// if(UseASVGF){
		// 	CurrentRes.BaseColor = packRGBE(1);
		// 	SpatialReservoirGI[index] = CurrentRes;
		// }
	}



}

#pragma kernel GIReTraceKernel


[numthreads(12, 12, 1)]
void GIReTraceKernel(uint3 id : SV_DispatchThreadID, uint3 id2 : SV_GroupThreadID, uint3 id3 : SV_GroupID, uint id4 : SV_GroupIndex) {

    if (id.x >= screen_width || id.y >= screen_height) return;
    const uint pixel_index = id.y * screen_width + id.x;

	float2 uv = float2((id.xy) / float2(screen_width, screen_height) * 2.0f - 1.0f);
    Ray ray = CreateCameraRay(uv, pixel_index);

    RandomNumsWrite[id.xy] = float4(curframe, pixel_index, 0, 0);
    if(curframe % ReSTIRGIUpdateRate == pixel_index % ReSTIRGIUpdateRate) {
		#ifdef HDRP
			float2 MotionVector = MotionVectors[int3(id.xy,0)].xy;
		#else
			float2 MotionVector = MotionVectors.SampleLevel(my_linear_clamp_sampler, (id.xy) / float2(screen_width, screen_height) , 0).xy;
		#endif
		uint2 prevIndex = int2(floor(((float2(id.xy) + 0.5) * float2(rcp(screen_width), rcp(screen_height)) - MotionVector) * float2(screen_width, screen_height)));
		if (prevIndex.x >= 0 && prevIndex.x < screen_width && prevIndex.y >= 0 && prevIndex.y < screen_height) {
	    	RandomNumsWrite[id.xy] = float4(CurrentReservoirGI[prevIndex.x + prevIndex.y * screen_width].HistoricFrame, CurrentReservoirGI[prevIndex.x + prevIndex.y * screen_width].HistoricID, 1, 1);
	    }
    }
    Rays[pixel_index].origin = ray.origin;
    Rays[pixel_index].direction = ray.direction;


}