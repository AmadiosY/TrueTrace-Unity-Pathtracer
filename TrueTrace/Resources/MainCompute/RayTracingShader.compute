#include "../GlobalDefines.cginc"
#ifndef DX11
    #pragma use_dxc
#endif
#include "CommonData.cginc"
#include "Materials.cginc"

// #define EnableRayDebug

static const bool DoVolumetrics = true;

#ifdef HDRP
Texture2DArray<float2> MotionVectors;
Texture2DArray<float3> NormalTex;
Texture2DArray<float> Depth;
#else
Texture2D<float2> MotionVectors;
Texture2D<float3> NormalTex;
Texture2D<float> Depth;
#endif


#pragma kernel kernel_shade

#ifdef EnableRayDebug
    RWStructuredBuffer<float3> DebugTraces;
#endif

TextureCube<float4> _SkyboxTexture;
SamplerState sampler_SkyboxTexture;

int BackgroundType;
float3 BackgroundColor;
float BackgroundIntensity;
bool ImprovedPrimaryHit;

//These are here purely for the Atrous
#ifdef HardwareRT
    #include "UnityRayQuery.cginc"
    #pragma require inlineraytracing
    RaytracingAccelerationStructure myAccelerationStructure;
#endif
bool VisabilityCheck(Ray ray, float dist) {
    #ifdef HardwareRT
        const uint rayFlags = RAY_FLAG_FORCE_OPAQUE  ;
        UnityRayQuery<rayFlags> q;
        RayDesc myRay;
        myRay.Origin = ray.origin;
        myRay.Direction = ray.direction;
        myRay.TMin = 0;
        myRay.TMax = dist;
        q.TraceRayInline(myAccelerationStructure, rayFlags, 0xff, myRay);
        while(q.Proceed()){}

        if(q.CommittedStatus() == COMMITTED_TRIANGLE_HIT) return false;
        else return true;
    #else
    return VisabilityCheckCompute(ray, dist);
    #endif
}

float2 sample_disc(float u1, float u2) {
    float a = 2.0f * u1 - 1.0f;
    float b = 2.0f * u2 - 1.0f;
    if (a == 0.0f) a = 0.00001;
    if (b == 0.0f) b = 0.00001;

    float phi, r;
    if (a * a > b * b) {
        r = a;
        phi = (0.25f * PI) * (b / a);
    }
    else {
        r = b;
        phi = (0.25f * PI) * (a / b) + (0.5f * PI);
    }

    float sin_phi, cos_phi;
    sincos(phi, sin_phi, cos_phi);

    return float2(r * cos_phi, r * sin_phi);
}

float3 sample_cosine_weighted_direction(float u1, float u2) {
    float2 d = sample_disc(u1, u2);
    return float3(d.x, d.y, sqrt(abs(1.0f - dot(d, d))));
}

float3 sample(inout float pdf, uint pixel_index) {//Diffuse
    float2 rando = random(5, pixel_index);
    float3 omega_o = sample_cosine_weighted_direction(rando.x, rando.y);
    pdf = omega_o.z * ONE_OVER_PI;
    return omega_o;
}

float3x3 GetTangentSpace(float3 normal) {
    // Choose a helper floattor for the cross product
    float3 helper = float3(1, 0, 0);
    if (abs(normal.x) > 0.99f)
        helper = float3(0, 0, 1);

    // Generate floattors
    float3 tangent = normalize(cross(normal, helper));
    float3 binormal = cross(normal, tangent);

    return float3x3(tangent, binormal, normal);
}



inline float3 local_to_world(const float3 Dir, const float3 tangent, const float3 binormal, const float3 normal) {
    return float3(
        tangent.x * Dir.x + binormal.x * Dir.y + normal.x * Dir.z,
        tangent.y * Dir.x + binormal.y * Dir.y + normal.y * Dir.z,
        tangent.z * Dir.x + binormal.z * Dir.y + normal.z * Dir.z
        );
}

float3 sample_henyey_greenstein(const float3 omega, float g, float u1, float u2) {
    float cos_theta;
    if (abs(g) < 0.01f) {
        // Isotropic case
        cos_theta = 1.0f - 2.0f * u1;
    }
    else {
        float sqr_term = (1.0f - g * g) / (1.0f + g - 2.0f * g * u1);
        cos_theta = -(1.0f + g * g - sqr_term * sqr_term) / (2.0f * g);
    }
    float sin_theta = sqrt(max(1.0f - cos_theta * cos_theta, 0.0f));

    float phi = (PI * 2.0f) * u2;
    float sin_phi, cos_phi;
    sincos(phi, sin_phi, cos_phi);

    float3 direction = float3(
        sin_theta * cos_phi,
        sin_theta * sin_phi,
        cos_theta
        );

    float3 v1, v2;
    orthonormal_basis(omega, v1, v2);

    return local_to_world(direction, v1, v2, omega);
}

bool VolumetricScatter(inout float3 throughput, RayHit hit, inout Ray ray, inout float3 Pos, MaterialData hitDat, uint pixel_index) {
    float3 SigmaS = hitDat.surfaceColor;
    float3 SigmaA = hitDat.transmittanceColor;

    bool medium_can_scatter = (SigmaS.x + SigmaS.y + SigmaS.z) > 0.0f;

    if (medium_can_scatter) {
        float2 rand_scatter = random(3, pixel_index);
        float2 rand_phase = random(5, pixel_index);

        float3 sigma_t = SigmaA + SigmaS;

        float throughput_sum = throughput.x + throughput.y + throughput.z;
        float3 wavelength_pdf = throughput / throughput_sum;

        float sigma_t_used_for_sampling;
        if (rand_scatter.x * throughput_sum < throughput.x) {
            sigma_t_used_for_sampling = sigma_t.x;
        }
        else if (rand_scatter.x * throughput_sum < throughput.x + throughput.y) {
            sigma_t_used_for_sampling = sigma_t.y;
        }
        else {
            sigma_t_used_for_sampling = sigma_t.z;
        }

        float scatter_distance = -log(rand_scatter.y) / sigma_t_used_for_sampling;
        float dist = min(scatter_distance, hit.t);// * (float)hitDat.Thin;
        dist *= pow(dist,12.0f);
        float3 transmittance = float3(
            exp(-sigma_t.x * dist),
            exp(-sigma_t.y * dist),
            exp(-sigma_t.z * dist)
            );

        if (scatter_distance < hit.t) {
            float3 pdf = wavelength_pdf * sigma_t * transmittance;
            throughput *= SigmaS * transmittance / (pdf.x + pdf.y + pdf.z);

            float3 direction_out = sample_henyey_greenstein(-ray.direction, hitDat.roughness, rand_phase.x, rand_phase.y);

            float3 ray_origin = ray.origin;
            ray.origin = ray_origin + scatter_distance * ray.direction;
            Pos = ray.origin;
            ray.direction = direction_out;
            return true;
        }
        else {
            float3 pdf = wavelength_pdf * transmittance;
            throughput *= transmittance / (pdf.x + pdf.y + pdf.z);
            return false;
        }
    }
    return false;
}





void sampleEquiAngular( float u, float maxDistance, float3 rOrigin, float3 rDirection, float3 lightPos, inout float dist, inout float pdf )
{
    // get coord of closest point to light along (infinite) ray
    float delta = clamp(dot(lightPos - rOrigin, rDirection), 0.0, 1.0);
    
    // get distance this point is from light
    float D = distance(rOrigin + delta * rDirection, lightPos);

    // get angle of endpoints
    float thetaA = atan((0.0 - delta) / D);
    float thetaB = atan((maxDistance - delta) / D);

    // take sample
    float t = D * tan( lerp(thetaA, thetaB, u) );
    dist = delta + t;
    pdf = D / ( (thetaB - thetaA) * (D * D + t * t) );
}









bool ChangedExposure;


int SelectUnityLight(int pixel_index, out float lightWeight, float3 Norm, float3 Position, float3 RayDir, MaterialData hitmat) {
    lightWeight = unitylightcount;
    if (unitylightcount == 1) return 0;
    float2 Rand = random(0, pixel_index);
    if(RISCount == 0)   return clamp(floor(Rand.y * unitylightcount), 0, unitylightcount - 1);
    int MinIndex = 0;
    float wsum = 0;
    int M = 0;
    float MinP_Hat = 0;
    for(int i = 0; i < RISCount; i++) {
        Rand = random(i + 23, pixel_index);
        int Index = clamp((Rand.x * unitylightcount), 0, unitylightcount - 1);
        LightData light = _UnityLights[Index];
        float3 Pos = light.Type == 1 ? (light.Direction * 120000.0f + Position) : light.Position;
        float3 to_light = Pos - Position;
        float LengthSquared = dot(to_light, to_light);
        to_light /= sqrt(LengthSquared);
        float3 bsdf_value;
        float bsdf_pdf;
        bool A = EvaluateBsdf(hitmat, RayDir, to_light, Norm, bsdf_pdf, bsdf_value, pixel_index);
        // bool A = evaldiffuse(to_light, dot(to_light, Norm), bsdf_value, bsdf_pdf);
        float p_hat = max(A * luminance(bsdf_value * light.Radiance) / ((light.Type == 1) ? 1 : LengthSquared) * ((light.Type == 2) ? saturate(saturate(dot(to_light, -light.Direction)) * light.SpotAngle.x + light.SpotAngle.y) : 1),0);
        wsum += p_hat;
        M++;
        if(Rand.y < p_hat / wsum) {
            MinIndex = Index;
            MinP_Hat = p_hat;
        }

    }
    if(MinP_Hat == 0) return clamp(floor(Rand.y * unitylightcount), 0, unitylightcount - 1);
    lightWeight = (wsum / max((M + 1) *MinP_Hat, 0.000001f)) * (float)unitylightcount;
    return MinIndex;
}

int2 StochasticBilinear(float2 st, float u) {
    #ifdef PointFiltering
        return st;
    #else
        int s = floor(st[0]), t = floor(st[1]);
        float ds = st[0] - floor(st[0]);
        float dt = st[1] - floor(st[1]);
        if (u < ds) {
        ++s;
        u /= ds;
        } else
        u = (u - ds) / (1 - ds);
        if (u < dt) {
        ++t;
        u /= dt;
        } else
        u = (u - dt) / (1 - dt);
        return float2(s, t);
    #endif
}

int NormalSize;
int EmissiveSize;

//can I improve RIS by pre-doing the transforms??
inline int SelectLight(uint pixel_index, uint MeshIndex, out float lightWeight, float3 Norm, float3 Position, const float3 RayDir, const MaterialData hitmat, const float4x4 Transform, inout float3 FinalPos, inout float2 FinalUV, inout float3 FinalNorm, inout float Finalarea) {//Need to check these to make sure they arnt simply doing uniform sampling

    float2 Rand = random(3, pixel_index);
    const int StartIndex = _LightMeshes[MeshIndex].StartIndex;
    const int IndexEnd = _LightMeshes[MeshIndex].IndexEnd;
    const int LightCount = IndexEnd - StartIndex;
    lightWeight = (LightCount);

    const int MeshTriOffset = _MeshData[_LightMeshes[MeshIndex].LockedMeshIndex].TriOffset;
    LightTriData Tri;
    Position = mul(Transform, float4(Position,1));
    Norm = normalize(mul(Transform, float4(Norm,0)).xyz);
    if(RISCount == 0) {
        int Index = clamp((Rand.x * LightCount) + StartIndex, StartIndex, IndexEnd - 1);
        Tri = LightTriangles[Index];
        FinalPos = sample_projected_triangle(Position, triangle_get_positions(Tri.TriTarget + MeshTriOffset), random(24, pixel_index), FinalNorm, Finalarea, FinalUV);    
        return Index;
    }
    const int MatOffset = _LightMeshes[MeshIndex].MatOffset;
    int MinIndex = 0;
    float wsum = 0;
    int M = 0;
    float MinP_Hat = 0;
    float3 bsdf_value;
    float bsdf_pdf;
    for(int i = 0; i < RISCount; i++) {
        Rand = random(i, pixel_index);
        int Index = clamp((Rand.x * LightCount) + StartIndex, StartIndex, IndexEnd - 1);
        Tri = LightTriangles[Index];
        float2 TriangleUV;
        float3 LightPosition;
        float3 LightNorm;
        float p_hat;
        LightPosition = sample_projected_triangle(Position, triangle_get_positions(Tri.TriTarget + MeshTriOffset), random(24 + i, pixel_index), LightNorm, p_hat, TriangleUV);    
        if(dot(normalize(LightPosition - Position), Norm) < 0) p_hat = 0;
        wsum += p_hat;
        M++;
        if(Rand.y < p_hat / wsum) {
            FinalPos = LightPosition;
            FinalNorm = LightNorm;
            FinalUV = TriangleUV;
            Finalarea = p_hat;
            MinIndex = Index;
            MinP_Hat = p_hat;
        }

    }
    lightWeight = (wsum / max((M + 1) *MinP_Hat, 0.000001f) * LightCount);
    return MinIndex;
}


void calcFinalColor(inout Ray ray, inout ColData Color, MaterialData hitDat, RayHit hit, uint2 Uv, float2 NormalUV, bool IsEmissiveTex, RayData RayDat, bool HitHeightmap, const uint pixel_index, int MaterialIndex, inout float4 AlbedoTexData) {//main function
    bool CB = !DoPartialRendering;
    if(!CB) {
        CB = curframe % PartialRenderingFactor == pixel_index % PartialRenderingFactor;
        if(UseASVGF || (UseReSTIRGI && ReSTIRGIUpdateRate != 0)) {
            if(RandomNums[Uv].w == 1) CB = true;
        }
    }
    float3 pos = ray.direction * hit.t + ray.origin;
    float3 PrevDirection = ray.direction;
    float3 PrevOrigin = ray.origin;
    float3 Geomnorm;
    float3 norm;
    float4x4 Inverse = inverse(_MeshData[hit.mesh_id].Transform);
    float pdf = 0.0f;
    bool validBSDFNEE = true;
    bool validBSDFSample;

    float3 throughput = Color.throughput;

    [branch] if (TerrainExists && HitHeightmap) {
        Geomnorm = GetHeightmapNormal(pos, hit.triangle_id);
    } else {
        Geomnorm = GetTriangleNormal(hit.triangle_id, float2(hit.u, hit.v), Inverse);
    }

    bool GotFlipped = dot(ray.direction, Geomnorm) >= 0.0f;
    if (GotFlipped) Geomnorm *= -1;//Backfacing surface

    norm = Geomnorm;
    [branch] if (CurBounce == 0 && NormalUV.x != -1) {//Handle Normal Maps
        float3 LocalTan = GetTriangleTangent(hit.triangle_id, float2(hit.u, hit.v), Inverse);
        float3 LocalBinorm = normalize(cross(Geomnorm, LocalTan));
        float2 Norm = _NormalAtlas[NormalUV * NormalSize];

        float3 LocalNormIN = float3((2.0f * Norm - 1.0f), 0.0f);
        LocalNormIN.z = 1.0 - 0.5 * dot(LocalNormIN, LocalNormIN);
        norm = normalize(mul(normalize(LocalNormIN), float3x3(LocalTan, LocalBinorm, Geomnorm)).xyz);
        norm = clamp(norm, -1, 1);
        if (abs(norm.x) == abs(norm.y) == abs(norm.z)) norm = Geomnorm;
    }

    [branch] if (hitDat.emmissive > 0.0f) {//if we hit a light, this ray is done
        float w = 1;
        if (!UseNEE || hitDat.MatType == VideoIndex) {
            if (CurBounce == 0) Color.Direct += hitDat.emmissive;
            else if(CurBounce == 1) Color.Direct += hitDat.emmissive * hitDat.surfaceColor;
            else Color.Indirect += Color.throughput * hitDat.emmissive * hitDat.surfaceColor;
        } else {
            float3 a0 = AggTris[hit.triangle_id].pos0;
            float3 a1 = a0 + AggTris[hit.triangle_id].posedge1;
            float3 a2 = a0 + AggTris[hit.triangle_id].posedge2;
            float light_pdf = 1.0f / (LightMeshCount * rcp(get_spherical_triangle_pdfw(a0, a1, a2, mul(_MeshData[hit.mesh_id].Transform, float4(PrevOrigin,1))))) * rcp(_MeshData[hit.mesh_id].LightTriCount);
            w = power_heuristic(max(RayDat.last_pdf,0), light_pdf);
            if (CurBounce == 0) Color.Direct = hitDat.emmissive;
            else if (CurBounce == 1) Color.Direct += (hitDat.surfaceColor * hitDat.emmissive) * w;
            else Color.Indirect += Color.throughput * hitDat.surfaceColor * hitDat.emmissive * w;
        }
        NEEPosA[Uv.xy] += float4(0,0,0,luminance(hitDat.surfaceColor * hitDat.emmissive)); 
        if(CurBounce == 1) WorldPosA[Uv] = uint4(UseReSTIRGI ? asuint(pos) : asuint(PrevDirection), WorldPosA[Uv].w);
        if(CurBounce == 0) AlbedoTexData = float4(hitDat.surfaceColor, 0);
        return;
    }

    int MaterialLobe = 2;
    BsdfSample Thissample = initbsdf();
    bool Refracted = false;
    [branch] if(CurBounce == 0 && UseReSTIRGI && ReSTIRGIUpdateRate != 0 && RandomNums[Uv].z == 1) {
        float3 bsdf_value;
        #ifdef HDRP
            float2 MotionVector = MotionVectors[int3(Uv,0)].xy;
        #else
            float2 MotionVector = MotionVectors.SampleLevel(my_linear_clamp_sampler, (Uv) / float2(screen_width, screen_height) , 0).xy;
        #endif
        uint2 prevIndexDoub = int2(floor(((float2(Uv) + 0.5) * float2(rcp(screen_width), rcp(screen_height)) - MotionVector) * float2(screen_width, screen_height)));
        hitDat.surfaceColor = unpackRGBE(WorldPosB[prevIndexDoub].w);
        ray.direction = normalize(asfloat(WorldPosB[prevIndexDoub].xyz) - (pos + Geomnorm * NormalOffset));
        validBSDFSample = ReconstructBsdf(hitDat, PrevDirection, ray.direction, norm, pdf, bsdf_value, GetTangentSpace2(norm), pixel_index);
        throughput *= max(bsdf_value, 0.000001f);
    } else {
        [branch] switch (hitDat.MatType) {//Switch between different materials
            case CutoutIndex://mask material
            case DisneyIndex://Disney BSDF
                validBSDFSample = SampleDisney(hitDat, -ray.direction, hitDat.Thin, Thissample, GetTangentSpace2(norm), MaterialLobe, pixel_index, Refracted);
                ray.direction = Thissample.wi;
                pdf = Thissample.forwardPdfW;
                throughput *= max(Thissample.reflectance, 0.000001f);

                if (CurBounce == 0) {
                    if (MaterialLobe == 0 || MaterialLobe == 3) {
                        Color.IsSpecular = (hitDat.roughness < 0.01f) ? 0 : 1;
                    }
                    
                    uint ABPacked = ((uint)(hitDat.metallic * 0xFFFF) << 16) | ((uint)(hitDat.roughness * 0xFFFF) & 0xFFFF);
                    Color.pad = asfloat(ABPacked);
                    
                    if (MaterialLobe == 3) {
                        Color.IsSpecular = 2;
                        uint B = (Refracted) ? (0.5f * 0xFFFF) : (0.39f * 0xFFFF);
                        if(Refracted) {
                            B = 0.5f * 0xFFFF;
                        } else Color.IsSpecular = 3;
                        uint ABPacked = (1 * 0xFFFF << 16) | (B & 0xFFFF);
                        Color.pad = asfloat(ABPacked);
                    }
                }

                if (Refracted) {
                    Geomnorm *= -1;
                    norm *= -1;
                } 
                else if (AlbedoTexData.w <= 0 && MaterialLobe == 3) {
                    Color.IsSpecular = 3;
                    uint ABPacked = ((uint)(1 * 0xFFFF) << 16) | ((uint)(0.1f * 0xFFFF) & 0xFFFF);
                    Color.pad = asfloat(ABPacked);
                }
            break;
            case VolumetricIndex://"Volumetric" material
                if(random(54, pixel_index).x > hitDat.diffTrans || GotFlipped) {
                    if (!GotFlipped) {
                        norm = -norm;
                        Geomnorm = -Geomnorm;
                        ray.direction = lerp(ray.direction, normalize(mul(sample(pdf, pixel_index), GetTangentSpace(norm))), hitDat.flatness);
                        throughput *= hitDat.surfaceColor;
                    } else if((GotFlipped && VolumetricScatter(throughput, hit, ray, pos, hitDat, pixel_index))) {
                        norm = -norm;
                        Geomnorm = -Geomnorm;
                    }
                    validBSDFSample = true;
                } else {
                    ray.direction = normalize(mul(sample(pdf, pixel_index), GetTangentSpace(norm)));
                    throughput *= hitDat.surfaceColor;
                     validBSDFSample = pdf > 0;
                     hitDat.MatType == 0;
                }
            break;
            default:
                ray.direction = normalize(mul(sample(pdf, pixel_index), GetTangentSpace(norm)));
                validBSDFSample = pdf > 0;
                throughput *= hitDat.surfaceColor;
            break;
        }
    }

    ray.origin = Geomnorm * NormalOffset + pos;//Offset the ray origin so we dont self intersect with the triangle we just bounced off of
    if(AlbedoTexData.w == CurBounce) {
        WorldPosA[Uv] = uint4(UseReSTIRGI ? asuint(pos) : asuint(PrevDirection), WorldPosA[Uv].w);
    }
    [branch] if (CurBounce == 0 || AlbedoTexData.w == -1) {//Setting textures for denosier to use
        bool PSRActiveGlass = CurBounce == 0;
        WorldPosA[Uv] = uint4(WorldPosA[Uv].xyz,packRGBE(PSRActiveGlass ? max(hitDat.surfaceColor, 0.005f) : (unpackRGBE(WorldPosA[Uv].w) * max(hitDat.surfaceColor, 0.005f))));
        ScreenSpaceInfo[Uv] = float4(asfloat(octahedral_32(Geomnorm)), asfloat(octahedral_32(norm)),(CurBounce == 0) ? hit.t : (ScreenSpaceInfo[Uv].z + hit.t), MaterialIndex); 

        AlbedoTexData = float4(((CurBounce == 0) ? max(throughput, 0.005f) : (max(throughput, 0.005f) * AlbedoTexData.xyz)), (MaterialLobe == 3 || (!UseReSTIRGI && MaterialLobe == 0 && hitDat.roughness < 0.01f && hitDat.metallic == 1 && CurBounce == 0)) ? -1 : (CurBounce + 1));  
        throughput = 1;  
    }   


    [branch] if ((UseNEE) && CurBounce < MaxBounce && hitDat.MatType != VolumetricIndex && unitylightcount + LightMeshCount != 0 && CB) {//Next event estimation
        int triindex;
        int MeshIndex = 0;
        float3 LightNorm;
        float2 TriangleUV;
        float3 LightPosition;
        float bsdf_pdf = 0.0f;
        float LightWeight = 1;
        float3 bsdf_value = 0.0f;
        float LightAttenuation = 1.0f;
        bool IsFullStrength = true;
        bool IsDirectional = false;
        bool RequiresRadialFalloff = false;
        float SelectionWeight = 1;
        float area = 0;

        bool UseUnityLight = false;
        if(unitylightcount != 0) {
            if(LightMeshCount != 0) {
                SelectionWeight = 2;
                UseUnityLight = random(11, pixel_index).x <= 0.5f;
            } else UseUnityLight = true;
        };

        int AggTriIndex = 0;
        if (UseUnityLight) {
            triindex = SelectUnityLight(pixel_index, LightWeight, norm, pos, PrevDirection, hitDat);
            LightData Light = _UnityLights[triindex];
            [branch] switch (Light.Type) {
                default://Point light
                    LightPosition = Light.Position;
                    LightNorm = normalize(ray.origin - LightPosition);
                break;
                case 1://Sun/Directional light
                    LightPosition = ray.origin + Light.Direction;
                    LightNorm = -Light.Direction;
                    IsFullStrength = (LightNorm.y <= 0.0f);
                    IsDirectional = true;
                    LightPosition += (float3(random(23, pixel_index), random(62, pixel_index).x) - 0.5f) * _UnityLights[triindex].SpotAngle.x * 0.01f;//Soft Shadows
                break;
                case 2://Spot light
                    LightPosition = Light.Position;
                    LightNorm = Light.Direction;
                    IsFullStrength = false;
                    RequiresRadialFalloff = true;
                    LightPosition += (float3(random(23, pixel_index), random(62, pixel_index).x) - 0.5f) * 0.1f;//Soft Shadows
                break;
                case 3://Area light
                    RequiresRadialFalloff = true;
                    float3 randVector = (float3(random(43, pixel_index).x * Light.SpotAngle.x, random(43, pixel_index).y * Light.SpotAngle.y, 0)) - float3(Light.SpotAngle.x, Light.SpotAngle.y, 0) / 2;
                    float3 oldRand = randVector;
                    Light.ZAxisRotation *= PI / 180.0f;
                    randVector = float3(oldRand.x * cos(Light.ZAxisRotation) - oldRand.y * sin(Light.ZAxisRotation), oldRand.y * cos(Light.ZAxisRotation) + oldRand.x * sin(Light.ZAxisRotation), 0);
                    float3 tangent0 = cross(Light.Direction, float3(0, 1, 0));
                    if (dot(tangent0, tangent0) < 0.001f) tangent0 = cross(Light.Direction, float3(1, 0, 0));
                    tangent0 = normalize(tangent0);
                    float3 tangent1 = normalize(cross(Light.Direction, tangent0));
                    float3x3 rotationmatrix = { tangent0, tangent1, Light.Direction };
                    float3 Length = length(randVector);
                    LightPosition = Light.Position + mul(normalize(randVector), rotationmatrix) * Length;
                    LightNorm = Light.Direction;
                break;
            }
        } else {
            MeshIndex = SelectLightMesh(pixel_index);
            float4x4 MeshTransformInverse = _MeshData[_LightMeshes[MeshIndex].LockedMeshIndex].Transform;
            triindex = SelectLight(pixel_index, MeshIndex, LightWeight, norm, pos, PrevDirection, hitDat, MeshTransformInverse, LightPosition, TriangleUV, LightNorm, area);
            AggTriIndex = LightTriangles[triindex].TriTarget + _MeshData[_LightMeshes[MeshIndex].LockedMeshIndex].TriOffset;
            MeshTransformInverse = inverse(MeshTransformInverse);
            LightPosition = mul(MeshTransformInverse, float4(LightPosition,1));
            LightNorm = normalize(mul((float3x3)MeshTransformInverse, LightNorm).xyz);
        }
        LightWeight *= SelectionWeight;
        float3 to_light = LightPosition - ray.origin;

        float distance_to_light_squared = dot(to_light, to_light);
        float distance_to_light = sqrt(max(distance_to_light_squared, 0.0f));

        to_light = to_light / distance_to_light;
        
        if(RequiresRadialFalloff) LightAttenuation = saturate(dot(to_light, -LightNorm));
        if (!IsDirectional && !IsFullStrength) LightAttenuation = saturate(LightAttenuation * _UnityLights[triindex].SpotAngle.x + _UnityLights[triindex].SpotAngle.y);

        bool validbsdfNEE = EvaluateBsdf(hitDat, PrevDirection, to_light, norm, bsdf_pdf, bsdf_value, pixel_index);

        float SurfaceCos = dot(to_light, norm);//YES KEEP THIS, IT NOT ONLY IMPROVES PERFORMANCE BUT IT ALSO HELPS KEEPS THINGS LESS BIASED AS OTHERWISE THE NORMAL OFFSET CAN RESULT IN WRONG VISABILITY!
        if (SurfaceCos > 0 && validbsdfNEE) {
            float LightCos = abs(dot(to_light, LightNorm));
            float3 Radiance;
            float NEE_pdf;
            float3 Illum;
            if (UseUnityLight) {
                float3 transmittance = 1;
                #ifndef DX11
                    if (IsDirectional) float3 Radiance = GetSkyRadiance(ray.origin, to_light, 0, SunDir, transmittance);
                #endif
                Radiance = _UnityLights[triindex].Radiance * transmittance;
                NEE_pdf = distance_to_light_squared * LightCos;
                Illum = Color.throughput * (Radiance * bsdf_value) / NEE_pdf * LightAttenuation * LightWeight;
            } else {        
                NEE_pdf = (1.0f / (LightMeshCount * area)) / LightWeight;//Putting the lightweight up here makes it biased
                int MaterialIndex = AggTris[AggTriIndex].MatDat + _MeshData[_LightMeshes[MeshIndex].LockedMeshIndex].MaterialOffset;
                Radiance = _Materials[MaterialIndex].emmissive *  _Materials[MaterialIndex].surfaceColor;
                if (_Materials[MaterialIndex].MatType == VideoIndex || (_Materials[MaterialIndex].EmissiveTex.x > 0 && _Materials[MaterialIndex].emmissive >= 0)) {
                    float2 BaseUv = AggTris[AggTriIndex].tex0 * (1.0f - TriangleUV.x - TriangleUV.y) + AggTris[AggTriIndex].texedge1 * TriangleUV.x + AggTris[AggTriIndex].texedge2 * TriangleUV.y;
                    if (_Materials[MaterialIndex].MatType == VideoIndex) {
                        Radiance *= VideoTex.SampleLevel(sampler_VideoTex, BaseUv, 0).xyz;
                    } else {
                        float2 EmissionUV = AlignUV(BaseUv, _Materials[MaterialIndex].AlbedoTexScale, _Materials[MaterialIndex].EmissiveTex);   
                        float4 EmissTex = _EmissiveAtlas.SampleLevel(my_point_clamp_sampler, EmissionUV, 0);
                        float3 EmissCol = _Materials[MaterialIndex].EmissionColor;
                        bool IsMask = !all(EmissCol == 0);
                        if (!IsMask) EmissCol = EmissTex.xyz * EmissTex.w;
                        else EmissCol *= EmissTex.xyz * EmissTex.w;
                        if (dot(EmissCol, EmissCol) > 0.001f) {
                            Radiance = EmissCol * _Materials[MaterialIndex].emmissive;
                        } else Radiance = 0;
                    }
                }
                float NEEMISWeight = power_heuristic(NEE_pdf, bsdf_pdf);
                Illum = Color.throughput * (Radiance * bsdf_value) / NEE_pdf * LightAttenuation * NEEMISWeight;
            }
            if (CurBounce == 0) NEEPosA[Uv] = float4((IsDirectional) ? (ray.origin + to_light * 100.0f) : LightPosition,NEEPosA[Uv].w);

            float ExposureCalc = 1;
            if(DoExposure) ExposureCalc = Exposure[0];
            float maxillum = max(max(Illum.x, Illum.y), Illum.z) * ExposureCalc;
            if(!UseRussianRoulette) maxillum = 1;
            Illum *= rcp(saturate(maxillum));
            if(maxillum > random(27, pixel_index).y) {//NEE russian roulette, massively improves performance while giivng the same result
                uint index3;
                if(UseReSTIRGI && CurBounce == 0) Illum *= (bsdf_value == 0) ? 1 : rcp(bsdf_value);                    

                InterlockedAdd(BufferSizes[CurBounce].shadow_rays, 1, index3);
                ShadowRaysBuffer[index3].origin = ray.origin;
                ShadowRaysBuffer[index3].direction = to_light;
                ShadowRaysBuffer[index3].t = (IsDirectional ? 10000.0f : distance_to_light - 0.01f) * ((CurBounce != 0) ? 1 : -1);
                ShadowRaysBuffer[index3].illumination = Illum;
                ShadowRaysBuffer[index3].PixelIndex = pixel_index;
                ShadowRaysBuffer[index3].LuminanceIncomming = luminance(Radiance);
            }
        }
    }

    if (!validBSDFSample) return;//If the ray failed, we have no choice but to terminate this path

    if (CurBounce > 0 && UseRussianRoulette && AlbedoTexData.w != -1) {
        float3 AdjustedCol = throughput * (ImprovedPrimaryHit ? 1.0f : AlbedoTexData.xyz);
        float p = saturate(max(AdjustedCol.x, max(AdjustedCol.y, AdjustedCol.z)));
        if (random(2, pixel_index).x > p)//Simple Russian Roulette
            return;
        throughput *= rcp(p);//rcp is a slightly faster but less accurate version of 1 / p, I decided the inaccuracy was worth the performance bump
    }
    // if (any(throughput > 10000.0f)) return;
    Color.throughput = throughput;

    if(CB) {
        uint index2;//Congrats, the ray will continue its path
        InterlockedAdd(BufferSizes[CurBounce + 1].tracerays, 1, index2);
        GlobalRays[index2].origin = ray.origin;
        GlobalRays[index2].direction = ray.direction;
        GlobalRays[index2].PixelIndex = Uv.x + Uv.y * screen_width;
        GlobalRays[index2].last_pdf = pdf;
        set(index2, hit);
    }
}

Texture2D<float4> TerrainAlphaMap;
SamplerState sampler_TerrainAlphaMap;
int MaterialCount;


[numthreads(64, 1, 1)]
void kernel_shade(uint3 id : SV_DispatchThreadID) {

    if (id.x >= BufferSizes[CurBounce].tracerays) return;
    uint pixel_index = GlobalRays[id.x].PixelIndex;
    uint2 TempUv = uint2(pixel_index % screen_width, pixel_index / screen_width);
    float4 AlbedoTexData = TempAlbedoTex[TempUv];
    Ray ray;
    RayData GlobRay = GlobalRays[id.x];
    RayHit bestHit = get(id.x);
    ray.origin = GlobRay.origin;
    ray.direction = GlobRay.direction;
    ray.direction_inv = float3(0.0f, 0.0f, 0.0f);//We dont need to calculate this, but we do need to give it some value or Unity complains

    #ifdef HardwareRT
        if(bestHit.mesh_id != 9999999) {
            int2 Indexes = Unpack1To2(bestHit.mesh_id);
            int triangleOffset = SubMeshOffsets[MeshOffsets[Indexes.y].x + Indexes.x];
            bestHit.triangle_id += triangleOffset;
            bestHit.mesh_id = MeshOffsets[Indexes.y].y;
        }
    #endif
    ColData Color = GlobalColors[pixel_index];
    if (bestHit.t == FarPlane) {//if ray goes into the void, sample skybox
        float3 Sun, SkyBoxCol, Radiance, transmittance, Direct = 0;
        [branch]switch(BackgroundType) {
            case 0:
                Direct = 1;
                transmittance = 0;
                Sun = 0;
                Radiance = GetSkyRadiance(ray.origin, ray.direction, 0, SunDir, transmittance);// * normalize(float3(114975.3,71305.86,65311.04));
                Radiance = saturate(pow((1 - exp(-Radiance * 15.0f)),1.0f));
                SkyBoxCol = saturate(Radiance);// * Direct + trans2;
                if(AlbedoTexData.w <= 0) SkyBoxCol += saturate(luminance(transmittance)) * StarRender(ray.direction);
                if (dot(ray.direction, SunDir) > cos(0.0235f / 2.0f)) Sun = clamp((Radiance + transmittance * (1.5f / (PI * (0.0235f / 2.0f) * (0.0235f / 2.0f)))) / 100.0f, 0, 10.0f);

                if (all(SkyBoxCol > 0 || SkyBoxCol < 0 || SkyBoxCol == 0)) {
                    if (CurBounce <= 1) {//Seperated into direct and indirect channels
                        Color.Direct = Color.throughput * ((SkyBoxCol)+Sun);
                    } else {
                        Color.Indirect += Color.throughput * (SkyBoxCol)+Sun;
                    }
                }
            break;
            case 1:
                if (CurBounce == 0) Color.Direct = _SkyboxTexture.SampleLevel(sampler_SkyboxTexture, ray.direction, 0).xyz;
                else if (CurBounce == 1) Color.Direct += _SkyboxTexture.SampleLevel(sampler_SkyboxTexture, ray.direction, 4).xyz * BackgroundIntensity;
                else Color.Indirect += Color.throughput * _SkyboxTexture.SampleLevel(sampler_SkyboxTexture, ray.direction, CurBounce + 4).xyz * BackgroundIntensity;
            break;
            case 2:
                if (CurBounce == 0) Color.Direct = BackgroundColor;
                else if (CurBounce == 1) Color.Direct += BackgroundColor * BackgroundIntensity;
                else Color.Indirect += Color.throughput * BackgroundColor * BackgroundIntensity;
            break;
        }
        if(CurBounce == 1) WorldPosA[TempUv] = uint4(UseReSTIRGI ? asuint(ray.origin + ray.direction * 12.0f) : asuint(ray.direction), WorldPosA[TempUv].w);
        if (CurBounce == 0) TempAlbedoTex[TempUv] = float4(Color.Direct,0);
        GlobalColors[pixel_index] = Color;
        return;
    }


    float2 BaseUv;
    int MaterialIndex;
    bool HitTerrain = false;
    MaterialData TempMat;
    if (TerrainExists && (bestHit.mesh_id == 9999999)) {//if hit terrain
        BaseUv = float2(bestHit.u, bestHit.v);
        float4 Mats = TerrainAlphaMap.SampleLevel(sampler_TerrainAlphaMap, BaseUv * (Terrains[bestHit.triangle_id].AlphaMap.xy - Terrains[bestHit.triangle_id].AlphaMap.zw) + Terrains[bestHit.triangle_id].AlphaMap.zw, 0);
        int x = 0;
        float minmat = Mats.x;
        if(minmat < Mats.y) {
            minmat = Mats.y;
            x = 1;
        }
        if(minmat < Mats.z) {
            minmat = Mats.z;
            x = 2;
        }
        if(minmat < Mats.a) {
            minmat = Mats.a;
            x = 3;
        }

        minmat = 0;
        float3 BaseCol = 0;
        MaterialIndex = MaterialCount + Terrains[bestHit.triangle_id].MatOffset;
        if(Mats.x > 0.001f) BaseCol += _TextureAtlas.SampleLevel(my_point_clamp_sampler,  AlignUV(BaseUv * _Materials[MaterialIndex].surfaceColor.xy + _Materials[MaterialIndex].transmittanceColor.xy, _Materials[MaterialIndex].AlbedoTexScale, _Materials[MaterialIndex].AlbedoTex), 0).xyz * Mats.x;
        if(Mats.y > 0.001f) BaseCol += _TextureAtlas.SampleLevel(my_point_clamp_sampler,  AlignUV(BaseUv * _Materials[MaterialIndex + 1].surfaceColor.xy + _Materials[MaterialIndex + 1].transmittanceColor.xy, _Materials[MaterialIndex + 1].AlbedoTexScale, _Materials[MaterialIndex + 1].AlbedoTex), 0).xyz * Mats.y;
        if(Mats.z > 0.001f) BaseCol += _TextureAtlas.SampleLevel(my_point_clamp_sampler,  AlignUV(BaseUv * _Materials[MaterialIndex + 2].surfaceColor.xy + _Materials[MaterialIndex + 2].transmittanceColor.xy, _Materials[MaterialIndex + 2].AlbedoTexScale, _Materials[MaterialIndex + 2].AlbedoTex), 0).xyz * Mats.z;
        if(Mats.w > 0.001f) BaseCol += _TextureAtlas.SampleLevel(my_point_clamp_sampler,  AlignUV(BaseUv * _Materials[MaterialIndex + 3].surfaceColor.xy + _Materials[MaterialIndex + 3].transmittanceColor.xy, _Materials[MaterialIndex + 3].AlbedoTexScale, _Materials[MaterialIndex + 3].AlbedoTex), 0).xyz * Mats.w;
        MaterialIndex += x;
        TempMat = _Materials[MaterialIndex];
        BaseUv = BaseUv * TempMat.surfaceColor.xy + TempMat.transmittanceColor.xy;
        TempMat.surfaceColor = BaseCol;
        HitTerrain = true;
    } else {
        BaseUv = AggTris[bestHit.triangle_id].tex0 * (1.0f - bestHit.u - bestHit.v) + AggTris[bestHit.triangle_id].texedge1 * bestHit.u + AggTris[bestHit.triangle_id].texedge2 * bestHit.v;
        MaterialIndex = _MeshData[bestHit.mesh_id].MaterialOffset + AggTris[bestHit.triangle_id].MatDat;
        TempMat = _Materials[MaterialIndex];
    }


    float2 AlbedoUv = AlignUV(BaseUv, TempMat.AlbedoTexScale, TempMat.AlbedoTex);
    float2 NormalUV = AlignUV(BaseUv, TempMat.AlbedoTexScale, TempMat.NormalTex);
    if(TempMat.MatType == VideoIndex) {
        TempMat.surfaceColor = VideoTex.SampleLevel(sampler_VideoTex, BaseUv, 0).xyz;
    } else if(AlbedoUv.x != -1 && !HitTerrain) {
        TempMat.surfaceColor *= _TextureAtlas[StochasticBilinear(AlbedoUv * AlbedoAtlasSize, random(54, pixel_index).x)].xyz;
    }
    TempMat.roughness = max(TempMat.roughness, 0.00001f);
    float2 MetallicUV = AlignUV(BaseUv, TempMat.AlbedoTexScale, TempMat.MetallicTex);
    float2 RoughnessUV = AlignUV(BaseUv, TempMat.AlbedoTexScale, TempMat.RoughnessTex);
    if (TempMat.specTrans != 1 && MetallicUV.x > 0) TempMat.metallic = MetallicTex.SampleLevel(my_point_clamp_sampler, StochasticBilinear(MetallicUV * AtlasSize, random(54, pixel_index).x) / AtlasSize, max(CurBounce, 0));
    if (RoughnessUV.x > 0) TempMat.roughness = saturate(RoughnessTex.SampleLevel(my_point_clamp_sampler, StochasticBilinear(RoughnessUV * AtlasSize, random(54, pixel_index).x) / AtlasSize, max(CurBounce, 0)));
    if(TempMat.IsSmoothness) TempMat.roughness = 1.0f - TempMat.roughness;
    if(AlbedoTexData.w != -1) TempMat.roughness = min(TempMat.roughness + max(CurBounce / (float)MaxBounce,0),1);
    bool IsEmissiveTex = false;
    if(TempMat.emmissive >= 0) {
        float2 EmissionUV = AlignUV(BaseUv, TempMat.AlbedoTexScale, TempMat.EmissiveTex);        
        if (EmissionUV.x != -1) {
            float3 EmissCol = _Materials[MaterialIndex].EmissionColor;
            float4 EmissTexture = _EmissiveAtlas[StochasticBilinear(EmissionUV * EmissiveSize, random(54, pixel_index).x)];
            bool IsMask = !all(EmissCol == 0);
            if (!IsMask) EmissCol = EmissTexture.xyz * EmissTexture.w;
            else EmissCol *= EmissTexture.xyz * EmissTexture.w;
            if (dot(EmissCol, EmissCol) > 0.001f) {
                IsEmissiveTex = true;
                TempMat.surfaceColor = EmissCol;
            } else TempMat.emmissive = 0;
        } else if(any(_Materials[MaterialIndex].EmissionColor != 0)) {
            TempMat.surfaceColor += _Materials[MaterialIndex].EmissionColor * TempMat.surfaceColor;
        }
    }

    float PrevAlbedoTex = AlbedoTexData.x;
    calcFinalColor(ray, Color, TempMat, bestHit, TempUv, NormalUV, IsEmissiveTex || (TempMat.MatType == VideoIndex), GlobRay, bestHit.mesh_id == 9999999, pixel_index, MaterialIndex, AlbedoTexData);
    TempAlbedoTex[TempUv] = AlbedoTexData;
    GlobalColors[pixel_index] = Color;
}



#pragma kernel kernel_finalize


float IndirectBoost;

#ifdef HDRP
    Texture2DArray<float4> DiffuseGBuffer;
    Texture2DArray<float4> SpecularGBuffer;
#else
    Texture2D<float4> DiffuseGBuffer;
    Texture2D<float4> SpecularGBuffer;
#endif


Texture2D<float> Curr;
[numthreads(16, 16, 1)]
void kernel_finalize(uint3 id : SV_DispatchThreadID) {//Moved final accumulation into its own kernel, improves performance

    if (id.x >= screen_width || id.y >= screen_height) return;
    int final_pixel_index = id.y * screen_width + id.x;

    if (UseReSTIRGI) PrevDepthTex[id.xy] = ScreenSpaceInfo[id.xy].z;

    float3 GBufferCol = 1;
    if(DiffRes) {
        float2 UV = id.xy / float2(screen_width, screen_height);
        #ifdef HDRP
            float3 SpecularAlbedo = 0;
            GBufferCol = ((DiffuseGBuffer.SampleLevel(my_linear_clamp_sampler, float3(UV, 0), 0).xyz + SpecularAlbedo) == 0) ? 1 : (DiffuseGBuffer.SampleLevel(my_linear_clamp_sampler, float3(UV, 0), 0).xyz + SpecularAlbedo);
        #else
            float3 SpecularAlbedo = SpecularGBuffer.SampleLevel(my_linear_clamp_sampler, UV, 0);
            GBufferCol = ((DiffuseGBuffer.SampleLevel(my_linear_clamp_sampler, UV, 0).xyz + SpecularAlbedo) == 0) ? 1 : ((DiffuseGBuffer.SampleLevel(my_linear_clamp_sampler, UV, 0).xyz + SpecularAlbedo));
        #endif
    }
    float3 res = (TempAlbedoTex[id.xy].w == 0) ? TempAlbedoTex[id.xy].xyz : (((GlobalColors[final_pixel_index].Direct + GlobalColors[final_pixel_index].Indirect * IndirectBoost) * TempAlbedoTex[id.xy].xyz + unpackRGBE(GlobalColors[final_pixel_index].PrimaryNEERay)) / GBufferCol);
    if (!all(res < 100000)) res = 0;
    Result[id.xy] = float4(res, 1.0f);
}









#pragma kernel GIReTraceKernel


[numthreads(12, 12, 1)]
void GIReTraceKernel(uint3 id : SV_DispatchThreadID, uint3 id2 : SV_GroupThreadID, uint3 id3 : SV_GroupID, uint id4 : SV_GroupIndex) {

    if (id.x >= screen_width || id.y >= screen_height) return;
    const uint pixel_index = id.y * screen_width + id.x;

    float2 uv = float2((id.xy) / float2(screen_width, screen_height) * 2.0f - 1.0f);
    Ray ray = CreateCameraRay(uv, pixel_index);

    RandomNumsWrite[id.xy] = float4(curframe, pixel_index, 0, 0);
    if(curframe % ReSTIRGIUpdateRate == pixel_index % ReSTIRGIUpdateRate) {
        #ifdef HDRP
            float2 MotionVector = MotionVectors[int3(id.xy,0)].xy;
        #else
            float2 MotionVector = MotionVectors.SampleLevel(my_linear_clamp_sampler, (id.xy) / float2(screen_width, screen_height) , 0).xy;
        #endif
        uint2 prevIndex = int2(floor(((float2(id.xy) + 0.5) * float2(rcp(screen_width), rcp(screen_height)) - MotionVector) * float2(screen_width, screen_height)));
        if (prevIndex.x >= 0 && prevIndex.x < screen_width && prevIndex.y >= 0 && prevIndex.y < screen_height) {
            RandomNumsWrite[id.xy] = float4(PrevGlobalColorsA[prevIndex.x + prevIndex.y * screen_width].throughput.yx, 1, 1);
        }
    }
    Rays[pixel_index] = ray;
}


#pragma kernel TransferKernel


[numthreads(1, 1, 1)]
void TransferKernel(uint3 id : SV_DispatchThreadID) {

    BufferData[0] = uint3(ceil(BufferSizes[CurBounce].tracerays / 64.0f), 1, 1);

}

#pragma kernel DepthCopyKernel

[numthreads(32, 32, 1)]
void DepthCopyKernel(uint3 id : SV_DispatchThreadID) {
    if(id.x > screen_width || id.y > screen_height) return;
    float2 Uv = id.xy / float2(screen_width, screen_height);
    Ray ray = CreateCameraRay(Uv * 2.0f - 1.0f);
    #ifdef HDRP
        CorrectedDepthTex[id.xy] = length(ray.direction / dot(ray.direction, Forward) * LinearEyeDepth(Depth[int3(id.xy,0)].x));
    #else
        CorrectedDepthTex[id.xy] = length(ray.direction / dot(ray.direction, Forward) * LinearEyeDepth(Depth.SampleLevel(my_linear_clamp_sampler, Uv, 0).x));   
    #endif
}

#pragma kernel ReSTIRCorectKernel

[numthreads(16, 16, 1)]
void ReSTIRCorectKernel(uint3 id : SV_DispatchThreadID) {//Moved final accumulation into its own kernel, improves performance

    if (id.x >= screen_width || id.y >= screen_height) return;
    int final_pixel_index = id.y * screen_width + id.x;
    
    if(UseReSTIRGI && ReSTIRGIUpdateRate != 0 && PrevGlobalColorsB[final_pixel_index].throughput.x == 0) {
        for(int i = -1; i <= 1; i++) {
            for(int j = -1; j <= 1; j++) {
                int2 Index = int2(id.x + i,id.y + j);
                ReservoirA[Index] = float4(min(1,ReservoirA[Index].x), ReservoirA[Index].yzw);
            }   
        }
    }
}